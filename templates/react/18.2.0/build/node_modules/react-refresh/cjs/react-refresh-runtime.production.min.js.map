{"version":3,"file":"react-refresh-runtime.production.min.js","sources":["../../../../packages/react-refresh/src/ReactFreshRuntime.js"],"sourcesContent":["/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\nimport type {Instance} from 'react-reconciler/src/ReactFiberHostConfig';\nimport type {FiberRoot} from 'react-reconciler/src/ReactInternalTypes';\nimport type {\n  Family,\n  RefreshUpdate,\n  ScheduleRefresh,\n  ScheduleRoot,\n  FindHostInstancesForRefresh,\n  SetRefreshHandler,\n} from 'react-reconciler/src/ReactFiberHotReloading';\nimport type {ReactNodeList} from 'shared/ReactTypes';\n\nimport {REACT_MEMO_TYPE, REACT_FORWARD_REF_TYPE} from 'shared/ReactSymbols';\n\ntype Signature = {|\n  ownKey: string,\n  forceReset: boolean,\n  fullKey: string | null, // Contains keys of nested Hooks. Computed lazily.\n  getCustomHooks: () => Array<Function>,\n|};\n\ntype RendererHelpers = {|\n  findHostInstancesForRefresh: FindHostInstancesForRefresh,\n  scheduleRefresh: ScheduleRefresh,\n  scheduleRoot: ScheduleRoot,\n  setRefreshHandler: SetRefreshHandler,\n|};\n\nif (!__DEV__) {\n  throw new Error(\n    'React Refresh runtime should not be included in the production bundle.',\n  );\n}\n\n// In old environments, we'll leak previous types after every edit.\nconst PossiblyWeakMap = typeof WeakMap === 'function' ? WeakMap : Map;\n\n// We never remove these associations.\n// It's OK to reference families, but use WeakMap/Set for types.\nconst allFamiliesByID: Map<string, Family> = new Map();\nconst allFamiliesByType: // $FlowIssue\nWeakMap<any, Family> | Map<any, Family> = new PossiblyWeakMap();\nconst allSignaturesByType: // $FlowIssue\nWeakMap<any, Signature> | Map<any, Signature> = new PossiblyWeakMap();\n// This WeakMap is read by React, so we only put families\n// that have actually been edited here. This keeps checks fast.\n// $FlowIssue\nconst updatedFamiliesByType: // $FlowIssue\nWeakMap<any, Family> | Map<any, Family> = new PossiblyWeakMap();\n\n// This is cleared on every performReactRefresh() call.\n// It is an array of [Family, NextType] tuples.\nlet pendingUpdates: Array<[Family, any]> = [];\n\n// This is injected by the renderer via DevTools global hook.\nconst helpersByRendererID: Map<number, RendererHelpers> = new Map();\n\nconst helpersByRoot: Map<FiberRoot, RendererHelpers> = new Map();\n\n// We keep track of mounted roots so we can schedule updates.\nconst mountedRoots: Set<FiberRoot> = new Set();\n// If a root captures an error, we remember it so we can retry on edit.\nconst failedRoots: Set<FiberRoot> = new Set();\n\n// In environments that support WeakMap, we also remember the last element for every root.\n// It needs to be weak because we do this even for roots that failed to mount.\n// If there is no WeakMap, we won't attempt to do retrying.\n// $FlowIssue\nconst rootElements: WeakMap<any, ReactNodeList> | null = // $FlowIssue\n  typeof WeakMap === 'function' ? new WeakMap() : null;\n\nlet isPerformingRefresh = false;\n\nfunction computeFullKey(signature: Signature): string {\n  if (signature.fullKey !== null) {\n    return signature.fullKey;\n  }\n\n  let fullKey: string = signature.ownKey;\n  let hooks;\n  try {\n    hooks = signature.getCustomHooks();\n  } catch (err) {\n    // This can happen in an edge case, e.g. if expression like Foo.useSomething\n    // depends on Foo which is lazily initialized during rendering.\n    // In that case just assume we'll have to remount.\n    signature.forceReset = true;\n    signature.fullKey = fullKey;\n    return fullKey;\n  }\n\n  for (let i = 0; i < hooks.length; i++) {\n    const hook = hooks[i];\n    if (typeof hook !== 'function') {\n      // Something's wrong. Assume we need to remount.\n      signature.forceReset = true;\n      signature.fullKey = fullKey;\n      return fullKey;\n    }\n    const nestedHookSignature = allSignaturesByType.get(hook);\n    if (nestedHookSignature === undefined) {\n      // No signature means Hook wasn't in the source code, e.g. in a library.\n      // We'll skip it because we can assume it won't change during this session.\n      continue;\n    }\n    const nestedHookKey = computeFullKey(nestedHookSignature);\n    if (nestedHookSignature.forceReset) {\n      signature.forceReset = true;\n    }\n    fullKey += '\\n---\\n' + nestedHookKey;\n  }\n\n  signature.fullKey = fullKey;\n  return fullKey;\n}\n\nfunction haveEqualSignatures(prevType, nextType) {\n  const prevSignature = allSignaturesByType.get(prevType);\n  const nextSignature = allSignaturesByType.get(nextType);\n\n  if (prevSignature === undefined && nextSignature === undefined) {\n    return true;\n  }\n  if (prevSignature === undefined || nextSignature === undefined) {\n    return false;\n  }\n  if (computeFullKey(prevSignature) !== computeFullKey(nextSignature)) {\n    return false;\n  }\n  if (nextSignature.forceReset) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction isReactClass(type) {\n  return type.prototype && type.prototype.isReactComponent;\n}\n\nfunction canPreserveStateBetween(prevType, nextType) {\n  if (isReactClass(prevType) || isReactClass(nextType)) {\n    return false;\n  }\n  if (haveEqualSignatures(prevType, nextType)) {\n    return true;\n  }\n  return false;\n}\n\nfunction resolveFamily(type) {\n  // Only check updated types to keep lookups fast.\n  return updatedFamiliesByType.get(type);\n}\n\n// If we didn't care about IE11, we could use new Map/Set(iterable).\nfunction cloneMap<K, V>(map: Map<K, V>): Map<K, V> {\n  const clone = new Map();\n  map.forEach((value, key) => {\n    clone.set(key, value);\n  });\n  return clone;\n}\nfunction cloneSet<T>(set: Set<T>): Set<T> {\n  const clone = new Set();\n  set.forEach(value => {\n    clone.add(value);\n  });\n  return clone;\n}\n\n// This is a safety mechanism to protect against rogue getters and Proxies.\nfunction getProperty(object, property) {\n  try {\n    return object[property];\n  } catch (err) {\n    // Intentionally ignore.\n    return undefined;\n  }\n}\n\nexport function performReactRefresh(): RefreshUpdate | null {\n  if (!__DEV__) {\n    throw new Error(\n      'Unexpected call to React Refresh in a production environment.',\n    );\n  }\n  if (pendingUpdates.length === 0) {\n    return null;\n  }\n  if (isPerformingRefresh) {\n    return null;\n  }\n\n  isPerformingRefresh = true;\n  try {\n    const staleFamilies = new Set();\n    const updatedFamilies = new Set();\n\n    const updates = pendingUpdates;\n    pendingUpdates = [];\n    updates.forEach(([family, nextType]) => {\n      // Now that we got a real edit, we can create associations\n      // that will be read by the React reconciler.\n      const prevType = family.current;\n      updatedFamiliesByType.set(prevType, family);\n      updatedFamiliesByType.set(nextType, family);\n      family.current = nextType;\n\n      // Determine whether this should be a re-render or a re-mount.\n      if (canPreserveStateBetween(prevType, nextType)) {\n        updatedFamilies.add(family);\n      } else {\n        staleFamilies.add(family);\n      }\n    });\n\n    // TODO: rename these fields to something more meaningful.\n    const update: RefreshUpdate = {\n      updatedFamilies, // Families that will re-render preserving state\n      staleFamilies, // Families that will be remounted\n    };\n\n    helpersByRendererID.forEach(helpers => {\n      // Even if there are no roots, set the handler on first update.\n      // This ensures that if *new* roots are mounted, they'll use the resolve handler.\n      helpers.setRefreshHandler(resolveFamily);\n    });\n\n    let didError = false;\n    let firstError = null;\n\n    // We snapshot maps and sets that are mutated during commits.\n    // If we don't do this, there is a risk they will be mutated while\n    // we iterate over them. For example, trying to recover a failed root\n    // may cause another root to be added to the failed list -- an infinite loop.\n    const failedRootsSnapshot = cloneSet(failedRoots);\n    const mountedRootsSnapshot = cloneSet(mountedRoots);\n    const helpersByRootSnapshot = cloneMap(helpersByRoot);\n\n    failedRootsSnapshot.forEach(root => {\n      const helpers = helpersByRootSnapshot.get(root);\n      if (helpers === undefined) {\n        throw new Error(\n          'Could not find helpers for a root. This is a bug in React Refresh.',\n        );\n      }\n      if (!failedRoots.has(root)) {\n        // No longer failed.\n      }\n      if (rootElements === null) {\n        return;\n      }\n      if (!rootElements.has(root)) {\n        return;\n      }\n      const element = rootElements.get(root);\n      try {\n        helpers.scheduleRoot(root, element);\n      } catch (err) {\n        if (!didError) {\n          didError = true;\n          firstError = err;\n        }\n        // Keep trying other roots.\n      }\n    });\n    mountedRootsSnapshot.forEach(root => {\n      const helpers = helpersByRootSnapshot.get(root);\n      if (helpers === undefined) {\n        throw new Error(\n          'Could not find helpers for a root. This is a bug in React Refresh.',\n        );\n      }\n      if (!mountedRoots.has(root)) {\n        // No longer mounted.\n      }\n      try {\n        helpers.scheduleRefresh(root, update);\n      } catch (err) {\n        if (!didError) {\n          didError = true;\n          firstError = err;\n        }\n        // Keep trying other roots.\n      }\n    });\n    if (didError) {\n      throw firstError;\n    }\n    return update;\n  } finally {\n    isPerformingRefresh = false;\n  }\n}\n\nexport function register(type: any, id: string): void {\n  if (__DEV__) {\n    if (type === null) {\n      return;\n    }\n    if (typeof type !== 'function' && typeof type !== 'object') {\n      return;\n    }\n\n    // This can happen in an edge case, e.g. if we register\n    // return value of a HOC but it returns a cached component.\n    // Ignore anything but the first registration for each type.\n    if (allFamiliesByType.has(type)) {\n      return;\n    }\n    // Create family or remember to update it.\n    // None of this bookkeeping affects reconciliation\n    // until the first performReactRefresh() call above.\n    let family = allFamiliesByID.get(id);\n    if (family === undefined) {\n      family = {current: type};\n      allFamiliesByID.set(id, family);\n    } else {\n      pendingUpdates.push([family, type]);\n    }\n    allFamiliesByType.set(type, family);\n\n    // Visit inner types because we might not have registered them.\n    if (typeof type === 'object' && type !== null) {\n      switch (getProperty(type, '$$typeof')) {\n        case REACT_FORWARD_REF_TYPE:\n          register(type.render, id + '$render');\n          break;\n        case REACT_MEMO_TYPE:\n          register(type.type, id + '$type');\n          break;\n      }\n    }\n  } else {\n    throw new Error(\n      'Unexpected call to React Refresh in a production environment.',\n    );\n  }\n}\n\nexport function setSignature(\n  type: any,\n  key: string,\n  forceReset?: boolean = false,\n  getCustomHooks?: () => Array<Function>,\n): void {\n  if (__DEV__) {\n    if (!allSignaturesByType.has(type)) {\n      allSignaturesByType.set(type, {\n        forceReset,\n        ownKey: key,\n        fullKey: null,\n        getCustomHooks: getCustomHooks || (() => []),\n      });\n    }\n    // Visit inner types because we might not have signed them.\n    if (typeof type === 'object' && type !== null) {\n      switch (getProperty(type, '$$typeof')) {\n        case REACT_FORWARD_REF_TYPE:\n          setSignature(type.render, key, forceReset, getCustomHooks);\n          break;\n        case REACT_MEMO_TYPE:\n          setSignature(type.type, key, forceReset, getCustomHooks);\n          break;\n      }\n    }\n  } else {\n    throw new Error(\n      'Unexpected call to React Refresh in a production environment.',\n    );\n  }\n}\n\n// This is lazily called during first render for a type.\n// It captures Hook list at that time so inline requires don't break comparisons.\nexport function collectCustomHooksForSignature(type: any) {\n  if (__DEV__) {\n    const signature = allSignaturesByType.get(type);\n    if (signature !== undefined) {\n      computeFullKey(signature);\n    }\n  } else {\n    throw new Error(\n      'Unexpected call to React Refresh in a production environment.',\n    );\n  }\n}\n\nexport function getFamilyByID(id: string): Family | void {\n  if (__DEV__) {\n    return allFamiliesByID.get(id);\n  } else {\n    throw new Error(\n      'Unexpected call to React Refresh in a production environment.',\n    );\n  }\n}\n\nexport function getFamilyByType(type: any): Family | void {\n  if (__DEV__) {\n    return allFamiliesByType.get(type);\n  } else {\n    throw new Error(\n      'Unexpected call to React Refresh in a production environment.',\n    );\n  }\n}\n\nexport function findAffectedHostInstances(\n  families: Array<Family>,\n): Set<Instance> {\n  if (__DEV__) {\n    const affectedInstances = new Set();\n    mountedRoots.forEach(root => {\n      const helpers = helpersByRoot.get(root);\n      if (helpers === undefined) {\n        throw new Error(\n          'Could not find helpers for a root. This is a bug in React Refresh.',\n        );\n      }\n      const instancesForRoot = helpers.findHostInstancesForRefresh(\n        root,\n        families,\n      );\n      instancesForRoot.forEach(inst => {\n        affectedInstances.add(inst);\n      });\n    });\n    return affectedInstances;\n  } else {\n    throw new Error(\n      'Unexpected call to React Refresh in a production environment.',\n    );\n  }\n}\n\nexport function injectIntoGlobalHook(globalObject: any): void {\n  if (__DEV__) {\n    // For React Native, the global hook will be set up by require('react-devtools-core').\n    // That code will run before us. So we need to monkeypatch functions on existing hook.\n\n    // For React Web, the global hook will be set up by the extension.\n    // This will also run before us.\n    let hook = globalObject.__REACT_DEVTOOLS_GLOBAL_HOOK__;\n    if (hook === undefined) {\n      // However, if there is no DevTools extension, we'll need to set up the global hook ourselves.\n      // Note that in this case it's important that renderer code runs *after* this method call.\n      // Otherwise, the renderer will think that there is no global hook, and won't do the injection.\n      let nextID = 0;\n      globalObject.__REACT_DEVTOOLS_GLOBAL_HOOK__ = hook = {\n        renderers: new Map(),\n        supportsFiber: true,\n        inject(injected) {\n          return nextID++;\n        },\n        onScheduleFiberRoot(\n          id: number,\n          root: FiberRoot,\n          children: ReactNodeList,\n        ) {},\n        onCommitFiberRoot(\n          id: number,\n          root: FiberRoot,\n          maybePriorityLevel: mixed,\n          didError: boolean,\n        ) {},\n        onCommitFiberUnmount() {},\n      };\n    }\n\n    if (hook.isDisabled) {\n      // This isn't a real property on the hook, but it can be set to opt out\n      // of DevTools integration and associated warnings and logs.\n      // Using console['warn'] to evade Babel and ESLint\n      console['warn'](\n        'Something has shimmed the React DevTools global hook (__REACT_DEVTOOLS_GLOBAL_HOOK__). ' +\n          'Fast Refresh is not compatible with this shim and will be disabled.',\n      );\n      return;\n    }\n\n    // Here, we just want to get a reference to scheduleRefresh.\n    const oldInject = hook.inject;\n    hook.inject = function(injected) {\n      const id = oldInject.apply(this, arguments);\n      if (\n        typeof injected.scheduleRefresh === 'function' &&\n        typeof injected.setRefreshHandler === 'function'\n      ) {\n        // This version supports React Refresh.\n        helpersByRendererID.set(id, ((injected: any): RendererHelpers));\n      }\n      return id;\n    };\n\n    // Do the same for any already injected roots.\n    // This is useful if ReactDOM has already been initialized.\n    // https://github.com/facebook/react/issues/17626\n    hook.renderers.forEach((injected, id) => {\n      if (\n        typeof injected.scheduleRefresh === 'function' &&\n        typeof injected.setRefreshHandler === 'function'\n      ) {\n        // This version supports React Refresh.\n        helpersByRendererID.set(id, ((injected: any): RendererHelpers));\n      }\n    });\n\n    // We also want to track currently mounted roots.\n    const oldOnCommitFiberRoot = hook.onCommitFiberRoot;\n    const oldOnScheduleFiberRoot = hook.onScheduleFiberRoot || (() => {});\n    hook.onScheduleFiberRoot = function(\n      id: number,\n      root: FiberRoot,\n      children: ReactNodeList,\n    ) {\n      if (!isPerformingRefresh) {\n        // If it was intentionally scheduled, don't attempt to restore.\n        // This includes intentionally scheduled unmounts.\n        failedRoots.delete(root);\n        if (rootElements !== null) {\n          rootElements.set(root, children);\n        }\n      }\n      return oldOnScheduleFiberRoot.apply(this, arguments);\n    };\n    hook.onCommitFiberRoot = function(\n      id: number,\n      root: FiberRoot,\n      maybePriorityLevel: mixed,\n      didError: boolean,\n    ) {\n      const helpers = helpersByRendererID.get(id);\n      if (helpers !== undefined) {\n        helpersByRoot.set(root, helpers);\n\n        const current = root.current;\n        const alternate = current.alternate;\n\n        // We need to determine whether this root has just (un)mounted.\n        // This logic is copy-pasted from similar logic in the DevTools backend.\n        // If this breaks with some refactoring, you'll want to update DevTools too.\n\n        if (alternate !== null) {\n          const wasMounted =\n            alternate.memoizedState != null &&\n            alternate.memoizedState.element != null &&\n            mountedRoots.has(root);\n\n          const isMounted =\n            current.memoizedState != null &&\n            current.memoizedState.element != null;\n\n          if (!wasMounted && isMounted) {\n            // Mount a new root.\n            mountedRoots.add(root);\n            failedRoots.delete(root);\n          } else if (wasMounted && isMounted) {\n            // Update an existing root.\n            // This doesn't affect our mounted root Set.\n          } else if (wasMounted && !isMounted) {\n            // Unmount an existing root.\n            mountedRoots.delete(root);\n            if (didError) {\n              // We'll remount it on future edits.\n              failedRoots.add(root);\n            } else {\n              helpersByRoot.delete(root);\n            }\n          } else if (!wasMounted && !isMounted) {\n            if (didError) {\n              // We'll remount it on future edits.\n              failedRoots.add(root);\n            }\n          }\n        } else {\n          // Mount a new root.\n          mountedRoots.add(root);\n        }\n      }\n\n      // Always call the decorated DevTools hook.\n      return oldOnCommitFiberRoot.apply(this, arguments);\n    };\n  } else {\n    throw new Error(\n      'Unexpected call to React Refresh in a production environment.',\n    );\n  }\n}\n\nexport function hasUnrecoverableErrors() {\n  // TODO: delete this after removing dependency in RN.\n  return false;\n}\n\n// Exposed for testing.\nexport function _getMountedRootCount() {\n  if (__DEV__) {\n    return mountedRoots.size;\n  } else {\n    throw new Error(\n      'Unexpected call to React Refresh in a production environment.',\n    );\n  }\n}\n\n// This is a wrapper over more primitive functions for setting signature.\n// Signatures let us decide whether the Hook order has changed on refresh.\n//\n// This function is intended to be used as a transform target, e.g.:\n// var _s = createSignatureFunctionForTransform()\n//\n// function Hello() {\n//   const [foo, setFoo] = useState(0);\n//   const value = useCustomHook();\n//   _s(); /* Call without arguments triggers collecting the custom Hook list.\n//          * This doesn't happen during the module evaluation because we\n//          * don't want to change the module order with inline requires.\n//          * Next calls are noops. */\n//   return <h1>Hi</h1>;\n// }\n//\n// /* Call with arguments attaches the signature to the type: */\n// _s(\n//   Hello,\n//   'useState{[foo, setFoo]}(0)',\n//   () => [useCustomHook], /* Lazy to avoid triggering inline requires */\n// );\nexport function createSignatureFunctionForTransform() {\n  if (__DEV__) {\n    let savedType;\n    let hasCustomHooks;\n    let didCollectHooks = false;\n    return function<T>(\n      type: T,\n      key: string,\n      forceReset?: boolean,\n      getCustomHooks?: () => Array<Function>,\n    ): T | void {\n      if (typeof key === 'string') {\n        // We're in the initial phase that associates signatures\n        // with the functions. Note this may be called multiple times\n        // in HOC chains like _s(hoc1(_s(hoc2(_s(actualFunction))))).\n        if (!savedType) {\n          // We're in the innermost call, so this is the actual type.\n          savedType = type;\n          hasCustomHooks = typeof getCustomHooks === 'function';\n        }\n        // Set the signature for all types (even wrappers!) in case\n        // they have no signatures of their own. This is to prevent\n        // problems like https://github.com/facebook/react/issues/20417.\n        if (\n          type != null &&\n          (typeof type === 'function' || typeof type === 'object')\n        ) {\n          setSignature(type, key, forceReset, getCustomHooks);\n        }\n        return type;\n      } else {\n        // We're in the _s() call without arguments, which means\n        // this is the time to collect custom Hook signatures.\n        // Only do this once. This path is hot and runs *inside* every render!\n        if (!didCollectHooks && hasCustomHooks) {\n          didCollectHooks = true;\n          collectCustomHooksForSignature(savedType);\n        }\n      }\n    };\n  } else {\n    throw new Error(\n      'Unexpected call to React Refresh in a production environment.',\n    );\n  }\n}\n\nexport function isLikelyComponentType(type: any): boolean {\n  if (__DEV__) {\n    switch (typeof type) {\n      case 'function': {\n        // First, deal with classes.\n        if (type.prototype != null) {\n          if (type.prototype.isReactComponent) {\n            // React class.\n            return true;\n          }\n          const ownNames = Object.getOwnPropertyNames(type.prototype);\n          if (ownNames.length > 1 || ownNames[0] !== 'constructor') {\n            // This looks like a class.\n            return false;\n          }\n          // eslint-disable-next-line no-proto\n          if (type.prototype.__proto__ !== Object.prototype) {\n            // It has a superclass.\n            return false;\n          }\n          // Pass through.\n          // This looks like a regular function with empty prototype.\n        }\n        // For plain functions and arrows, use name as a heuristic.\n        const name = type.name || type.displayName;\n        return typeof name === 'string' && /^[A-Z]/.test(name);\n      }\n      case 'object': {\n        if (type != null) {\n          switch (getProperty(type, '$$typeof')) {\n            case REACT_FORWARD_REF_TYPE:\n            case REACT_MEMO_TYPE:\n              // Definitely React components.\n              return true;\n            default:\n              return false;\n          }\n        }\n        return false;\n      }\n      default: {\n        return false;\n      }\n    }\n  } else {\n    throw new Error(\n      'Unexpected call to React Refresh in a production environment.',\n    );\n  }\n}\n"],"names":["Error","performReactRefresh","register","type","id","setSignature","key","collectCustomHooksForSignature","getFamilyByID","getFamilyByType","findAffectedHostInstances","families","injectIntoGlobalHook","globalObject","hasUnrecoverableErrors","_getMountedRootCount","createSignatureFunctionForTransform","isLikelyComponentType"],"mappings":";;AAqCc;AACZ,QAAM,IAAIA,KAAJ,CACJ,wEADI,CAAN;AAGD;;AAqJM,SAASC,mBAAT,GAAqD;AAC1D,EAAc;AACZ,UAAM,IAAID,KAAJ,CACJ,+DADI,CAAN;AAGD;AA4GF;AAEM,SAASE,QAAT,CAAkBC,IAAlB,EAA6BC,EAA7B,EAA+C;AACpD,EAqCO;AACL,UAAM,IAAIJ,KAAJ,CACJ,+DADI,CAAN;AAGD;AACF;AAEM,SAASK,YAAT,CACLF,IADK,EAELG,GAFK,EAKC;;AACN,EAoBO;AACL,UAAM,IAAIN,KAAJ,CACJ,+DADI,CAAN;AAGD;AACF;AAGD;;AACO,SAASO,8BAAT,CAAwCJ,IAAxC,EAAmD;AACxD,EAKO;AACL,UAAM,IAAIH,KAAJ,CACJ,+DADI,CAAN;AAGD;AACF;AAEM,SAASQ,aAAT,CAAuBJ,EAAvB,EAAkD;AACvD,EAEO;AACL,UAAM,IAAIJ,KAAJ,CACJ,+DADI,CAAN;AAGD;AACF;AAEM,SAASS,eAAT,CAAyBN,IAAzB,EAAmD;AACxD,EAEO;AACL,UAAM,IAAIH,KAAJ,CACJ,+DADI,CAAN;AAGD;AACF;AAEM,SAASU,yBAAT,CACLC,QADK,EAEU;AACf,EAkBO;AACL,UAAM,IAAIX,KAAJ,CACJ,+DADI,CAAN;AAGD;AACF;AAEM,SAASY,oBAAT,CAA8BC,YAA9B,EAAuD;AAC5D,EAmJO;AACL,UAAM,IAAIb,KAAJ,CACJ,+DADI,CAAN;AAGD;AACF;AAEM,SAASc,sBAAT,GAAkC;AACvC;AACA,SAAO,KAAP;AACD;;AAGM,SAASC,oBAAT,GAAgC;AACrC,EAEO;AACL,UAAM,IAAIf,KAAJ,CACJ,+DADI,CAAN;AAGD;AACF;AAGD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACO,SAASgB,mCAAT,GAA+C;AACpD,EAuCO;AACL,UAAM,IAAIhB,KAAJ,CACJ,+DADI,CAAN;AAGD;AACF;AAEM,SAASiB,qBAAT,CAA+Bd,IAA/B,EAAmD;AACxD,EA2CO;AACL,UAAM,IAAIH,KAAJ,CACJ,+DADI,CAAN;AAGD;AACF;;;;;;;;;;;;;;;"}