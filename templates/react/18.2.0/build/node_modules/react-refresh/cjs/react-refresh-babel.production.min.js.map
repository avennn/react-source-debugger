{"version":3,"file":"react-refresh-babel.production.min.js","sources":["../../../../packages/react-refresh/src/ReactFreshBabelPlugin.js"],"sourcesContent":["/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n'use strict';\n\nexport default function(babel, opts = {}) {\n  if (typeof babel.env === 'function') {\n    // Only available in Babel 7.\n    const env = babel.env();\n    if (env !== 'development' && !opts.skipEnvCheck) {\n      throw new Error(\n        'React Refresh Babel transform should only be enabled in development environment. ' +\n          'Instead, the environment is: \"' +\n          env +\n          '\". If you want to override this check, pass {skipEnvCheck: true} as plugin options.',\n      );\n    }\n  }\n\n  const {types: t} = babel;\n  const refreshReg = t.identifier(opts.refreshReg || '$RefreshReg$');\n  const refreshSig = t.identifier(opts.refreshSig || '$RefreshSig$');\n\n  const registrationsByProgramPath = new Map();\n  function createRegistration(programPath, persistentID) {\n    const handle = programPath.scope.generateUidIdentifier('c');\n    if (!registrationsByProgramPath.has(programPath)) {\n      registrationsByProgramPath.set(programPath, []);\n    }\n    const registrations = registrationsByProgramPath.get(programPath);\n    registrations.push({\n      handle,\n      persistentID,\n    });\n    return handle;\n  }\n\n  function isComponentishName(name) {\n    return typeof name === 'string' && name[0] >= 'A' && name[0] <= 'Z';\n  }\n\n  function findInnerComponents(inferredName, path, callback) {\n    const node = path.node;\n    switch (node.type) {\n      case 'Identifier': {\n        if (!isComponentishName(node.name)) {\n          return false;\n        }\n        // export default hoc(Foo)\n        // const X = hoc(Foo)\n        callback(inferredName, node, null);\n        return true;\n      }\n      case 'FunctionDeclaration': {\n        // function Foo() {}\n        // export function Foo() {}\n        // export default function Foo() {}\n        callback(inferredName, node.id, null);\n        return true;\n      }\n      case 'ArrowFunctionExpression': {\n        if (node.body.type === 'ArrowFunctionExpression') {\n          return false;\n        }\n        // let Foo = () => {}\n        // export default hoc1(hoc2(() => {}))\n        callback(inferredName, node, path);\n        return true;\n      }\n      case 'FunctionExpression': {\n        // let Foo = function() {}\n        // const Foo = hoc1(forwardRef(function renderFoo() {}))\n        // export default memo(function() {})\n        callback(inferredName, node, path);\n        return true;\n      }\n      case 'CallExpression': {\n        const argsPath = path.get('arguments');\n        if (argsPath === undefined || argsPath.length === 0) {\n          return false;\n        }\n        const calleePath = path.get('callee');\n        switch (calleePath.node.type) {\n          case 'MemberExpression':\n          case 'Identifier': {\n            const calleeSource = calleePath.getSource();\n            const firstArgPath = argsPath[0];\n            const innerName = inferredName + '$' + calleeSource;\n            const foundInside = findInnerComponents(\n              innerName,\n              firstArgPath,\n              callback,\n            );\n            if (!foundInside) {\n              return false;\n            }\n            // const Foo = hoc1(hoc2(() => {}))\n            // export default memo(React.forwardRef(function() {}))\n            callback(inferredName, node, path);\n            return true;\n          }\n          default: {\n            return false;\n          }\n        }\n      }\n      case 'VariableDeclarator': {\n        const init = node.init;\n        if (init === null) {\n          return false;\n        }\n        const name = node.id.name;\n        if (!isComponentishName(name)) {\n          return false;\n        }\n        switch (init.type) {\n          case 'ArrowFunctionExpression':\n          case 'FunctionExpression':\n            // Likely component definitions.\n            break;\n          case 'CallExpression': {\n            // Maybe a HOC.\n            // Try to determine if this is some form of import.\n            const callee = init.callee;\n            const calleeType = callee.type;\n            if (calleeType === 'Import') {\n              return false;\n            } else if (calleeType === 'Identifier') {\n              if (callee.name.indexOf('require') === 0) {\n                return false;\n              } else if (callee.name.indexOf('import') === 0) {\n                return false;\n              }\n              // Neither require nor import. Might be a HOC.\n              // Pass through.\n            } else if (calleeType === 'MemberExpression') {\n              // Could be something like React.forwardRef(...)\n              // Pass through.\n            }\n            break;\n          }\n          case 'TaggedTemplateExpression':\n            // Maybe something like styled.div`...`\n            break;\n          default:\n            return false;\n        }\n        const initPath = path.get('init');\n        const foundInside = findInnerComponents(\n          inferredName,\n          initPath,\n          callback,\n        );\n        if (foundInside) {\n          return true;\n        }\n        // See if this identifier is used in JSX. Then it's a component.\n        const binding = path.scope.getBinding(name);\n        if (binding === undefined) {\n          return;\n        }\n        let isLikelyUsedAsType = false;\n        const referencePaths = binding.referencePaths;\n        for (let i = 0; i < referencePaths.length; i++) {\n          const ref = referencePaths[i];\n          if (\n            ref.node &&\n            ref.node.type !== 'JSXIdentifier' &&\n            ref.node.type !== 'Identifier'\n          ) {\n            continue;\n          }\n          const refParent = ref.parent;\n          if (refParent.type === 'JSXOpeningElement') {\n            isLikelyUsedAsType = true;\n          } else if (refParent.type === 'CallExpression') {\n            const callee = refParent.callee;\n            let fnName;\n            switch (callee.type) {\n              case 'Identifier':\n                fnName = callee.name;\n                break;\n              case 'MemberExpression':\n                fnName = callee.property.name;\n                break;\n            }\n            switch (fnName) {\n              case 'createElement':\n              case 'jsx':\n              case 'jsxDEV':\n              case 'jsxs':\n                isLikelyUsedAsType = true;\n                break;\n            }\n          }\n          if (isLikelyUsedAsType) {\n            // const X = ... + later <X />\n            callback(inferredName, init, initPath);\n            return true;\n          }\n        }\n      }\n    }\n    return false;\n  }\n\n  function isBuiltinHook(hookName) {\n    switch (hookName) {\n      case 'useState':\n      case 'React.useState':\n      case 'useReducer':\n      case 'React.useReducer':\n      case 'useEffect':\n      case 'React.useEffect':\n      case 'useLayoutEffect':\n      case 'React.useLayoutEffect':\n      case 'useMemo':\n      case 'React.useMemo':\n      case 'useCallback':\n      case 'React.useCallback':\n      case 'useRef':\n      case 'React.useRef':\n      case 'useContext':\n      case 'React.useContext':\n      case 'useImperativeHandle':\n      case 'React.useImperativeHandle':\n      case 'useDebugValue':\n      case 'React.useDebugValue':\n        return true;\n      default:\n        return false;\n    }\n  }\n\n  function getHookCallsSignature(functionNode) {\n    const fnHookCalls = hookCalls.get(functionNode);\n    if (fnHookCalls === undefined) {\n      return null;\n    }\n    return {\n      key: fnHookCalls.map(call => call.name + '{' + call.key + '}').join('\\n'),\n      customHooks: fnHookCalls\n        .filter(call => !isBuiltinHook(call.name))\n        .map(call => t.cloneDeep(call.callee)),\n    };\n  }\n\n  const hasForceResetCommentByFile = new WeakMap();\n\n  // We let user do /* @refresh reset */ to reset state in the whole file.\n  function hasForceResetComment(path) {\n    const file = path.hub.file;\n    let hasForceReset = hasForceResetCommentByFile.get(file);\n    if (hasForceReset !== undefined) {\n      return hasForceReset;\n    }\n\n    hasForceReset = false;\n    const comments = file.ast.comments;\n    for (let i = 0; i < comments.length; i++) {\n      const cmt = comments[i];\n      if (cmt.value.indexOf('@refresh reset') !== -1) {\n        hasForceReset = true;\n        break;\n      }\n    }\n\n    hasForceResetCommentByFile.set(file, hasForceReset);\n    return hasForceReset;\n  }\n\n  function createArgumentsForSignature(node, signature, scope) {\n    const {key, customHooks} = signature;\n\n    let forceReset = hasForceResetComment(scope.path);\n    const customHooksInScope = [];\n    customHooks.forEach(callee => {\n      // Check if a corresponding binding exists where we emit the signature.\n      let bindingName;\n      switch (callee.type) {\n        case 'MemberExpression':\n          if (callee.object.type === 'Identifier') {\n            bindingName = callee.object.name;\n          }\n          break;\n        case 'Identifier':\n          bindingName = callee.name;\n          break;\n      }\n      if (scope.hasBinding(bindingName)) {\n        customHooksInScope.push(callee);\n      } else {\n        // We don't have anything to put in the array because Hook is out of scope.\n        // Since it could potentially have been edited, remount the component.\n        forceReset = true;\n      }\n    });\n\n    let finalKey = key;\n    if (typeof require === 'function' && !opts.emitFullSignatures) {\n      // Prefer to hash when we can (e.g. outside of ASTExplorer).\n      // This makes it deterministically compact, even if there's\n      // e.g. a useState initializer with some code inside.\n      // We also need it for www that has transforms like cx()\n      // that don't understand if something is part of a string.\n      finalKey = require('crypto')\n        .createHash('sha1')\n        .update(key)\n        .digest('base64');\n    }\n\n    const args = [node, t.stringLiteral(finalKey)];\n    if (forceReset || customHooksInScope.length > 0) {\n      args.push(t.booleanLiteral(forceReset));\n    }\n    if (customHooksInScope.length > 0) {\n      args.push(\n        // TODO: We could use an arrow here to be more compact.\n        // However, don't do it until AMA can run them natively.\n        t.functionExpression(\n          null,\n          [],\n          t.blockStatement([\n            t.returnStatement(t.arrayExpression(customHooksInScope)),\n          ]),\n        ),\n      );\n    }\n    return args;\n  }\n\n  function findHOCCallPathsAbove(path) {\n    const calls = [];\n    while (true) {\n      if (!path) {\n        return calls;\n      }\n      const parentPath = path.parentPath;\n      if (!parentPath) {\n        return calls;\n      }\n      if (\n        // hoc(_c = function() { })\n        parentPath.node.type === 'AssignmentExpression' &&\n        path.node === parentPath.node.right\n      ) {\n        // Ignore registrations.\n        path = parentPath;\n        continue;\n      }\n      if (\n        // hoc1(hoc2(...))\n        parentPath.node.type === 'CallExpression' &&\n        path.node !== parentPath.node.callee\n      ) {\n        calls.push(parentPath);\n        path = parentPath;\n        continue;\n      }\n      return calls; // Stop at other types.\n    }\n  }\n\n  const seenForRegistration = new WeakSet();\n  const seenForSignature = new WeakSet();\n  const seenForOutro = new WeakSet();\n\n  const hookCalls = new WeakMap();\n  const HookCallsVisitor = {\n    CallExpression(path) {\n      const node = path.node;\n      const callee = node.callee;\n\n      // Note: this visitor MUST NOT mutate the tree in any way.\n      // It runs early in a separate traversal and should be very fast.\n\n      let name = null;\n      switch (callee.type) {\n        case 'Identifier':\n          name = callee.name;\n          break;\n        case 'MemberExpression':\n          name = callee.property.name;\n          break;\n      }\n      if (name === null || !/^use[A-Z]/.test(name)) {\n        return;\n      }\n      const fnScope = path.scope.getFunctionParent();\n      if (fnScope === null) {\n        return;\n      }\n\n      // This is a Hook call. Record it.\n      const fnNode = fnScope.block;\n      if (!hookCalls.has(fnNode)) {\n        hookCalls.set(fnNode, []);\n      }\n      const hookCallsForFn = hookCalls.get(fnNode);\n      let key = '';\n      if (path.parent.type === 'VariableDeclarator') {\n        // TODO: if there is no LHS, consider some other heuristic.\n        key = path.parentPath.get('id').getSource();\n      }\n\n      // Some built-in Hooks reset on edits to arguments.\n      const args = path.get('arguments');\n      if (name === 'useState' && args.length > 0) {\n        // useState second argument is initial state.\n        key += '(' + args[0].getSource() + ')';\n      } else if (name === 'useReducer' && args.length > 1) {\n        // useReducer second argument is initial state.\n        key += '(' + args[1].getSource() + ')';\n      }\n\n      hookCallsForFn.push({\n        callee: path.node.callee,\n        name,\n        key,\n      });\n    },\n  };\n\n  return {\n    visitor: {\n      ExportDefaultDeclaration(path) {\n        const node = path.node;\n        const decl = node.declaration;\n        const declPath = path.get('declaration');\n        if (decl.type !== 'CallExpression') {\n          // For now, we only support possible HOC calls here.\n          // Named function declarations are handled in FunctionDeclaration.\n          // Anonymous direct exports like export default function() {}\n          // are currently ignored.\n          return;\n        }\n\n        // Make sure we're not mutating the same tree twice.\n        // This can happen if another Babel plugin replaces parents.\n        if (seenForRegistration.has(node)) {\n          return;\n        }\n        seenForRegistration.add(node);\n        // Don't mutate the tree above this point.\n\n        // This code path handles nested cases like:\n        // export default memo(() => {})\n        // In those cases it is more plausible people will omit names\n        // so they're worth handling despite possible false positives.\n        // More importantly, it handles the named case:\n        // export default memo(function Named() {})\n        const inferredName = '%default%';\n        const programPath = path.parentPath;\n        findInnerComponents(\n          inferredName,\n          declPath,\n          (persistentID, targetExpr, targetPath) => {\n            if (targetPath === null) {\n              // For case like:\n              // export default hoc(Foo)\n              // we don't want to wrap Foo inside the call.\n              // Instead we assume it's registered at definition.\n              return;\n            }\n            const handle = createRegistration(programPath, persistentID);\n            targetPath.replaceWith(\n              t.assignmentExpression('=', handle, targetExpr),\n            );\n          },\n        );\n      },\n      FunctionDeclaration: {\n        enter(path) {\n          const node = path.node;\n          let programPath;\n          let insertAfterPath;\n          let modulePrefix = '';\n          switch (path.parent.type) {\n            case 'Program':\n              insertAfterPath = path;\n              programPath = path.parentPath;\n              break;\n            case 'TSModuleBlock':\n              insertAfterPath = path;\n              programPath = insertAfterPath.parentPath.parentPath;\n              break;\n            case 'ExportNamedDeclaration':\n              insertAfterPath = path.parentPath;\n              programPath = insertAfterPath.parentPath;\n              break;\n            case 'ExportDefaultDeclaration':\n              insertAfterPath = path.parentPath;\n              programPath = insertAfterPath.parentPath;\n              break;\n            default:\n              return;\n          }\n\n          // These types can be nested in typescript namespace\n          // We need to find the export chain\n          // Or return if it stays local\n          if (\n            path.parent.type === 'TSModuleBlock' ||\n            path.parent.type === 'ExportNamedDeclaration'\n          ) {\n            while (programPath.type !== 'Program') {\n              if (programPath.type === 'TSModuleDeclaration') {\n                if (\n                  programPath.parentPath.type !== 'Program' &&\n                  programPath.parentPath.type !== 'ExportNamedDeclaration'\n                ) {\n                  return;\n                }\n                modulePrefix = programPath.node.id.name + '$' + modulePrefix;\n              }\n              programPath = programPath.parentPath;\n            }\n          }\n\n          const id = node.id;\n          if (id === null) {\n            // We don't currently handle anonymous default exports.\n            return;\n          }\n          const inferredName = id.name;\n          if (!isComponentishName(inferredName)) {\n            return;\n          }\n\n          // Make sure we're not mutating the same tree twice.\n          // This can happen if another Babel plugin replaces parents.\n          if (seenForRegistration.has(node)) {\n            return;\n          }\n          seenForRegistration.add(node);\n          // Don't mutate the tree above this point.\n\n          const innerName = modulePrefix + inferredName;\n          // export function Named() {}\n          // function Named() {}\n          findInnerComponents(innerName, path, (persistentID, targetExpr) => {\n            const handle = createRegistration(programPath, persistentID);\n            insertAfterPath.insertAfter(\n              t.expressionStatement(\n                t.assignmentExpression('=', handle, targetExpr),\n              ),\n            );\n          });\n        },\n        exit(path) {\n          const node = path.node;\n          const id = node.id;\n          if (id === null) {\n            return;\n          }\n          const signature = getHookCallsSignature(node);\n          if (signature === null) {\n            return;\n          }\n\n          // Make sure we're not mutating the same tree twice.\n          // This can happen if another Babel plugin replaces parents.\n          if (seenForSignature.has(node)) {\n            return;\n          }\n          seenForSignature.add(node);\n          // Don't mutate the tree above this point.\n\n          const sigCallID = path.scope.generateUidIdentifier('_s');\n          path.scope.parent.push({\n            id: sigCallID,\n            init: t.callExpression(refreshSig, []),\n          });\n\n          // The signature call is split in two parts. One part is called inside the function.\n          // This is used to signal when first render happens.\n          path\n            .get('body')\n            .unshiftContainer(\n              'body',\n              t.expressionStatement(t.callExpression(sigCallID, [])),\n            );\n\n          // The second call is around the function itself.\n          // This is used to associate a type with a signature.\n\n          // Unlike with $RefreshReg$, this needs to work for nested\n          // declarations too. So we need to search for a path where\n          // we can insert a statement rather than hard coding it.\n          let insertAfterPath = null;\n          path.find(p => {\n            if (p.parentPath.isBlock()) {\n              insertAfterPath = p;\n              return true;\n            }\n          });\n          if (insertAfterPath === null) {\n            return;\n          }\n\n          insertAfterPath.insertAfter(\n            t.expressionStatement(\n              t.callExpression(\n                sigCallID,\n                createArgumentsForSignature(\n                  id,\n                  signature,\n                  insertAfterPath.scope,\n                ),\n              ),\n            ),\n          );\n        },\n      },\n      'ArrowFunctionExpression|FunctionExpression': {\n        exit(path) {\n          const node = path.node;\n          const signature = getHookCallsSignature(node);\n          if (signature === null) {\n            return;\n          }\n\n          // Make sure we're not mutating the same tree twice.\n          // This can happen if another Babel plugin replaces parents.\n          if (seenForSignature.has(node)) {\n            return;\n          }\n          seenForSignature.add(node);\n          // Don't mutate the tree above this point.\n\n          const sigCallID = path.scope.generateUidIdentifier('_s');\n          path.scope.parent.push({\n            id: sigCallID,\n            init: t.callExpression(refreshSig, []),\n          });\n\n          // The signature call is split in two parts. One part is called inside the function.\n          // This is used to signal when first render happens.\n          if (path.node.body.type !== 'BlockStatement') {\n            path.node.body = t.blockStatement([\n              t.returnStatement(path.node.body),\n            ]);\n          }\n          path\n            .get('body')\n            .unshiftContainer(\n              'body',\n              t.expressionStatement(t.callExpression(sigCallID, [])),\n            );\n\n          // The second call is around the function itself.\n          // This is used to associate a type with a signature.\n\n          if (path.parent.type === 'VariableDeclarator') {\n            let insertAfterPath = null;\n            path.find(p => {\n              if (p.parentPath.isBlock()) {\n                insertAfterPath = p;\n                return true;\n              }\n            });\n            if (insertAfterPath === null) {\n              return;\n            }\n            // Special case when a function would get an inferred name:\n            // let Foo = () => {}\n            // let Foo = function() {}\n            // We'll add signature it on next line so that\n            // we don't mess up the inferred 'Foo' function name.\n            insertAfterPath.insertAfter(\n              t.expressionStatement(\n                t.callExpression(\n                  sigCallID,\n                  createArgumentsForSignature(\n                    path.parent.id,\n                    signature,\n                    insertAfterPath.scope,\n                  ),\n                ),\n              ),\n            );\n            // Result: let Foo = () => {}; __signature(Foo, ...);\n          } else {\n            // let Foo = hoc(() => {})\n            const paths = [path, ...findHOCCallPathsAbove(path)];\n            paths.forEach(p => {\n              p.replaceWith(\n                t.callExpression(\n                  sigCallID,\n                  createArgumentsForSignature(p.node, signature, p.scope),\n                ),\n              );\n            });\n            // Result: let Foo = __signature(hoc(__signature(() => {}, ...)), ...)\n          }\n        },\n      },\n      VariableDeclaration(path) {\n        const node = path.node;\n        let programPath;\n        let insertAfterPath;\n        let modulePrefix = '';\n        switch (path.parent.type) {\n          case 'Program':\n            insertAfterPath = path;\n            programPath = path.parentPath;\n            break;\n          case 'TSModuleBlock':\n            insertAfterPath = path;\n            programPath = insertAfterPath.parentPath.parentPath;\n            break;\n          case 'ExportNamedDeclaration':\n            insertAfterPath = path.parentPath;\n            programPath = insertAfterPath.parentPath;\n            break;\n          case 'ExportDefaultDeclaration':\n            insertAfterPath = path.parentPath;\n            programPath = insertAfterPath.parentPath;\n            break;\n          default:\n            return;\n        }\n\n        // These types can be nested in typescript namespace\n        // We need to find the export chain\n        // Or return if it stays local\n        if (\n          path.parent.type === 'TSModuleBlock' ||\n          path.parent.type === 'ExportNamedDeclaration'\n        ) {\n          while (programPath.type !== 'Program') {\n            if (programPath.type === 'TSModuleDeclaration') {\n              if (\n                programPath.parentPath.type !== 'Program' &&\n                programPath.parentPath.type !== 'ExportNamedDeclaration'\n              ) {\n                return;\n              }\n              modulePrefix = programPath.node.id.name + '$' + modulePrefix;\n            }\n            programPath = programPath.parentPath;\n          }\n        }\n\n        // Make sure we're not mutating the same tree twice.\n        // This can happen if another Babel plugin replaces parents.\n        if (seenForRegistration.has(node)) {\n          return;\n        }\n        seenForRegistration.add(node);\n        // Don't mutate the tree above this point.\n\n        const declPaths = path.get('declarations');\n        if (declPaths.length !== 1) {\n          return;\n        }\n        const declPath = declPaths[0];\n        const inferredName = declPath.node.id.name;\n        const innerName = modulePrefix + inferredName;\n        findInnerComponents(\n          innerName,\n          declPath,\n          (persistentID, targetExpr, targetPath) => {\n            if (targetPath === null) {\n              // For case like:\n              // export const Something = hoc(Foo)\n              // we don't want to wrap Foo inside the call.\n              // Instead we assume it's registered at definition.\n              return;\n            }\n            const handle = createRegistration(programPath, persistentID);\n            if (targetPath.parent.type === 'VariableDeclarator') {\n              // Special case when a variable would get an inferred name:\n              // let Foo = () => {}\n              // let Foo = function() {}\n              // let Foo = styled.div``;\n              // We'll register it on next line so that\n              // we don't mess up the inferred 'Foo' function name.\n              // (eg: with @babel/plugin-transform-react-display-name or\n              // babel-plugin-styled-components)\n              insertAfterPath.insertAfter(\n                t.expressionStatement(\n                  t.assignmentExpression('=', handle, declPath.node.id),\n                ),\n              );\n              // Result: let Foo = () => {}; _c1 = Foo;\n            } else {\n              // let Foo = hoc(() => {})\n              targetPath.replaceWith(\n                t.assignmentExpression('=', handle, targetExpr),\n              );\n              // Result: let Foo = hoc(_c1 = () => {})\n            }\n          },\n        );\n      },\n      Program: {\n        enter(path) {\n          // This is a separate early visitor because we need to collect Hook calls\n          // and \"const [foo, setFoo] = ...\" signatures before the destructuring\n          // transform mangles them. This extra traversal is not ideal for perf,\n          // but it's the best we can do until we stop transpiling destructuring.\n          path.traverse(HookCallsVisitor);\n        },\n        exit(path) {\n          const registrations = registrationsByProgramPath.get(path);\n          if (registrations === undefined) {\n            return;\n          }\n\n          // Make sure we're not mutating the same tree twice.\n          // This can happen if another Babel plugin replaces parents.\n          const node = path.node;\n          if (seenForOutro.has(node)) {\n            return;\n          }\n          seenForOutro.add(node);\n          // Don't mutate the tree above this point.\n\n          registrationsByProgramPath.delete(path);\n          const declarators = [];\n          path.pushContainer('body', t.variableDeclaration('var', declarators));\n          registrations.forEach(({handle, persistentID}) => {\n            path.pushContainer(\n              'body',\n              t.expressionStatement(\n                t.callExpression(refreshReg, [\n                  handle,\n                  t.stringLiteral(persistentID),\n                ]),\n              ),\n            );\n            declarators.push(t.variableDeclarator(handle));\n          });\n        },\n      },\n    },\n  };\n}\n"],"names":["babel","opts","env","skipEnvCheck","Error","t","types","refreshReg","identifier","refreshSig","registrationsByProgramPath","Map","createRegistration","programPath","persistentID","handle","scope","generateUidIdentifier","has","set","registrations","get","push","isComponentishName","name","findInnerComponents","inferredName","path","callback","node","type","id","body","argsPath","undefined","length","calleePath","calleeSource","getSource","firstArgPath","innerName","foundInside","init","callee","calleeType","indexOf","initPath","binding","getBinding","isLikelyUsedAsType","referencePaths","i","ref","refParent","parent","fnName","property","isBuiltinHook","hookName","getHookCallsSignature","functionNode","fnHookCalls","hookCalls","key","map","call","join","customHooks","filter","cloneDeep","hasForceResetCommentByFile","WeakMap","hasForceResetComment","file","hub","hasForceReset","comments","ast","cmt","value","createArgumentsForSignature","signature","forceReset","customHooksInScope","forEach","bindingName","object","hasBinding","finalKey","require","emitFullSignatures","createHash","update","digest","args","stringLiteral","booleanLiteral","functionExpression","blockStatement","returnStatement","arrayExpression","findHOCCallPathsAbove","calls","parentPath","right","seenForRegistration","WeakSet","seenForSignature","seenForOutro","HookCallsVisitor","CallExpression","test","fnScope","getFunctionParent","fnNode","block","hookCallsForFn","visitor","ExportDefaultDeclaration","decl","declaration","declPath","add","targetExpr","targetPath","replaceWith","assignmentExpression","FunctionDeclaration","enter","insertAfterPath","modulePrefix","insertAfter","expressionStatement","exit","sigCallID","callExpression","unshiftContainer","find","p","isBlock","paths","VariableDeclaration","declPaths","Program","traverse","delete","declarators","pushContainer","variableDeclaration","variableDeclarator"],"mappings":"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"}