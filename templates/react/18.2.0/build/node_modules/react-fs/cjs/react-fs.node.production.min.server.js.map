{"version":3,"file":"react-fs.node.production.min.server.js","sources":["../../../../packages/react-fs/src/ReactFilesystem.js"],"sourcesContent":["/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\nimport type {Wakeable, Thenable} from 'shared/ReactTypes';\n\nimport {unstable_getCacheForType} from 'react';\nimport * as fs from 'fs/promises';\nimport {isAbsolute, normalize} from 'path';\n\nconst Pending = 0;\nconst Resolved = 1;\nconst Rejected = 2;\n\ntype PendingRecord = {|\n  status: 0,\n  value: Wakeable,\n  cache: null,\n|};\n\ntype ResolvedRecord<T> = {|\n  status: 1,\n  value: T,\n  cache: null | Array<mixed>,\n|};\n\ntype RejectedRecord = {|\n  status: 2,\n  value: mixed,\n  cache: null,\n|};\n\ntype Record<T> = PendingRecord | ResolvedRecord<T> | RejectedRecord;\n\nfunction createRecordFromThenable<T>(thenable: Thenable<T>): Record<T> {\n  const record: Record<T> = {\n    status: Pending,\n    value: thenable,\n    cache: null,\n  };\n  thenable.then(\n    value => {\n      if (record.status === Pending) {\n        const resolvedRecord = ((record: any): ResolvedRecord<T>);\n        resolvedRecord.status = Resolved;\n        resolvedRecord.value = value;\n      }\n    },\n    err => {\n      if (record.status === Pending) {\n        const rejectedRecord = ((record: any): RejectedRecord);\n        rejectedRecord.status = Rejected;\n        rejectedRecord.value = err;\n      }\n    },\n  );\n  return record;\n}\n\nfunction readRecord<T>(record: Record<T>): ResolvedRecord<T> {\n  if (record.status === Resolved) {\n    // This is just a type refinement.\n    return record;\n  } else {\n    throw record.value;\n  }\n}\n\n// We don't want to normalize every path ourselves in production.\n// However, relative or non-normalized paths will lead to cache misses.\n// So we encourage the developer to fix it in DEV and normalize on their end.\nfunction checkPathInDev(path: string) {\n  if (__DEV__) {\n    if (!isAbsolute(path)) {\n      console.error(\n        'The provided path was not absolute: \"%s\". ' +\n          'Convert it to an absolute path first.',\n        path,\n      );\n    } else if (path !== normalize(path)) {\n      console.error(\n        'The provided path was not normalized: \"%s\". ' +\n          'Convert it to a normalized path first.',\n        path,\n      );\n    }\n  }\n}\n\nfunction createAccessMap(): Map<string, Array<number | Record<void>>> {\n  return new Map();\n}\n\nexport function access(path: string, mode?: number): void {\n  checkPathInDev(path);\n  if (mode == null) {\n    mode = 0; // fs.constants.F_OK\n  }\n  const map = unstable_getCacheForType(createAccessMap);\n  let accessCache = map.get(path);\n  if (!accessCache) {\n    accessCache = [];\n    map.set(path, accessCache);\n  }\n  let record;\n  for (let i = 0; i < accessCache.length; i += 2) {\n    const cachedMode: number = (accessCache[i]: any);\n    if (mode === cachedMode) {\n      const cachedRecord: Record<void> = (accessCache[i + 1]: any);\n      record = cachedRecord;\n      break;\n    }\n  }\n  if (!record) {\n    const thenable = fs.access(path, mode);\n    record = createRecordFromThenable(thenable);\n    accessCache.push(mode, record);\n  }\n  readRecord(record); // No return value.\n}\n\nfunction createLstatMap(): Map<string, Array<boolean | Record<mixed>>> {\n  return new Map();\n}\n\nexport function lstat(path: string, options?: {bigint?: boolean}): mixed {\n  checkPathInDev(path);\n  let bigint = false;\n  if (options && options.bigint) {\n    bigint = true;\n  }\n  const map = unstable_getCacheForType(createLstatMap);\n  let lstatCache = map.get(path);\n  if (!lstatCache) {\n    lstatCache = [];\n    map.set(path, lstatCache);\n  }\n  let record;\n  for (let i = 0; i < lstatCache.length; i += 2) {\n    const cachedBigint: boolean = (lstatCache[i]: any);\n    if (bigint === cachedBigint) {\n      const cachedRecord: Record<void> = (lstatCache[i + 1]: any);\n      record = cachedRecord;\n      break;\n    }\n  }\n  if (!record) {\n    const thenable = fs.lstat(path, {bigint});\n    record = createRecordFromThenable(thenable);\n    lstatCache.push(bigint, record);\n  }\n  const stats = readRecord(record).value;\n  return stats;\n}\n\nfunction createReaddirMap(): Map<\n  string,\n  Array<string | boolean | Record<mixed>>,\n> {\n  return new Map();\n}\n\nexport function readdir(\n  path: string,\n  options?: string | {encoding?: string, withFileTypes?: boolean},\n): mixed {\n  checkPathInDev(path);\n  let encoding = 'utf8';\n  let withFileTypes = false;\n  if (typeof options === 'string') {\n    encoding = options;\n  } else if (options != null) {\n    if (options.encoding) {\n      encoding = options.encoding;\n    }\n    if (options.withFileTypes) {\n      withFileTypes = true;\n    }\n  }\n  const map = unstable_getCacheForType(createReaddirMap);\n  let readdirCache = map.get(path);\n  if (!readdirCache) {\n    readdirCache = [];\n    map.set(path, readdirCache);\n  }\n  let record;\n  for (let i = 0; i < readdirCache.length; i += 3) {\n    const cachedEncoding: string = (readdirCache[i]: any);\n    const cachedWithFileTypes: boolean = (readdirCache[i + 1]: any);\n    if (encoding === cachedEncoding && withFileTypes === cachedWithFileTypes) {\n      const cachedRecord: Record<void> = (readdirCache[i + 2]: any);\n      record = cachedRecord;\n      break;\n    }\n  }\n  if (!record) {\n    const thenable = fs.readdir(path, {encoding, withFileTypes});\n    record = createRecordFromThenable(thenable);\n    readdirCache.push(encoding, withFileTypes, record);\n  }\n  const files = readRecord(record).value;\n  return files;\n}\n\nfunction createReadFileMap(): Map<string, Record<Buffer>> {\n  return new Map();\n}\n\nexport function readFile(\n  path: string,\n  options:\n    | string\n    | {\n        encoding?: string | null,\n        // Unsupported:\n        flag?: string, // Doesn't make sense except \"r\"\n        signal?: mixed, // We'll have our own signal\n      },\n): string | Buffer {\n  checkPathInDev(path);\n  const map = unstable_getCacheForType(createReadFileMap);\n  let record = map.get(path);\n  if (!record) {\n    const thenable = fs.readFile(path);\n    record = createRecordFromThenable(thenable);\n    map.set(path, record);\n  }\n  const resolvedRecord = readRecord(record);\n  const buffer: Buffer = resolvedRecord.value;\n  if (!options) {\n    return buffer;\n  }\n  let encoding;\n  if (typeof options === 'string') {\n    encoding = options;\n  } else {\n    const flag = options.flag;\n    if (flag != null && flag !== 'r') {\n      throw Error(\n        'The flag option is not supported, and always defaults to \"r\".',\n      );\n    }\n    if (options.signal) {\n      throw Error('The signal option is not supported.');\n    }\n    encoding = options.encoding;\n  }\n  if (typeof encoding !== 'string') {\n    return buffer;\n  }\n  const textCache = resolvedRecord.cache || (resolvedRecord.cache = []);\n  for (let i = 0; i < textCache.length; i += 2) {\n    if (textCache[i] === encoding) {\n      return (textCache[i + 1]: any);\n    }\n  }\n  const text = buffer.toString((encoding: any));\n  textCache.push(encoding, text);\n  return text;\n}\n\nfunction createReadlinkMap(): Map<string, Array<string | Record<mixed>>> {\n  return new Map();\n}\n\nexport function readlink(\n  path: string,\n  options?: string | {encoding?: string},\n): mixed {\n  checkPathInDev(path);\n  let encoding = 'utf8';\n  if (typeof options === 'string') {\n    encoding = options;\n  } else if (options != null) {\n    if (options.encoding) {\n      encoding = options.encoding;\n    }\n  }\n  const map = unstable_getCacheForType(createReadlinkMap);\n  let readlinkCache = map.get(path);\n  if (!readlinkCache) {\n    readlinkCache = [];\n    map.set(path, readlinkCache);\n  }\n  let record;\n  for (let i = 0; i < readlinkCache.length; i += 2) {\n    const cachedEncoding: string = (readlinkCache[i]: any);\n    if (encoding === cachedEncoding) {\n      const cachedRecord: Record<void> = (readlinkCache[i + 1]: any);\n      record = cachedRecord;\n      break;\n    }\n  }\n  if (!record) {\n    const thenable = fs.readlink(path, {encoding});\n    record = createRecordFromThenable(thenable);\n    readlinkCache.push(encoding, record);\n  }\n  const linkString = readRecord(record).value;\n  return linkString;\n}\n\nfunction createRealpathMap(): Map<string, Array<string | Record<mixed>>> {\n  return new Map();\n}\n\nexport function realpath(\n  path: string,\n  options?: string | {encoding?: string},\n): mixed {\n  checkPathInDev(path);\n  let encoding = 'utf8';\n  if (typeof options === 'string') {\n    encoding = options;\n  } else if (options != null) {\n    if (options.encoding) {\n      encoding = options.encoding;\n    }\n  }\n  const map = unstable_getCacheForType(createRealpathMap);\n  let realpathCache = map.get(path);\n  if (!realpathCache) {\n    realpathCache = [];\n    map.set(path, realpathCache);\n  }\n  let record;\n  for (let i = 0; i < realpathCache.length; i += 2) {\n    const cachedEncoding: string = (realpathCache[i]: any);\n    if (encoding === cachedEncoding) {\n      const cachedRecord: Record<void> = (realpathCache[i + 1]: any);\n      record = cachedRecord;\n      break;\n    }\n  }\n  if (!record) {\n    const thenable = fs.realpath(path, {encoding});\n    record = createRecordFromThenable(thenable);\n    realpathCache.push(encoding, record);\n  }\n  const resolvedPath = readRecord(record).value;\n  return resolvedPath;\n}\n\nfunction createStatMap(): Map<string, Array<boolean | Record<mixed>>> {\n  return new Map();\n}\n\nexport function stat(path: string, options?: {bigint?: boolean}): mixed {\n  checkPathInDev(path);\n  let bigint = false;\n  if (options && options.bigint) {\n    bigint = true;\n  }\n  const map = unstable_getCacheForType(createStatMap);\n  let statCache = map.get(path);\n  if (!statCache) {\n    statCache = [];\n    map.set(path, statCache);\n  }\n  let record;\n  for (let i = 0; i < statCache.length; i += 2) {\n    const cachedBigint: boolean = (statCache[i]: any);\n    if (bigint === cachedBigint) {\n      const cachedRecord: Record<void> = (statCache[i + 1]: any);\n      record = cachedRecord;\n      break;\n    }\n  }\n  if (!record) {\n    const thenable = fs.stat(path, {bigint});\n    record = createRecordFromThenable(thenable);\n    statCache.push(bigint, record);\n  }\n  const stats = readRecord(record).value;\n  return stats;\n}\n"],"names":["Pending","Resolved","Rejected","createRecordFromThenable","thenable","record","status","value","cache","then","resolvedRecord","err","rejectedRecord","readRecord","createAccessMap","Map","access","path","mode","map","unstable_getCacheForType","accessCache","get","set","i","length","cachedMode","cachedRecord","fs","push","createLstatMap","lstat","options","bigint","lstatCache","cachedBigint","stats","createReaddirMap","readdir","encoding","withFileTypes","readdirCache","cachedEncoding","cachedWithFileTypes","files","createReadFileMap","readFile","buffer","flag","Error","signal","textCache","text","toString","createReadlinkMap","readlink","readlinkCache","linkString","createRealpathMap","realpath","realpathCache","resolvedPath","createStatMap","stat","statCache"],"mappings":"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"}