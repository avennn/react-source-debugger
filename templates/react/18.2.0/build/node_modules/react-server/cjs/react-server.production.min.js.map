{"version":3,"file":"react-server.production.min.js","sources":["../../../../packages/react-server/src/forks/ReactServerStreamConfig.custom.js","../../../../packages/react-server/src/forks/ReactServerFormatConfig.custom.js","../../../../packages/shared/assign.js","../../../../packages/shared/ReactSymbols.js","../../../../packages/shared/getComponentNameFromType.js","../../../../packages/shared/ReactSharedInternals.js","../../../../packages/shared/ReactComponentStackFrame.js","../../../../packages/shared/checkPropTypes.js","../../../../packages/react-server/src/ReactFizzContext.js","../../../../packages/react-server/src/ReactFizzNewContext.js","../../../../packages/shared/ReactInstanceMap.js","../../../../packages/shared/isArray.js","../../../../packages/react-server/src/ReactFizzClassComponent.js","../../../../packages/react-server/src/ReactFizzTreeContext.js","../../../../packages/shared/objectIs.js","../../../../packages/react-server/src/ReactFizzHooks.js","../../../../packages/react-server/src/ReactFizzServer.js"],"sourcesContent":["/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\n// This is a host config that's used for the `react-server` package on npm.\n// It is only used by third-party renderers.\n//\n// Its API lets you pass the host config as an argument.\n// However, inside the `react-server` we treat host config as a module.\n// This file is a shim between two worlds.\n//\n// It works because the `react-server` bundle is wrapped in something like:\n//\n// module.exports = function ($$$config) {\n//   /* renderer code */\n// }\n//\n// So `$$$config` looks like a global variable, but it's\n// really an argument to a top-level wrapping function.\n\ndeclare var $$$hostConfig: any;\nexport opaque type Destination = mixed; // eslint-disable-line no-undef\n\nexport opaque type PrecomputedChunk = mixed; // eslint-disable-line no-undef\nexport opaque type Chunk = mixed; // eslint-disable-line no-undef\n\nexport const scheduleWork = $$$hostConfig.scheduleWork;\nexport const beginWriting = $$$hostConfig.beginWriting;\nexport const writeChunk = $$$hostConfig.writeChunk;\nexport const writeChunkAndReturn = $$$hostConfig.writeChunkAndReturn;\nexport const completeWriting = $$$hostConfig.completeWriting;\nexport const flushBuffered = $$$hostConfig.flushBuffered;\nexport const close = $$$hostConfig.close;\nexport const closeWithError = $$$hostConfig.closeWithError;\nexport const stringToChunk = $$$hostConfig.stringToChunk;\nexport const stringToPrecomputedChunk = $$$hostConfig.stringToPrecomputedChunk;\n","/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\n// This is a host config that's used for the `react-server` package on npm.\n// It is only used by third-party renderers.\n//\n// Its API lets you pass the host config as an argument.\n// However, inside the `react-server` we treat host config as a module.\n// This file is a shim between two worlds.\n//\n// It works because the `react-server` bundle is wrapped in something like:\n//\n// module.exports = function ($$$config) {\n//   /* renderer code */\n// }\n//\n// So `$$$config` looks like a global variable, but it's\n// really an argument to a top-level wrapping function.\n\ndeclare var $$$hostConfig: any;\nexport opaque type Destination = mixed; // eslint-disable-line no-undef\nexport opaque type ResponseState = mixed;\nexport opaque type FormatContext = mixed;\nexport opaque type SuspenseBoundaryID = mixed;\n\nexport const isPrimaryRenderer = false;\n\nexport const getChildFormatContext = $$$hostConfig.getChildFormatContext;\nexport const UNINITIALIZED_SUSPENSE_BOUNDARY_ID =\n  $$$hostConfig.UNINITIALIZED_SUSPENSE_BOUNDARY_ID;\nexport const assignSuspenseBoundaryID = $$$hostConfig.assignSuspenseBoundaryID;\nexport const makeId = $$$hostConfig.makeId;\nexport const pushTextInstance = $$$hostConfig.pushTextInstance;\nexport const pushStartInstance = $$$hostConfig.pushStartInstance;\nexport const pushEndInstance = $$$hostConfig.pushEndInstance;\nexport const pushStartCompletedSuspenseBoundary =\n  $$$hostConfig.pushStartCompletedSuspenseBoundary;\nexport const pushEndCompletedSuspenseBoundary =\n  $$$hostConfig.pushEndCompletedSuspenseBoundary;\nexport const pushSegmentFinale = $$$hostConfig.pushSegmentFinale;\nexport const writeCompletedRoot = $$$hostConfig.writeCompletedRoot;\nexport const writePlaceholder = $$$hostConfig.writePlaceholder;\nexport const writeStartCompletedSuspenseBoundary =\n  $$$hostConfig.writeStartCompletedSuspenseBoundary;\nexport const writeStartPendingSuspenseBoundary =\n  $$$hostConfig.writeStartPendingSuspenseBoundary;\nexport const writeStartClientRenderedSuspenseBoundary =\n  $$$hostConfig.writeStartClientRenderedSuspenseBoundary;\nexport const writeEndCompletedSuspenseBoundary =\n  $$$hostConfig.writeEndCompletedSuspenseBoundary;\nexport const writeEndPendingSuspenseBoundary =\n  $$$hostConfig.writeEndPendingSuspenseBoundary;\nexport const writeEndClientRenderedSuspenseBoundary =\n  $$$hostConfig.writeEndClientRenderedSuspenseBoundary;\nexport const writeStartSegment = $$$hostConfig.writeStartSegment;\nexport const writeEndSegment = $$$hostConfig.writeEndSegment;\nexport const writeCompletedSegmentInstruction =\n  $$$hostConfig.writeCompletedSegmentInstruction;\nexport const writeCompletedBoundaryInstruction =\n  $$$hostConfig.writeCompletedBoundaryInstruction;\nexport const writeClientRenderBoundaryInstruction =\n  $$$hostConfig.writeClientRenderBoundaryInstruction;\n","/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\nconst assign = Object.assign;\n\nexport default assign;\n","/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\n// ATTENTION\n// When adding new symbols to this file,\n// Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'\n\n// The Symbol used to tag the ReactElement-like types.\nexport const REACT_ELEMENT_TYPE = Symbol.for('react.element');\nexport const REACT_PORTAL_TYPE = Symbol.for('react.portal');\nexport const REACT_FRAGMENT_TYPE = Symbol.for('react.fragment');\nexport const REACT_STRICT_MODE_TYPE = Symbol.for('react.strict_mode');\nexport const REACT_PROFILER_TYPE = Symbol.for('react.profiler');\nexport const REACT_PROVIDER_TYPE = Symbol.for('react.provider');\nexport const REACT_CONTEXT_TYPE = Symbol.for('react.context');\nexport const REACT_SERVER_CONTEXT_TYPE = Symbol.for('react.server_context');\nexport const REACT_FORWARD_REF_TYPE = Symbol.for('react.forward_ref');\nexport const REACT_SUSPENSE_TYPE = Symbol.for('react.suspense');\nexport const REACT_SUSPENSE_LIST_TYPE = Symbol.for('react.suspense_list');\nexport const REACT_MEMO_TYPE = Symbol.for('react.memo');\nexport const REACT_LAZY_TYPE = Symbol.for('react.lazy');\nexport const REACT_SCOPE_TYPE = Symbol.for('react.scope');\nexport const REACT_DEBUG_TRACING_MODE_TYPE = Symbol.for(\n  'react.debug_trace_mode',\n);\nexport const REACT_OFFSCREEN_TYPE = Symbol.for('react.offscreen');\nexport const REACT_LEGACY_HIDDEN_TYPE = Symbol.for('react.legacy_hidden');\nexport const REACT_CACHE_TYPE = Symbol.for('react.cache');\nexport const REACT_TRACING_MARKER_TYPE = Symbol.for('react.tracing_marker');\nexport const REACT_SERVER_CONTEXT_DEFAULT_VALUE_NOT_LOADED = Symbol.for(\n  'react.default_value',\n);\n\nconst MAYBE_ITERATOR_SYMBOL = Symbol.iterator;\nconst FAUX_ITERATOR_SYMBOL = '@@iterator';\n\nexport function getIteratorFn(maybeIterable: ?any): ?() => ?Iterator<*> {\n  if (maybeIterable === null || typeof maybeIterable !== 'object') {\n    return null;\n  }\n  const maybeIterator =\n    (MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL]) ||\n    maybeIterable[FAUX_ITERATOR_SYMBOL];\n  if (typeof maybeIterator === 'function') {\n    return maybeIterator;\n  }\n  return null;\n}\n","/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\nimport type {LazyComponent} from 'react/src/ReactLazy';\nimport type {ReactContext, ReactProviderType} from 'shared/ReactTypes';\n\nimport {\n  REACT_CONTEXT_TYPE,\n  REACT_FORWARD_REF_TYPE,\n  REACT_FRAGMENT_TYPE,\n  REACT_PORTAL_TYPE,\n  REACT_MEMO_TYPE,\n  REACT_PROFILER_TYPE,\n  REACT_PROVIDER_TYPE,\n  REACT_STRICT_MODE_TYPE,\n  REACT_SUSPENSE_TYPE,\n  REACT_SUSPENSE_LIST_TYPE,\n  REACT_LAZY_TYPE,\n  REACT_CACHE_TYPE,\n  REACT_TRACING_MARKER_TYPE,\n  REACT_SERVER_CONTEXT_TYPE,\n} from 'shared/ReactSymbols';\n\nimport {\n  enableServerContext,\n  enableTransitionTracing,\n  enableCache,\n} from './ReactFeatureFlags';\n\n// Keep in sync with react-reconciler/getComponentNameFromFiber\nfunction getWrappedName(\n  outerType: mixed,\n  innerType: any,\n  wrapperName: string,\n): string {\n  const displayName = (outerType: any).displayName;\n  if (displayName) {\n    return displayName;\n  }\n  const functionName = innerType.displayName || innerType.name || '';\n  return functionName !== '' ? `${wrapperName}(${functionName})` : wrapperName;\n}\n\n// Keep in sync with react-reconciler/getComponentNameFromFiber\nfunction getContextName(type: ReactContext<any>) {\n  return type.displayName || 'Context';\n}\n\n// Note that the reconciler package should generally prefer to use getComponentNameFromFiber() instead.\nexport default function getComponentNameFromType(type: mixed): string | null {\n  if (type == null) {\n    // Host root, text node or just invalid type.\n    return null;\n  }\n  if (__DEV__) {\n    if (typeof (type: any).tag === 'number') {\n      console.error(\n        'Received an unexpected object in getComponentNameFromType(). ' +\n          'This is likely a bug in React. Please file an issue.',\n      );\n    }\n  }\n  if (typeof type === 'function') {\n    return (type: any).displayName || type.name || null;\n  }\n  if (typeof type === 'string') {\n    return type;\n  }\n  switch (type) {\n    case REACT_FRAGMENT_TYPE:\n      return 'Fragment';\n    case REACT_PORTAL_TYPE:\n      return 'Portal';\n    case REACT_PROFILER_TYPE:\n      return 'Profiler';\n    case REACT_STRICT_MODE_TYPE:\n      return 'StrictMode';\n    case REACT_SUSPENSE_TYPE:\n      return 'Suspense';\n    case REACT_SUSPENSE_LIST_TYPE:\n      return 'SuspenseList';\n    case REACT_CACHE_TYPE:\n      if (enableCache) {\n        return 'Cache';\n      }\n    // eslint-disable-next-line no-fallthrough\n    case REACT_TRACING_MARKER_TYPE:\n      if (enableTransitionTracing) {\n        return 'TracingMarker';\n      }\n  }\n  if (typeof type === 'object') {\n    switch (type.$$typeof) {\n      case REACT_CONTEXT_TYPE:\n        const context: ReactContext<any> = (type: any);\n        return getContextName(context) + '.Consumer';\n      case REACT_PROVIDER_TYPE:\n        const provider: ReactProviderType<any> = (type: any);\n        return getContextName(provider._context) + '.Provider';\n      case REACT_FORWARD_REF_TYPE:\n        return getWrappedName(type, type.render, 'ForwardRef');\n      case REACT_MEMO_TYPE:\n        const outerName = (type: any).displayName || null;\n        if (outerName !== null) {\n          return outerName;\n        }\n        return getComponentNameFromType(type.type) || 'Memo';\n      case REACT_LAZY_TYPE: {\n        const lazyComponent: LazyComponent<any, any> = (type: any);\n        const payload = lazyComponent._payload;\n        const init = lazyComponent._init;\n        try {\n          return getComponentNameFromType(init(payload));\n        } catch (x) {\n          return null;\n        }\n      }\n      case REACT_SERVER_CONTEXT_TYPE:\n        if (enableServerContext) {\n          const context2 = ((type: any): ReactContext<any>);\n          return (context2.displayName || context2._globalName) + '.Provider';\n        }\n      // eslint-disable-next-line no-fallthrough\n    }\n  }\n  return null;\n}\n","/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\nimport * as React from 'react';\n\nconst ReactSharedInternals =\n  React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;\n\nexport default ReactSharedInternals;\n","/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\nimport type {Source} from 'shared/ReactElementType';\nimport type {LazyComponent} from 'react/src/ReactLazy';\n\nimport {\n  enableComponentStackLocations,\n  disableNativeComponentFrames,\n} from 'shared/ReactFeatureFlags';\n\nimport {\n  REACT_SUSPENSE_TYPE,\n  REACT_SUSPENSE_LIST_TYPE,\n  REACT_FORWARD_REF_TYPE,\n  REACT_MEMO_TYPE,\n  REACT_LAZY_TYPE,\n} from 'shared/ReactSymbols';\n\nimport {disableLogs, reenableLogs} from 'shared/ConsolePatchingDev';\n\nimport ReactSharedInternals from 'shared/ReactSharedInternals';\n\nconst {ReactCurrentDispatcher} = ReactSharedInternals;\n\nlet prefix;\nexport function describeBuiltInComponentFrame(\n  name: string,\n  source: void | null | Source,\n  ownerFn: void | null | Function,\n): string {\n  if (enableComponentStackLocations) {\n    if (prefix === undefined) {\n      // Extract the VM specific prefix used by each line.\n      try {\n        throw Error();\n      } catch (x) {\n        const match = x.stack.trim().match(/\\n( *(at )?)/);\n        prefix = (match && match[1]) || '';\n      }\n    }\n    // We use the prefix to ensure our stacks line up with native stack frames.\n    return '\\n' + prefix + name;\n  } else {\n    let ownerName = null;\n    if (__DEV__ && ownerFn) {\n      ownerName = ownerFn.displayName || ownerFn.name || null;\n    }\n    return describeComponentFrame(name, source, ownerName);\n  }\n}\n\nlet reentry = false;\nlet componentFrameCache;\nif (__DEV__) {\n  const PossiblyWeakMap = typeof WeakMap === 'function' ? WeakMap : Map;\n  componentFrameCache = new PossiblyWeakMap();\n}\n\nexport function describeNativeComponentFrame(\n  fn: Function,\n  construct: boolean,\n): string {\n  // If something asked for a stack inside a fake render, it should get ignored.\n  if (disableNativeComponentFrames || !fn || reentry) {\n    return '';\n  }\n\n  if (__DEV__) {\n    const frame = componentFrameCache.get(fn);\n    if (frame !== undefined) {\n      return frame;\n    }\n  }\n\n  let control;\n\n  reentry = true;\n  const previousPrepareStackTrace = Error.prepareStackTrace;\n  // $FlowFixMe It does accept undefined.\n  Error.prepareStackTrace = undefined;\n  let previousDispatcher;\n  if (__DEV__) {\n    previousDispatcher = ReactCurrentDispatcher.current;\n    // Set the dispatcher in DEV because this might be call in the render function\n    // for warnings.\n    ReactCurrentDispatcher.current = null;\n    disableLogs();\n  }\n  try {\n    // This should throw.\n    if (construct) {\n      // Something should be setting the props in the constructor.\n      const Fake = function() {\n        throw Error();\n      };\n      // $FlowFixMe\n      Object.defineProperty(Fake.prototype, 'props', {\n        set: function() {\n          // We use a throwing setter instead of frozen or non-writable props\n          // because that won't throw in a non-strict mode function.\n          throw Error();\n        },\n      });\n      if (typeof Reflect === 'object' && Reflect.construct) {\n        // We construct a different control for this case to include any extra\n        // frames added by the construct call.\n        try {\n          Reflect.construct(Fake, []);\n        } catch (x) {\n          control = x;\n        }\n        Reflect.construct(fn, [], Fake);\n      } else {\n        try {\n          Fake.call();\n        } catch (x) {\n          control = x;\n        }\n        fn.call(Fake.prototype);\n      }\n    } else {\n      try {\n        throw Error();\n      } catch (x) {\n        control = x;\n      }\n      fn();\n    }\n  } catch (sample) {\n    // This is inlined manually because closure doesn't do it for us.\n    if (sample && control && typeof sample.stack === 'string') {\n      // This extracts the first frame from the sample that isn't also in the control.\n      // Skipping one frame that we assume is the frame that calls the two.\n      const sampleLines = sample.stack.split('\\n');\n      const controlLines = control.stack.split('\\n');\n      let s = sampleLines.length - 1;\n      let c = controlLines.length - 1;\n      while (s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]) {\n        // We expect at least one stack frame to be shared.\n        // Typically this will be the root most one. However, stack frames may be\n        // cut off due to maximum stack limits. In this case, one maybe cut off\n        // earlier than the other. We assume that the sample is longer or the same\n        // and there for cut off earlier. So we should find the root most frame in\n        // the sample somewhere in the control.\n        c--;\n      }\n      for (; s >= 1 && c >= 0; s--, c--) {\n        // Next we find the first one that isn't the same which should be the\n        // frame that called our sample function and the control.\n        if (sampleLines[s] !== controlLines[c]) {\n          // In V8, the first line is describing the message but other VMs don't.\n          // If we're about to return the first line, and the control is also on the same\n          // line, that's a pretty good indicator that our sample threw at same line as\n          // the control. I.e. before we entered the sample frame. So we ignore this result.\n          // This can happen if you passed a class to function component, or non-function.\n          if (s !== 1 || c !== 1) {\n            do {\n              s--;\n              c--;\n              // We may still have similar intermediate frames from the construct call.\n              // The next one that isn't the same should be our match though.\n              if (c < 0 || sampleLines[s] !== controlLines[c]) {\n                // V8 adds a \"new\" prefix for native classes. Let's remove it to make it prettier.\n                let frame = '\\n' + sampleLines[s].replace(' at new ', ' at ');\n\n                // If our component frame is labeled \"<anonymous>\"\n                // but we have a user-provided \"displayName\"\n                // splice it in to make the stack more readable.\n                if (fn.displayName && frame.includes('<anonymous>')) {\n                  frame = frame.replace('<anonymous>', fn.displayName);\n                }\n\n                if (__DEV__) {\n                  if (typeof fn === 'function') {\n                    componentFrameCache.set(fn, frame);\n                  }\n                }\n                // Return the line we found.\n                return frame;\n              }\n            } while (s >= 1 && c >= 0);\n          }\n          break;\n        }\n      }\n    }\n  } finally {\n    reentry = false;\n    if (__DEV__) {\n      ReactCurrentDispatcher.current = previousDispatcher;\n      reenableLogs();\n    }\n    Error.prepareStackTrace = previousPrepareStackTrace;\n  }\n  // Fallback to just using the name if we couldn't make it throw.\n  const name = fn ? fn.displayName || fn.name : '';\n  const syntheticFrame = name ? describeBuiltInComponentFrame(name) : '';\n  if (__DEV__) {\n    if (typeof fn === 'function') {\n      componentFrameCache.set(fn, syntheticFrame);\n    }\n  }\n  return syntheticFrame;\n}\n\nconst BEFORE_SLASH_RE = /^(.*)[\\\\\\/]/;\n\nfunction describeComponentFrame(\n  name: null | string,\n  source: void | null | Source,\n  ownerName: null | string,\n) {\n  let sourceInfo = '';\n  if (__DEV__ && source) {\n    const path = source.fileName;\n    let fileName = path.replace(BEFORE_SLASH_RE, '');\n    // In DEV, include code for a common special case:\n    // prefer \"folder/index.js\" instead of just \"index.js\".\n    if (/^index\\./.test(fileName)) {\n      const match = path.match(BEFORE_SLASH_RE);\n      if (match) {\n        const pathBeforeSlash = match[1];\n        if (pathBeforeSlash) {\n          const folderName = pathBeforeSlash.replace(BEFORE_SLASH_RE, '');\n          fileName = folderName + '/' + fileName;\n        }\n      }\n    }\n    sourceInfo = ' (at ' + fileName + ':' + source.lineNumber + ')';\n  } else if (ownerName) {\n    sourceInfo = ' (created by ' + ownerName + ')';\n  }\n  return '\\n    in ' + (name || 'Unknown') + sourceInfo;\n}\n\nexport function describeClassComponentFrame(\n  ctor: Function,\n  source: void | null | Source,\n  ownerFn: void | null | Function,\n): string {\n  if (enableComponentStackLocations) {\n    return describeNativeComponentFrame(ctor, true);\n  } else {\n    return describeFunctionComponentFrame(ctor, source, ownerFn);\n  }\n}\n\nexport function describeFunctionComponentFrame(\n  fn: Function,\n  source: void | null | Source,\n  ownerFn: void | null | Function,\n): string {\n  if (enableComponentStackLocations) {\n    return describeNativeComponentFrame(fn, false);\n  } else {\n    if (!fn) {\n      return '';\n    }\n    const name = fn.displayName || fn.name || null;\n    let ownerName = null;\n    if (__DEV__ && ownerFn) {\n      ownerName = ownerFn.displayName || ownerFn.name || null;\n    }\n    return describeComponentFrame(name, source, ownerName);\n  }\n}\n\nfunction shouldConstruct(Component: Function) {\n  const prototype = Component.prototype;\n  return !!(prototype && prototype.isReactComponent);\n}\n\nexport function describeUnknownElementTypeFrameInDEV(\n  type: any,\n  source: void | null | Source,\n  ownerFn: void | null | Function,\n): string {\n  if (!__DEV__) {\n    return '';\n  }\n  if (type == null) {\n    return '';\n  }\n  if (typeof type === 'function') {\n    if (enableComponentStackLocations) {\n      return describeNativeComponentFrame(type, shouldConstruct(type));\n    } else {\n      return describeFunctionComponentFrame(type, source, ownerFn);\n    }\n  }\n  if (typeof type === 'string') {\n    return describeBuiltInComponentFrame(type, source, ownerFn);\n  }\n  switch (type) {\n    case REACT_SUSPENSE_TYPE:\n      return describeBuiltInComponentFrame('Suspense', source, ownerFn);\n    case REACT_SUSPENSE_LIST_TYPE:\n      return describeBuiltInComponentFrame('SuspenseList', source, ownerFn);\n  }\n  if (typeof type === 'object') {\n    switch (type.$$typeof) {\n      case REACT_FORWARD_REF_TYPE:\n        return describeFunctionComponentFrame(type.render, source, ownerFn);\n      case REACT_MEMO_TYPE:\n        // Memo may contain any component type so we recursively resolve it.\n        return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);\n      case REACT_LAZY_TYPE: {\n        const lazyComponent: LazyComponent<any, any> = (type: any);\n        const payload = lazyComponent._payload;\n        const init = lazyComponent._init;\n        try {\n          // Lazy may contain any component type so we recursively resolve it.\n          return describeUnknownElementTypeFrameInDEV(\n            init(payload),\n            source,\n            ownerFn,\n          );\n        } catch (x) {}\n      }\n    }\n  }\n  return '';\n}\n","/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\nconst loggedTypeFailures = {};\n\nimport {describeUnknownElementTypeFrameInDEV} from 'shared/ReactComponentStackFrame';\n\nimport ReactSharedInternals from 'shared/ReactSharedInternals';\nimport hasOwnProperty from 'shared/hasOwnProperty';\n\nconst ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\n\nfunction setCurrentlyValidatingElement(element) {\n  if (__DEV__) {\n    if (element) {\n      const owner = element._owner;\n      const stack = describeUnknownElementTypeFrameInDEV(\n        element.type,\n        element._source,\n        owner ? owner.type : null,\n      );\n      ReactDebugCurrentFrame.setExtraStackFrame(stack);\n    } else {\n      ReactDebugCurrentFrame.setExtraStackFrame(null);\n    }\n  }\n}\n\nexport default function checkPropTypes(\n  typeSpecs: Object,\n  values: Object,\n  location: string,\n  componentName: ?string,\n  element?: any,\n): void {\n  if (__DEV__) {\n    // $FlowFixMe This is okay but Flow doesn't know it.\n    const has = Function.call.bind(hasOwnProperty);\n    for (const typeSpecName in typeSpecs) {\n      if (has(typeSpecs, typeSpecName)) {\n        let error;\n        // Prop type validation may throw. In case they do, we don't want to\n        // fail the render phase where it didn't fail before. So we log it.\n        // After these have been cleaned up, we'll let them throw.\n        try {\n          // This is intentionally an invariant that gets caught. It's the same\n          // behavior as without this statement except with a better message.\n          if (typeof typeSpecs[typeSpecName] !== 'function') {\n            // eslint-disable-next-line react-internal/prod-error-codes\n            const err = Error(\n              (componentName || 'React class') +\n                ': ' +\n                location +\n                ' type `' +\n                typeSpecName +\n                '` is invalid; ' +\n                'it must be a function, usually from the `prop-types` package, but received `' +\n                typeof typeSpecs[typeSpecName] +\n                '`.' +\n                'This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.',\n            );\n            err.name = 'Invariant Violation';\n            throw err;\n          }\n          error = typeSpecs[typeSpecName](\n            values,\n            typeSpecName,\n            componentName,\n            location,\n            null,\n            'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED',\n          );\n        } catch (ex) {\n          error = ex;\n        }\n        if (error && !(error instanceof Error)) {\n          setCurrentlyValidatingElement(element);\n          console.error(\n            '%s: type specification of %s' +\n              ' `%s` is invalid; the type checker ' +\n              'function must return `null` or an `Error` but returned a %s. ' +\n              'You may have forgotten to pass an argument to the type checker ' +\n              'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' +\n              'shape all require an argument).',\n            componentName || 'React class',\n            location,\n            typeSpecName,\n            typeof error,\n          );\n          setCurrentlyValidatingElement(null);\n        }\n        if (error instanceof Error && !(error.message in loggedTypeFailures)) {\n          // Only monitor this failure once because there tends to be a lot of the\n          // same error.\n          loggedTypeFailures[error.message] = true;\n          setCurrentlyValidatingElement(element);\n          console.error('Failed %s type: %s', location, error.message);\n          setCurrentlyValidatingElement(null);\n        }\n      }\n    }\n  }\n}\n","/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\nimport {disableLegacyContext} from 'shared/ReactFeatureFlags';\nimport getComponentNameFromType from 'shared/getComponentNameFromType';\nimport checkPropTypes from 'shared/checkPropTypes';\n\nlet warnedAboutMissingGetChildContext;\n\nif (__DEV__) {\n  warnedAboutMissingGetChildContext = {};\n}\n\nexport const emptyContextObject = {};\nif (__DEV__) {\n  Object.freeze(emptyContextObject);\n}\n\nexport function getMaskedContext(type: any, unmaskedContext: Object): Object {\n  if (disableLegacyContext) {\n    return emptyContextObject;\n  } else {\n    const contextTypes = type.contextTypes;\n    if (!contextTypes) {\n      return emptyContextObject;\n    }\n\n    const context = {};\n    for (const key in contextTypes) {\n      context[key] = unmaskedContext[key];\n    }\n\n    if (__DEV__) {\n      const name = getComponentNameFromType(type) || 'Unknown';\n      checkPropTypes(contextTypes, context, 'context', name);\n    }\n\n    return context;\n  }\n}\n\nexport function processChildContext(\n  instance: any,\n  type: any,\n  parentContext: Object,\n  childContextTypes: Object,\n): Object {\n  if (disableLegacyContext) {\n    return parentContext;\n  } else {\n    // TODO (bvaughn) Replace this behavior with an invariant() in the future.\n    // It has only been added in Fiber to match the (unintentional) behavior in Stack.\n    if (typeof instance.getChildContext !== 'function') {\n      if (__DEV__) {\n        const componentName = getComponentNameFromType(type) || 'Unknown';\n\n        if (!warnedAboutMissingGetChildContext[componentName]) {\n          warnedAboutMissingGetChildContext[componentName] = true;\n          console.error(\n            '%s.childContextTypes is specified but there is no getChildContext() method ' +\n              'on the instance. You can either define getChildContext() on %s or remove ' +\n              'childContextTypes from it.',\n            componentName,\n            componentName,\n          );\n        }\n      }\n      return parentContext;\n    }\n\n    const childContext = instance.getChildContext();\n    for (const contextKey in childContext) {\n      if (!(contextKey in childContextTypes)) {\n        throw new Error(\n          `${getComponentNameFromType(type) ||\n            'Unknown'}.getChildContext(): key \"${contextKey}\" is not defined in childContextTypes.`,\n        );\n      }\n    }\n    if (__DEV__) {\n      const name = getComponentNameFromType(type) || 'Unknown';\n      checkPropTypes(childContextTypes, childContext, 'child context', name);\n    }\n\n    return {...parentContext, ...childContext};\n  }\n}\n","/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\nimport type {ReactContext} from 'shared/ReactTypes';\n\nimport {REACT_SERVER_CONTEXT_DEFAULT_VALUE_NOT_LOADED} from 'shared/ReactSymbols';\nimport {isPrimaryRenderer} from './ReactServerFormatConfig';\n\nlet rendererSigil;\nif (__DEV__) {\n  // Use this to detect multiple renderers using the same context\n  rendererSigil = {};\n}\n\n// Used to store the parent path of all context overrides in a shared linked list.\n// Forming a reverse tree.\ntype ContextNode<T> = {\n  parent: null | ContextNode<any>,\n  depth: number, // Short hand to compute the depth of the tree at this node.\n  context: ReactContext<T>,\n  parentValue: T,\n  value: T,\n};\n\n// The structure of a context snapshot is an implementation of this file.\n// Currently, it's implemented as tracking the current active node.\nexport opaque type ContextSnapshot = null | ContextNode<any>;\n\nexport const rootContextSnapshot: ContextSnapshot = null;\n\n// We assume that this runtime owns the \"current\" field on all ReactContext instances.\n// This global (actually thread local) state represents what state all those \"current\",\n// fields are currently in.\nlet currentActiveSnapshot: ContextSnapshot = null;\n\nfunction popNode(prev: ContextNode<any>): void {\n  if (isPrimaryRenderer) {\n    prev.context._currentValue = prev.parentValue;\n  } else {\n    prev.context._currentValue2 = prev.parentValue;\n  }\n}\n\nfunction pushNode(next: ContextNode<any>): void {\n  if (isPrimaryRenderer) {\n    next.context._currentValue = next.value;\n  } else {\n    next.context._currentValue2 = next.value;\n  }\n}\n\nfunction popToNearestCommonAncestor(\n  prev: ContextNode<any>,\n  next: ContextNode<any>,\n): void {\n  if (prev === next) {\n    // We've found a shared ancestor. We don't need to pop nor reapply this one or anything above.\n  } else {\n    popNode(prev);\n    const parentPrev = prev.parent;\n    const parentNext = next.parent;\n    if (parentPrev === null) {\n      if (parentNext !== null) {\n        throw new Error(\n          'The stacks must reach the root at the same time. This is a bug in React.',\n        );\n      }\n    } else {\n      if (parentNext === null) {\n        throw new Error(\n          'The stacks must reach the root at the same time. This is a bug in React.',\n        );\n      }\n\n      popToNearestCommonAncestor(parentPrev, parentNext);\n    }\n\n    // On the way back, we push the new ones that weren't common.\n    pushNode(next);\n  }\n}\n\nfunction popAllPrevious(prev: ContextNode<any>): void {\n  popNode(prev);\n  const parentPrev = prev.parent;\n  if (parentPrev !== null) {\n    popAllPrevious(parentPrev);\n  }\n}\n\nfunction pushAllNext(next: ContextNode<any>): void {\n  const parentNext = next.parent;\n  if (parentNext !== null) {\n    pushAllNext(parentNext);\n  }\n  pushNode(next);\n}\n\nfunction popPreviousToCommonLevel(\n  prev: ContextNode<any>,\n  next: ContextNode<any>,\n): void {\n  popNode(prev);\n  const parentPrev = prev.parent;\n\n  if (parentPrev === null) {\n    throw new Error(\n      'The depth must equal at least at zero before reaching the root. This is a bug in React.',\n    );\n  }\n\n  if (parentPrev.depth === next.depth) {\n    // We found the same level. Now we just need to find a shared ancestor.\n    popToNearestCommonAncestor(parentPrev, next);\n  } else {\n    // We must still be deeper.\n    popPreviousToCommonLevel(parentPrev, next);\n  }\n}\n\nfunction popNextToCommonLevel(\n  prev: ContextNode<any>,\n  next: ContextNode<any>,\n): void {\n  const parentNext = next.parent;\n\n  if (parentNext === null) {\n    throw new Error(\n      'The depth must equal at least at zero before reaching the root. This is a bug in React.',\n    );\n  }\n\n  if (prev.depth === parentNext.depth) {\n    // We found the same level. Now we just need to find a shared ancestor.\n    popToNearestCommonAncestor(prev, parentNext);\n  } else {\n    // We must still be deeper.\n    popNextToCommonLevel(prev, parentNext);\n  }\n  pushNode(next);\n}\n\n// Perform context switching to the new snapshot.\n// To make it cheap to read many contexts, while not suspending, we make the switch eagerly by\n// updating all the context's current values. That way reads, always just read the current value.\n// At the cost of updating contexts even if they're never read by this subtree.\nexport function switchContext(newSnapshot: ContextSnapshot): void {\n  // The basic algorithm we need to do is to pop back any contexts that are no longer on the stack.\n  // We also need to update any new contexts that are now on the stack with the deepest value.\n  // The easiest way to update new contexts is to just reapply them in reverse order from the\n  // perspective of the backpointers. To avoid allocating a lot when switching, we use the stack\n  // for that. Therefore this algorithm is recursive.\n  // 1) First we pop which ever snapshot tree was deepest. Popping old contexts as we go.\n  // 2) Then we find the nearest common ancestor from there. Popping old contexts as we go.\n  // 3) Then we reapply new contexts on the way back up the stack.\n  const prev = currentActiveSnapshot;\n  const next = newSnapshot;\n  if (prev !== next) {\n    if (prev === null) {\n      // $FlowFixMe: This has to be non-null since it's not equal to prev.\n      pushAllNext(next);\n    } else if (next === null) {\n      popAllPrevious(prev);\n    } else if (prev.depth === next.depth) {\n      popToNearestCommonAncestor(prev, next);\n    } else if (prev.depth > next.depth) {\n      popPreviousToCommonLevel(prev, next);\n    } else {\n      popNextToCommonLevel(prev, next);\n    }\n    currentActiveSnapshot = next;\n  }\n}\n\nexport function pushProvider<T>(\n  context: ReactContext<T>,\n  nextValue: T,\n): ContextSnapshot {\n  let prevValue;\n  if (isPrimaryRenderer) {\n    prevValue = context._currentValue;\n    context._currentValue = nextValue;\n    if (__DEV__) {\n      if (\n        context._currentRenderer !== undefined &&\n        context._currentRenderer !== null &&\n        context._currentRenderer !== rendererSigil\n      ) {\n        console.error(\n          'Detected multiple renderers concurrently rendering the ' +\n            'same context provider. This is currently unsupported.',\n        );\n      }\n      context._currentRenderer = rendererSigil;\n    }\n  } else {\n    prevValue = context._currentValue2;\n    context._currentValue2 = nextValue;\n    if (__DEV__) {\n      if (\n        context._currentRenderer2 !== undefined &&\n        context._currentRenderer2 !== null &&\n        context._currentRenderer2 !== rendererSigil\n      ) {\n        console.error(\n          'Detected multiple renderers concurrently rendering the ' +\n            'same context provider. This is currently unsupported.',\n        );\n      }\n      context._currentRenderer2 = rendererSigil;\n    }\n  }\n  const prevNode = currentActiveSnapshot;\n  const newNode: ContextNode<T> = {\n    parent: prevNode,\n    depth: prevNode === null ? 0 : prevNode.depth + 1,\n    context: context,\n    parentValue: prevValue,\n    value: nextValue,\n  };\n  currentActiveSnapshot = newNode;\n  return newNode;\n}\n\nexport function popProvider<T>(context: ReactContext<T>): ContextSnapshot {\n  const prevSnapshot = currentActiveSnapshot;\n\n  if (prevSnapshot === null) {\n    throw new Error(\n      'Tried to pop a Context at the root of the app. This is a bug in React.',\n    );\n  }\n\n  if (__DEV__) {\n    if (prevSnapshot.context !== context) {\n      console.error(\n        'The parent context is not the expected context. This is probably a bug in React.',\n      );\n    }\n  }\n  if (isPrimaryRenderer) {\n    const value = prevSnapshot.parentValue;\n    if (value === REACT_SERVER_CONTEXT_DEFAULT_VALUE_NOT_LOADED) {\n      prevSnapshot.context._currentValue = prevSnapshot.context._defaultValue;\n    } else {\n      prevSnapshot.context._currentValue = value;\n    }\n    if (__DEV__) {\n      if (\n        context._currentRenderer !== undefined &&\n        context._currentRenderer !== null &&\n        context._currentRenderer !== rendererSigil\n      ) {\n        console.error(\n          'Detected multiple renderers concurrently rendering the ' +\n            'same context provider. This is currently unsupported.',\n        );\n      }\n      context._currentRenderer = rendererSigil;\n    }\n  } else {\n    const value = prevSnapshot.parentValue;\n    if (value === REACT_SERVER_CONTEXT_DEFAULT_VALUE_NOT_LOADED) {\n      prevSnapshot.context._currentValue2 = prevSnapshot.context._defaultValue;\n    } else {\n      prevSnapshot.context._currentValue2 = value;\n    }\n    if (__DEV__) {\n      if (\n        context._currentRenderer2 !== undefined &&\n        context._currentRenderer2 !== null &&\n        context._currentRenderer2 !== rendererSigil\n      ) {\n        console.error(\n          'Detected multiple renderers concurrently rendering the ' +\n            'same context provider. This is currently unsupported.',\n        );\n      }\n      context._currentRenderer2 = rendererSigil;\n    }\n  }\n  return (currentActiveSnapshot = prevSnapshot.parent);\n}\n\nexport function getActiveContext(): ContextSnapshot {\n  return currentActiveSnapshot;\n}\n\nexport function readContext<T>(context: ReactContext<T>): T {\n  const value = isPrimaryRenderer\n    ? context._currentValue\n    : context._currentValue2;\n  return value;\n}\n","/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n/**\n * `ReactInstanceMap` maintains a mapping from a public facing stateful\n * instance (key) and the internal representation (value). This allows public\n * methods to accept the user facing instance as an argument and map them back\n * to internal methods.\n *\n * Note that this module is currently shared and assumed to be stateless.\n * If this becomes an actual Map, that will break.\n */\n\n/**\n * This API should be called `delete` but we'd have to make sure to always\n * transform these to strings for IE support. When this transform is fully\n * supported we can rename it.\n */\nexport function remove(key) {\n  key._reactInternals = undefined;\n}\n\nexport function get(key) {\n  return key._reactInternals;\n}\n\nexport function has(key) {\n  return key._reactInternals !== undefined;\n}\n\nexport function set(key, value) {\n  key._reactInternals = value;\n}\n","/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\ndeclare function isArray(a: mixed): boolean %checks(Array.isArray(a));\n\nconst isArrayImpl = Array.isArray;\n\n// eslint-disable-next-line no-redeclare\nfunction isArray(a: mixed): boolean {\n  return isArrayImpl(a);\n}\n\nexport default isArray;\n","/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\nimport {emptyContextObject} from './ReactFizzContext';\nimport {readContext} from './ReactFizzNewContext';\n\nimport {\n  disableLegacyContext,\n  warnAboutDeprecatedLifecycles,\n} from 'shared/ReactFeatureFlags';\nimport {get as getInstance, set as setInstance} from 'shared/ReactInstanceMap';\nimport getComponentNameFromType from 'shared/getComponentNameFromType';\nimport {REACT_CONTEXT_TYPE, REACT_PROVIDER_TYPE} from 'shared/ReactSymbols';\nimport assign from 'shared/assign';\nimport isArray from 'shared/isArray';\n\nconst didWarnAboutNoopUpdateForComponent = {};\nconst didWarnAboutDeprecatedWillMount = {};\n\nlet didWarnAboutUninitializedState;\nlet didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate;\nlet didWarnAboutLegacyLifecyclesAndDerivedState;\nlet didWarnAboutUndefinedDerivedState;\nlet warnOnUndefinedDerivedState;\nlet warnOnInvalidCallback;\nlet didWarnAboutDirectlyAssigningPropsToState;\nlet didWarnAboutContextTypeAndContextTypes;\nlet didWarnAboutInvalidateContextType;\n\nif (__DEV__) {\n  didWarnAboutUninitializedState = new Set();\n  didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate = new Set();\n  didWarnAboutLegacyLifecyclesAndDerivedState = new Set();\n  didWarnAboutDirectlyAssigningPropsToState = new Set();\n  didWarnAboutUndefinedDerivedState = new Set();\n  didWarnAboutContextTypeAndContextTypes = new Set();\n  didWarnAboutInvalidateContextType = new Set();\n\n  const didWarnOnInvalidCallback = new Set();\n\n  warnOnInvalidCallback = function(callback: mixed, callerName: string) {\n    if (callback === null || typeof callback === 'function') {\n      return;\n    }\n    const key = callerName + '_' + (callback: any);\n    if (!didWarnOnInvalidCallback.has(key)) {\n      didWarnOnInvalidCallback.add(key);\n      console.error(\n        '%s(...): Expected the last optional `callback` argument to be a ' +\n          'function. Instead received: %s.',\n        callerName,\n        callback,\n      );\n    }\n  };\n\n  warnOnUndefinedDerivedState = function(type, partialState) {\n    if (partialState === undefined) {\n      const componentName = getComponentNameFromType(type) || 'Component';\n      if (!didWarnAboutUndefinedDerivedState.has(componentName)) {\n        didWarnAboutUndefinedDerivedState.add(componentName);\n        console.error(\n          '%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. ' +\n            'You have returned undefined.',\n          componentName,\n        );\n      }\n    }\n  };\n}\n\nfunction warnNoop(\n  publicInstance: React$Component<any, any>,\n  callerName: string,\n) {\n  if (__DEV__) {\n    const constructor = publicInstance.constructor;\n    const componentName =\n      (constructor && getComponentNameFromType(constructor)) || 'ReactClass';\n    const warningKey = componentName + '.' + callerName;\n    if (didWarnAboutNoopUpdateForComponent[warningKey]) {\n      return;\n    }\n\n    console.error(\n      '%s(...): Can only update a mounting component. ' +\n        'This usually means you called %s() outside componentWillMount() on the server. ' +\n        'This is a no-op.\\n\\nPlease check the code for the %s component.',\n      callerName,\n      callerName,\n      componentName,\n    );\n    didWarnAboutNoopUpdateForComponent[warningKey] = true;\n  }\n}\n\ntype InternalInstance = {\n  queue: null | Array<Object>,\n  replace: boolean,\n};\n\nconst classComponentUpdater = {\n  isMounted(inst) {\n    return false;\n  },\n  enqueueSetState(inst, payload, callback) {\n    const internals: InternalInstance = getInstance(inst);\n    if (internals.queue === null) {\n      warnNoop(inst, 'setState');\n    } else {\n      internals.queue.push(payload);\n      if (__DEV__) {\n        if (callback !== undefined && callback !== null) {\n          warnOnInvalidCallback(callback, 'setState');\n        }\n      }\n    }\n  },\n  enqueueReplaceState(inst, payload, callback) {\n    const internals: InternalInstance = getInstance(inst);\n    internals.replace = true;\n    internals.queue = [payload];\n    if (__DEV__) {\n      if (callback !== undefined && callback !== null) {\n        warnOnInvalidCallback(callback, 'setState');\n      }\n    }\n  },\n  enqueueForceUpdate(inst, callback) {\n    const internals: InternalInstance = getInstance(inst);\n    if (internals.queue === null) {\n      warnNoop(inst, 'forceUpdate');\n    } else {\n      if (__DEV__) {\n        if (callback !== undefined && callback !== null) {\n          warnOnInvalidCallback(callback, 'setState');\n        }\n      }\n    }\n  },\n};\n\nfunction applyDerivedStateFromProps(\n  instance: any,\n  ctor: any,\n  getDerivedStateFromProps: (props: any, state: any) => any,\n  prevState: any,\n  nextProps: any,\n) {\n  const partialState = getDerivedStateFromProps(nextProps, prevState);\n\n  if (__DEV__) {\n    warnOnUndefinedDerivedState(ctor, partialState);\n  }\n  // Merge the partial state and the previous state.\n  const newState =\n    partialState === null || partialState === undefined\n      ? prevState\n      : assign({}, prevState, partialState);\n  return newState;\n}\n\nexport function constructClassInstance(\n  ctor: any,\n  props: any,\n  maskedLegacyContext: any,\n): any {\n  let context = emptyContextObject;\n  const contextType = ctor.contextType;\n\n  if (__DEV__) {\n    if ('contextType' in ctor) {\n      const isValid =\n        // Allow null for conditional declaration\n        contextType === null ||\n        (contextType !== undefined &&\n          contextType.$$typeof === REACT_CONTEXT_TYPE &&\n          contextType._context === undefined); // Not a <Context.Consumer>\n\n      if (!isValid && !didWarnAboutInvalidateContextType.has(ctor)) {\n        didWarnAboutInvalidateContextType.add(ctor);\n\n        let addendum = '';\n        if (contextType === undefined) {\n          addendum =\n            ' However, it is set to undefined. ' +\n            'This can be caused by a typo or by mixing up named and default imports. ' +\n            'This can also happen due to a circular dependency, so ' +\n            'try moving the createContext() call to a separate file.';\n        } else if (typeof contextType !== 'object') {\n          addendum = ' However, it is set to a ' + typeof contextType + '.';\n        } else if (contextType.$$typeof === REACT_PROVIDER_TYPE) {\n          addendum = ' Did you accidentally pass the Context.Provider instead?';\n        } else if (contextType._context !== undefined) {\n          // <Context.Consumer>\n          addendum = ' Did you accidentally pass the Context.Consumer instead?';\n        } else {\n          addendum =\n            ' However, it is set to an object with keys {' +\n            Object.keys(contextType).join(', ') +\n            '}.';\n        }\n        console.error(\n          '%s defines an invalid contextType. ' +\n            'contextType should point to the Context object returned by React.createContext().%s',\n          getComponentNameFromType(ctor) || 'Component',\n          addendum,\n        );\n      }\n    }\n  }\n\n  if (typeof contextType === 'object' && contextType !== null) {\n    context = readContext((contextType: any));\n  } else if (!disableLegacyContext) {\n    context = maskedLegacyContext;\n  }\n\n  const instance = new ctor(props, context);\n\n  if (__DEV__) {\n    if (\n      typeof ctor.getDerivedStateFromProps === 'function' &&\n      (instance.state === null || instance.state === undefined)\n    ) {\n      const componentName = getComponentNameFromType(ctor) || 'Component';\n      if (!didWarnAboutUninitializedState.has(componentName)) {\n        didWarnAboutUninitializedState.add(componentName);\n        console.error(\n          '`%s` uses `getDerivedStateFromProps` but its initial state is ' +\n            '%s. This is not recommended. Instead, define the initial state by ' +\n            'assigning an object to `this.state` in the constructor of `%s`. ' +\n            'This ensures that `getDerivedStateFromProps` arguments have a consistent shape.',\n          componentName,\n          instance.state === null ? 'null' : 'undefined',\n          componentName,\n        );\n      }\n    }\n\n    // If new component APIs are defined, \"unsafe\" lifecycles won't be called.\n    // Warn about these lifecycles if they are present.\n    // Don't warn about react-lifecycles-compat polyfilled methods though.\n    if (\n      typeof ctor.getDerivedStateFromProps === 'function' ||\n      typeof instance.getSnapshotBeforeUpdate === 'function'\n    ) {\n      let foundWillMountName = null;\n      let foundWillReceivePropsName = null;\n      let foundWillUpdateName = null;\n      if (\n        typeof instance.componentWillMount === 'function' &&\n        instance.componentWillMount.__suppressDeprecationWarning !== true\n      ) {\n        foundWillMountName = 'componentWillMount';\n      } else if (typeof instance.UNSAFE_componentWillMount === 'function') {\n        foundWillMountName = 'UNSAFE_componentWillMount';\n      }\n      if (\n        typeof instance.componentWillReceiveProps === 'function' &&\n        instance.componentWillReceiveProps.__suppressDeprecationWarning !== true\n      ) {\n        foundWillReceivePropsName = 'componentWillReceiveProps';\n      } else if (\n        typeof instance.UNSAFE_componentWillReceiveProps === 'function'\n      ) {\n        foundWillReceivePropsName = 'UNSAFE_componentWillReceiveProps';\n      }\n      if (\n        typeof instance.componentWillUpdate === 'function' &&\n        instance.componentWillUpdate.__suppressDeprecationWarning !== true\n      ) {\n        foundWillUpdateName = 'componentWillUpdate';\n      } else if (typeof instance.UNSAFE_componentWillUpdate === 'function') {\n        foundWillUpdateName = 'UNSAFE_componentWillUpdate';\n      }\n      if (\n        foundWillMountName !== null ||\n        foundWillReceivePropsName !== null ||\n        foundWillUpdateName !== null\n      ) {\n        const componentName = getComponentNameFromType(ctor) || 'Component';\n        const newApiName =\n          typeof ctor.getDerivedStateFromProps === 'function'\n            ? 'getDerivedStateFromProps()'\n            : 'getSnapshotBeforeUpdate()';\n        if (!didWarnAboutLegacyLifecyclesAndDerivedState.has(componentName)) {\n          didWarnAboutLegacyLifecyclesAndDerivedState.add(componentName);\n          console.error(\n            'Unsafe legacy lifecycles will not be called for components using new component APIs.\\n\\n' +\n              '%s uses %s but also contains the following legacy lifecycles:%s%s%s\\n\\n' +\n              'The above lifecycles should be removed. Learn more about this warning here:\\n' +\n              'https://reactjs.org/link/unsafe-component-lifecycles',\n            componentName,\n            newApiName,\n            foundWillMountName !== null ? `\\n  ${foundWillMountName}` : '',\n            foundWillReceivePropsName !== null\n              ? `\\n  ${foundWillReceivePropsName}`\n              : '',\n            foundWillUpdateName !== null ? `\\n  ${foundWillUpdateName}` : '',\n          );\n        }\n      }\n    }\n  }\n\n  return instance;\n}\n\nfunction checkClassInstance(instance: any, ctor: any, newProps: any) {\n  if (__DEV__) {\n    const name = getComponentNameFromType(ctor) || 'Component';\n    const renderPresent = instance.render;\n\n    if (!renderPresent) {\n      if (ctor.prototype && typeof ctor.prototype.render === 'function') {\n        console.error(\n          '%s(...): No `render` method found on the returned component ' +\n            'instance: did you accidentally return an object from the constructor?',\n          name,\n        );\n      } else {\n        console.error(\n          '%s(...): No `render` method found on the returned component ' +\n            'instance: you may have forgotten to define `render`.',\n          name,\n        );\n      }\n    }\n\n    if (\n      instance.getInitialState &&\n      !instance.getInitialState.isReactClassApproved &&\n      !instance.state\n    ) {\n      console.error(\n        'getInitialState was defined on %s, a plain JavaScript class. ' +\n          'This is only supported for classes created using React.createClass. ' +\n          'Did you mean to define a state property instead?',\n        name,\n      );\n    }\n    if (\n      instance.getDefaultProps &&\n      !instance.getDefaultProps.isReactClassApproved\n    ) {\n      console.error(\n        'getDefaultProps was defined on %s, a plain JavaScript class. ' +\n          'This is only supported for classes created using React.createClass. ' +\n          'Use a static property to define defaultProps instead.',\n        name,\n      );\n    }\n    if (instance.propTypes) {\n      console.error(\n        'propTypes was defined as an instance property on %s. Use a static ' +\n          'property to define propTypes instead.',\n        name,\n      );\n    }\n    if (instance.contextType) {\n      console.error(\n        'contextType was defined as an instance property on %s. Use a static ' +\n          'property to define contextType instead.',\n        name,\n      );\n    }\n\n    if (disableLegacyContext) {\n      if (ctor.childContextTypes) {\n        console.error(\n          '%s uses the legacy childContextTypes API which is no longer supported. ' +\n            'Use React.createContext() instead.',\n          name,\n        );\n      }\n      if (ctor.contextTypes) {\n        console.error(\n          '%s uses the legacy contextTypes API which is no longer supported. ' +\n            'Use React.createContext() with static contextType instead.',\n          name,\n        );\n      }\n    } else {\n      if (instance.contextTypes) {\n        console.error(\n          'contextTypes was defined as an instance property on %s. Use a static ' +\n            'property to define contextTypes instead.',\n          name,\n        );\n      }\n\n      if (\n        ctor.contextType &&\n        ctor.contextTypes &&\n        !didWarnAboutContextTypeAndContextTypes.has(ctor)\n      ) {\n        didWarnAboutContextTypeAndContextTypes.add(ctor);\n        console.error(\n          '%s declares both contextTypes and contextType static properties. ' +\n            'The legacy contextTypes property will be ignored.',\n          name,\n        );\n      }\n    }\n\n    if (typeof instance.componentShouldUpdate === 'function') {\n      console.error(\n        '%s has a method called ' +\n          'componentShouldUpdate(). Did you mean shouldComponentUpdate()? ' +\n          'The name is phrased as a question because the function is ' +\n          'expected to return a value.',\n        name,\n      );\n    }\n    if (\n      ctor.prototype &&\n      ctor.prototype.isPureReactComponent &&\n      typeof instance.shouldComponentUpdate !== 'undefined'\n    ) {\n      console.error(\n        '%s has a method called shouldComponentUpdate(). ' +\n          'shouldComponentUpdate should not be used when extending React.PureComponent. ' +\n          'Please extend React.Component if shouldComponentUpdate is used.',\n        getComponentNameFromType(ctor) || 'A pure component',\n      );\n    }\n    if (typeof instance.componentDidUnmount === 'function') {\n      console.error(\n        '%s has a method called ' +\n          'componentDidUnmount(). But there is no such lifecycle method. ' +\n          'Did you mean componentWillUnmount()?',\n        name,\n      );\n    }\n    if (typeof instance.componentDidReceiveProps === 'function') {\n      console.error(\n        '%s has a method called ' +\n          'componentDidReceiveProps(). But there is no such lifecycle method. ' +\n          'If you meant to update the state in response to changing props, ' +\n          'use componentWillReceiveProps(). If you meant to fetch data or ' +\n          'run side-effects or mutations after React has updated the UI, use componentDidUpdate().',\n        name,\n      );\n    }\n    if (typeof instance.componentWillRecieveProps === 'function') {\n      console.error(\n        '%s has a method called ' +\n          'componentWillRecieveProps(). Did you mean componentWillReceiveProps()?',\n        name,\n      );\n    }\n    if (typeof instance.UNSAFE_componentWillRecieveProps === 'function') {\n      console.error(\n        '%s has a method called ' +\n          'UNSAFE_componentWillRecieveProps(). Did you mean UNSAFE_componentWillReceiveProps()?',\n        name,\n      );\n    }\n    const hasMutatedProps = instance.props !== newProps;\n    if (instance.props !== undefined && hasMutatedProps) {\n      console.error(\n        '%s(...): When calling super() in `%s`, make sure to pass ' +\n          \"up the same props that your component's constructor was passed.\",\n        name,\n        name,\n      );\n    }\n    if (instance.defaultProps) {\n      console.error(\n        'Setting defaultProps as an instance property on %s is not supported and will be ignored.' +\n          ' Instead, define defaultProps as a static property on %s.',\n        name,\n        name,\n      );\n    }\n\n    if (\n      typeof instance.getSnapshotBeforeUpdate === 'function' &&\n      typeof instance.componentDidUpdate !== 'function' &&\n      !didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.has(ctor)\n    ) {\n      didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.add(ctor);\n      console.error(\n        '%s: getSnapshotBeforeUpdate() should be used with componentDidUpdate(). ' +\n          'This component defines getSnapshotBeforeUpdate() only.',\n        getComponentNameFromType(ctor),\n      );\n    }\n\n    if (typeof instance.getDerivedStateFromProps === 'function') {\n      console.error(\n        '%s: getDerivedStateFromProps() is defined as an instance method ' +\n          'and will be ignored. Instead, declare it as a static method.',\n        name,\n      );\n    }\n    if (typeof instance.getDerivedStateFromError === 'function') {\n      console.error(\n        '%s: getDerivedStateFromError() is defined as an instance method ' +\n          'and will be ignored. Instead, declare it as a static method.',\n        name,\n      );\n    }\n    if (typeof ctor.getSnapshotBeforeUpdate === 'function') {\n      console.error(\n        '%s: getSnapshotBeforeUpdate() is defined as a static method ' +\n          'and will be ignored. Instead, declare it as an instance method.',\n        name,\n      );\n    }\n    const state = instance.state;\n    if (state && (typeof state !== 'object' || isArray(state))) {\n      console.error('%s.state: must be set to an object or null', name);\n    }\n    if (\n      typeof instance.getChildContext === 'function' &&\n      typeof ctor.childContextTypes !== 'object'\n    ) {\n      console.error(\n        '%s.getChildContext(): childContextTypes must be defined in order to ' +\n          'use getChildContext().',\n        name,\n      );\n    }\n  }\n}\n\nfunction callComponentWillMount(type, instance) {\n  const oldState = instance.state;\n\n  if (typeof instance.componentWillMount === 'function') {\n    if (__DEV__) {\n      if (\n        warnAboutDeprecatedLifecycles &&\n        instance.componentWillMount.__suppressDeprecationWarning !== true\n      ) {\n        const componentName = getComponentNameFromType(type) || 'Unknown';\n\n        if (!didWarnAboutDeprecatedWillMount[componentName]) {\n          console.warn(\n            // keep this warning in sync with ReactStrictModeWarning.js\n            'componentWillMount has been renamed, and is not recommended for use. ' +\n              'See https://reactjs.org/link/unsafe-component-lifecycles for details.\\n\\n' +\n              '* Move code from componentWillMount to componentDidMount (preferred in most cases) ' +\n              'or the constructor.\\n' +\n              '\\nPlease update the following components: %s',\n            componentName,\n          );\n          didWarnAboutDeprecatedWillMount[componentName] = true;\n        }\n      }\n    }\n\n    instance.componentWillMount();\n  }\n  if (typeof instance.UNSAFE_componentWillMount === 'function') {\n    instance.UNSAFE_componentWillMount();\n  }\n\n  if (oldState !== instance.state) {\n    if (__DEV__) {\n      console.error(\n        '%s.componentWillMount(): Assigning directly to this.state is ' +\n          \"deprecated (except inside a component's \" +\n          'constructor). Use setState instead.',\n        getComponentNameFromType(type) || 'Component',\n      );\n    }\n    classComponentUpdater.enqueueReplaceState(instance, instance.state, null);\n  }\n}\n\nfunction processUpdateQueue(\n  internalInstance: InternalInstance,\n  inst: any,\n  props: any,\n  maskedLegacyContext: any,\n): void {\n  if (internalInstance.queue !== null && internalInstance.queue.length > 0) {\n    const oldQueue = internalInstance.queue;\n    const oldReplace = internalInstance.replace;\n    internalInstance.queue = null;\n    internalInstance.replace = false;\n\n    if (oldReplace && oldQueue.length === 1) {\n      inst.state = oldQueue[0];\n    } else {\n      let nextState = oldReplace ? oldQueue[0] : inst.state;\n      let dontMutate = true;\n      for (let i = oldReplace ? 1 : 0; i < oldQueue.length; i++) {\n        const partial = oldQueue[i];\n        const partialState =\n          typeof partial === 'function'\n            ? partial.call(inst, nextState, props, maskedLegacyContext)\n            : partial;\n        if (partialState != null) {\n          if (dontMutate) {\n            dontMutate = false;\n            nextState = assign({}, nextState, partialState);\n          } else {\n            assign(nextState, partialState);\n          }\n        }\n      }\n      inst.state = nextState;\n    }\n  } else {\n    internalInstance.queue = null;\n  }\n}\n\n// Invokes the mount life-cycles on a previously never rendered instance.\nexport function mountClassInstance(\n  instance: any,\n  ctor: any,\n  newProps: any,\n  maskedLegacyContext: any,\n): void {\n  if (__DEV__) {\n    checkClassInstance(instance, ctor, newProps);\n  }\n\n  const initialState = instance.state !== undefined ? instance.state : null;\n\n  instance.updater = classComponentUpdater;\n  instance.props = newProps;\n  instance.state = initialState;\n  // We don't bother initializing the refs object on the server, since we're not going to resolve them anyway.\n\n  // The internal instance will be used to manage updates that happen during this mount.\n  const internalInstance: InternalInstance = {\n    queue: [],\n    replace: false,\n  };\n  setInstance(instance, internalInstance);\n\n  const contextType = ctor.contextType;\n  if (typeof contextType === 'object' && contextType !== null) {\n    instance.context = readContext(contextType);\n  } else if (disableLegacyContext) {\n    instance.context = emptyContextObject;\n  } else {\n    instance.context = maskedLegacyContext;\n  }\n\n  if (__DEV__) {\n    if (instance.state === newProps) {\n      const componentName = getComponentNameFromType(ctor) || 'Component';\n      if (!didWarnAboutDirectlyAssigningPropsToState.has(componentName)) {\n        didWarnAboutDirectlyAssigningPropsToState.add(componentName);\n        console.error(\n          '%s: It is not recommended to assign props directly to state ' +\n            \"because updates to props won't be reflected in state. \" +\n            'In most cases, it is better to use props directly.',\n          componentName,\n        );\n      }\n    }\n  }\n\n  const getDerivedStateFromProps = ctor.getDerivedStateFromProps;\n  if (typeof getDerivedStateFromProps === 'function') {\n    instance.state = applyDerivedStateFromProps(\n      instance,\n      ctor,\n      getDerivedStateFromProps,\n      initialState,\n      newProps,\n    );\n  }\n\n  // In order to support react-lifecycles-compat polyfilled components,\n  // Unsafe lifecycles should not be invoked for components using the new APIs.\n  if (\n    typeof ctor.getDerivedStateFromProps !== 'function' &&\n    typeof instance.getSnapshotBeforeUpdate !== 'function' &&\n    (typeof instance.UNSAFE_componentWillMount === 'function' ||\n      typeof instance.componentWillMount === 'function')\n  ) {\n    callComponentWillMount(ctor, instance);\n    // If we had additional state updates during this life-cycle, let's\n    // process them now.\n    processUpdateQueue(\n      internalInstance,\n      instance,\n      newProps,\n      maskedLegacyContext,\n    );\n  }\n}\n","/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\n// Ids are base 32 strings whose binary representation corresponds to the\n// position of a node in a tree.\n\n// Every time the tree forks into multiple children, we add additional bits to\n// the left of the sequence that represent the position of the child within the\n// current level of children.\n//\n//      00101       00010001011010101\n//             \n//   Fork 5 of 20       Parent id\n//\n// The leading 0s are important. In the above example, you only need 3 bits to\n// represent slot 5. However, you need 5 bits to represent all the forks at\n// the current level, so we must account for the empty bits at the end.\n//\n// For this same reason, slots are 1-indexed instead of 0-indexed. Otherwise,\n// the zeroth id at a level would be indistinguishable from its parent.\n//\n// If a node has only one child, and does not materialize an id (i.e. does not\n// contain a useId hook), then we don't need to allocate any space in the\n// sequence. It's treated as a transparent indirection. For example, these two\n// trees produce the same ids:\n//\n// <>                          <>\n//   <Indirection>               <A />\n//     <A />                     <B />\n//   </Indirection>            </>\n//   <B />\n// </>\n//\n// However, we cannot skip any node that materializes an id. Otherwise, a parent\n// id that does not fork would be indistinguishable from its child id. For\n// example, this tree does not fork, but the parent and child must have\n// different ids.\n//\n// <Parent>\n//   <Child />\n// </Parent>\n//\n// To handle this scenario, every time we materialize an id, we allocate a\n// new level with a single slot. You can think of this as a fork with only one\n// prong, or an array of children with length 1.\n//\n// It's possible for the size of the sequence to exceed 32 bits, the max\n// size for bitwise operations. When this happens, we make more room by\n// converting the right part of the id to a string and storing it in an overflow\n// variable. We use a base 32 string representation, because 32 is the largest\n// power of 2 that is supported by toString(). We want the base to be large so\n// that the resulting ids are compact, and we want the base to be a power of 2\n// because every log2(base) bits corresponds to a single character, i.e. every\n// log2(32) = 5 bits. That means we can lop bits off the end 5 at a time without\n// affecting the final result.\n\nexport type TreeContext = {\n  +id: number,\n  +overflow: string,\n};\n\nexport const emptyTreeContext = {\n  id: 1,\n  overflow: '',\n};\n\nexport function getTreeId(context: TreeContext): string {\n  const overflow = context.overflow;\n  const idWithLeadingBit = context.id;\n  const id = idWithLeadingBit & ~getLeadingBit(idWithLeadingBit);\n  return id.toString(32) + overflow;\n}\n\nexport function pushTreeContext(\n  baseContext: TreeContext,\n  totalChildren: number,\n  index: number,\n): TreeContext {\n  const baseIdWithLeadingBit = baseContext.id;\n  const baseOverflow = baseContext.overflow;\n\n  // The leftmost 1 marks the end of the sequence, non-inclusive. It's not part\n  // of the id; we use it to account for leading 0s.\n  const baseLength = getBitLength(baseIdWithLeadingBit) - 1;\n  const baseId = baseIdWithLeadingBit & ~(1 << baseLength);\n\n  const slot = index + 1;\n  const length = getBitLength(totalChildren) + baseLength;\n\n  // 30 is the max length we can store without overflowing, taking into\n  // consideration the leading 1 we use to mark the end of the sequence.\n  if (length > 30) {\n    // We overflowed the bitwise-safe range. Fall back to slower algorithm.\n    // This branch assumes the length of the base id is greater than 5; it won't\n    // work for smaller ids, because you need 5 bits per character.\n    //\n    // We encode the id in multiple steps: first the base id, then the\n    // remaining digits.\n    //\n    // Each 5 bit sequence corresponds to a single base 32 character. So for\n    // example, if the current id is 23 bits long, we can convert 20 of those\n    // bits into a string of 4 characters, with 3 bits left over.\n    //\n    // First calculate how many bits in the base id represent a complete\n    // sequence of characters.\n    const numberOfOverflowBits = baseLength - (baseLength % 5);\n\n    // Then create a bitmask that selects only those bits.\n    const newOverflowBits = (1 << numberOfOverflowBits) - 1;\n\n    // Select the bits, and convert them to a base 32 string.\n    const newOverflow = (baseId & newOverflowBits).toString(32);\n\n    // Now we can remove those bits from the base id.\n    const restOfBaseId = baseId >> numberOfOverflowBits;\n    const restOfBaseLength = baseLength - numberOfOverflowBits;\n\n    // Finally, encode the rest of the bits using the normal algorithm. Because\n    // we made more room, this time it won't overflow.\n    const restOfLength = getBitLength(totalChildren) + restOfBaseLength;\n    const restOfNewBits = slot << restOfBaseLength;\n    const id = restOfNewBits | restOfBaseId;\n    const overflow = newOverflow + baseOverflow;\n    return {\n      id: (1 << restOfLength) | id,\n      overflow,\n    };\n  } else {\n    // Normal path\n    const newBits = slot << baseLength;\n    const id = newBits | baseId;\n    const overflow = baseOverflow;\n    return {\n      id: (1 << length) | id,\n      overflow,\n    };\n  }\n}\n\nfunction getBitLength(number: number): number {\n  return 32 - clz32(number);\n}\n\nfunction getLeadingBit(id: number) {\n  return 1 << (getBitLength(id) - 1);\n}\n\n// TODO: Math.clz32 is supported in Node 12+. Maybe we can drop the fallback.\nconst clz32 = Math.clz32 ? Math.clz32 : clz32Fallback;\n\n// Count leading zeros.\n// Based on:\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/clz32\nconst log = Math.log;\nconst LN2 = Math.LN2;\nfunction clz32Fallback(x: number): number {\n  const asUint = x >>> 0;\n  if (asUint === 0) {\n    return 32;\n  }\n  return (31 - ((log(asUint) / LN2) | 0)) | 0;\n}\n","/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\n/**\n * inlined Object.is polyfill to avoid requiring consumers ship their own\n * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is\n */\nfunction is(x: any, y: any) {\n  return (\n    (x === y && (x !== 0 || 1 / x === 1 / y)) || (x !== x && y !== y) // eslint-disable-line no-self-compare\n  );\n}\n\nconst objectIs: (x: any, y: any) => boolean =\n  typeof Object.is === 'function' ? Object.is : is;\n\nexport default objectIs;\n","/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\nimport type {Dispatcher as DispatcherType} from 'react-reconciler/src/ReactInternalTypes';\n\nimport type {\n  MutableSource,\n  MutableSourceGetSnapshotFn,\n  MutableSourceSubscribeFn,\n  ReactContext,\n  StartTransitionOptions,\n} from 'shared/ReactTypes';\n\nimport type {ResponseState} from './ReactServerFormatConfig';\nimport type {Task} from './ReactFizzServer';\n\nimport {readContext as readContextImpl} from './ReactFizzNewContext';\nimport {getTreeId} from './ReactFizzTreeContext';\n\nimport {makeId} from './ReactServerFormatConfig';\n\nimport {enableCache} from 'shared/ReactFeatureFlags';\nimport is from 'shared/objectIs';\n\ntype BasicStateAction<S> = (S => S) | S;\ntype Dispatch<A> = A => void;\n\ntype Update<A> = {|\n  action: A,\n  next: Update<A> | null,\n|};\n\ntype UpdateQueue<A> = {|\n  last: Update<A> | null,\n  dispatch: any,\n|};\n\ntype Hook = {|\n  memoizedState: any,\n  queue: UpdateQueue<any> | null,\n  next: Hook | null,\n|};\n\nlet currentlyRenderingComponent: Object | null = null;\nlet currentlyRenderingTask: Task | null = null;\nlet firstWorkInProgressHook: Hook | null = null;\nlet workInProgressHook: Hook | null = null;\n// Whether the work-in-progress hook is a re-rendered hook\nlet isReRender: boolean = false;\n// Whether an update was scheduled during the currently executing render pass.\nlet didScheduleRenderPhaseUpdate: boolean = false;\n// Counts the number of useId hooks in this component\nlet localIdCounter: number = 0;\n// Lazily created map of render-phase updates\nlet renderPhaseUpdates: Map<UpdateQueue<any>, Update<any>> | null = null;\n// Counter to prevent infinite loops.\nlet numberOfReRenders: number = 0;\nconst RE_RENDER_LIMIT = 25;\n\nlet isInHookUserCodeInDev = false;\n\n// In DEV, this is the name of the currently executing primitive hook\nlet currentHookNameInDev: ?string;\n\nfunction resolveCurrentlyRenderingComponent(): Object {\n  if (currentlyRenderingComponent === null) {\n    throw new Error(\n      'Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for' +\n        ' one of the following reasons:\\n' +\n        '1. You might have mismatching versions of React and the renderer (such as React DOM)\\n' +\n        '2. You might be breaking the Rules of Hooks\\n' +\n        '3. You might have more than one copy of React in the same app\\n' +\n        'See https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.',\n    );\n  }\n\n  if (__DEV__) {\n    if (isInHookUserCodeInDev) {\n      console.error(\n        'Do not call Hooks inside useEffect(...), useMemo(...), or other built-in Hooks. ' +\n          'You can only call Hooks at the top level of your React function. ' +\n          'For more information, see ' +\n          'https://reactjs.org/link/rules-of-hooks',\n      );\n    }\n  }\n  return currentlyRenderingComponent;\n}\n\nfunction areHookInputsEqual(\n  nextDeps: Array<mixed>,\n  prevDeps: Array<mixed> | null,\n) {\n  if (prevDeps === null) {\n    if (__DEV__) {\n      console.error(\n        '%s received a final argument during this render, but not during ' +\n          'the previous render. Even though the final argument is optional, ' +\n          'its type cannot change between renders.',\n        currentHookNameInDev,\n      );\n    }\n    return false;\n  }\n\n  if (__DEV__) {\n    // Don't bother comparing lengths in prod because these arrays should be\n    // passed inline.\n    if (nextDeps.length !== prevDeps.length) {\n      console.error(\n        'The final argument passed to %s changed size between renders. The ' +\n          'order and size of this array must remain constant.\\n\\n' +\n          'Previous: %s\\n' +\n          'Incoming: %s',\n        currentHookNameInDev,\n        `[${nextDeps.join(', ')}]`,\n        `[${prevDeps.join(', ')}]`,\n      );\n    }\n  }\n  for (let i = 0; i < prevDeps.length && i < nextDeps.length; i++) {\n    if (is(nextDeps[i], prevDeps[i])) {\n      continue;\n    }\n    return false;\n  }\n  return true;\n}\n\nfunction createHook(): Hook {\n  if (numberOfReRenders > 0) {\n    throw new Error('Rendered more hooks than during the previous render');\n  }\n  return {\n    memoizedState: null,\n    queue: null,\n    next: null,\n  };\n}\n\nfunction createWorkInProgressHook(): Hook {\n  if (workInProgressHook === null) {\n    // This is the first hook in the list\n    if (firstWorkInProgressHook === null) {\n      isReRender = false;\n      firstWorkInProgressHook = workInProgressHook = createHook();\n    } else {\n      // There's already a work-in-progress. Reuse it.\n      isReRender = true;\n      workInProgressHook = firstWorkInProgressHook;\n    }\n  } else {\n    if (workInProgressHook.next === null) {\n      isReRender = false;\n      // Append to the end of the list\n      workInProgressHook = workInProgressHook.next = createHook();\n    } else {\n      // There's already a work-in-progress. Reuse it.\n      isReRender = true;\n      workInProgressHook = workInProgressHook.next;\n    }\n  }\n  return workInProgressHook;\n}\n\nexport function prepareToUseHooks(task: Task, componentIdentity: Object): void {\n  currentlyRenderingComponent = componentIdentity;\n  currentlyRenderingTask = task;\n  if (__DEV__) {\n    isInHookUserCodeInDev = false;\n  }\n\n  // The following should have already been reset\n  // didScheduleRenderPhaseUpdate = false;\n  // localIdCounter = 0;\n  // firstWorkInProgressHook = null;\n  // numberOfReRenders = 0;\n  // renderPhaseUpdates = null;\n  // workInProgressHook = null;\n\n  localIdCounter = 0;\n}\n\nexport function finishHooks(\n  Component: any,\n  props: any,\n  children: any,\n  refOrContext: any,\n): any {\n  // This must be called after every function component to prevent hooks from\n  // being used in classes.\n\n  while (didScheduleRenderPhaseUpdate) {\n    // Updates were scheduled during the render phase. They are stored in\n    // the `renderPhaseUpdates` map. Call the component again, reusing the\n    // work-in-progress hooks and applying the additional updates on top. Keep\n    // restarting until no more updates are scheduled.\n    didScheduleRenderPhaseUpdate = false;\n    localIdCounter = 0;\n    numberOfReRenders += 1;\n\n    // Start over from the beginning of the list\n    workInProgressHook = null;\n\n    children = Component(props, refOrContext);\n  }\n  resetHooksState();\n  return children;\n}\n\nexport function checkDidRenderIdHook() {\n  // This should be called immediately after every finishHooks call.\n  // Conceptually, it's part of the return value of finishHooks; it's only a\n  // separate function to avoid using an array tuple.\n  const didRenderIdHook = localIdCounter !== 0;\n  return didRenderIdHook;\n}\n\n// Reset the internal hooks state if an error occurs while rendering a component\nexport function resetHooksState(): void {\n  if (__DEV__) {\n    isInHookUserCodeInDev = false;\n  }\n\n  currentlyRenderingComponent = null;\n  currentlyRenderingTask = null;\n  didScheduleRenderPhaseUpdate = false;\n  firstWorkInProgressHook = null;\n  numberOfReRenders = 0;\n  renderPhaseUpdates = null;\n  workInProgressHook = null;\n}\n\nfunction getCacheForType<T>(resourceType: () => T): T {\n  // TODO: This should silently mark this as client rendered since it's not necessarily\n  // considered an error. It needs to work for things like Flight though.\n  throw new Error('Not implemented.');\n}\n\nfunction readContext<T>(context: ReactContext<T>): T {\n  if (__DEV__) {\n    if (isInHookUserCodeInDev) {\n      console.error(\n        'Context can only be read while React is rendering. ' +\n          'In classes, you can read it in the render method or getDerivedStateFromProps. ' +\n          'In function components, you can read it directly in the function body, but not ' +\n          'inside Hooks like useReducer() or useMemo().',\n      );\n    }\n  }\n  return readContextImpl(context);\n}\n\nfunction useContext<T>(context: ReactContext<T>): T {\n  if (__DEV__) {\n    currentHookNameInDev = 'useContext';\n  }\n  resolveCurrentlyRenderingComponent();\n  return readContextImpl(context);\n}\n\nfunction basicStateReducer<S>(state: S, action: BasicStateAction<S>): S {\n  // $FlowFixMe: Flow doesn't like mixed types\n  return typeof action === 'function' ? action(state) : action;\n}\n\nexport function useState<S>(\n  initialState: (() => S) | S,\n): [S, Dispatch<BasicStateAction<S>>] {\n  if (__DEV__) {\n    currentHookNameInDev = 'useState';\n  }\n  return useReducer(\n    basicStateReducer,\n    // useReducer has a special case to support lazy useState initializers\n    (initialState: any),\n  );\n}\n\nexport function useReducer<S, I, A>(\n  reducer: (S, A) => S,\n  initialArg: I,\n  init?: I => S,\n): [S, Dispatch<A>] {\n  if (__DEV__) {\n    if (reducer !== basicStateReducer) {\n      currentHookNameInDev = 'useReducer';\n    }\n  }\n  currentlyRenderingComponent = resolveCurrentlyRenderingComponent();\n  workInProgressHook = createWorkInProgressHook();\n  if (isReRender) {\n    // This is a re-render. Apply the new render phase updates to the previous\n    // current hook.\n    const queue: UpdateQueue<A> = (workInProgressHook.queue: any);\n    const dispatch: Dispatch<A> = (queue.dispatch: any);\n    if (renderPhaseUpdates !== null) {\n      // Render phase updates are stored in a map of queue -> linked list\n      const firstRenderPhaseUpdate = renderPhaseUpdates.get(queue);\n      if (firstRenderPhaseUpdate !== undefined) {\n        renderPhaseUpdates.delete(queue);\n        let newState = workInProgressHook.memoizedState;\n        let update = firstRenderPhaseUpdate;\n        do {\n          // Process this render phase update. We don't have to check the\n          // priority because it will always be the same as the current\n          // render's.\n          const action = update.action;\n          if (__DEV__) {\n            isInHookUserCodeInDev = true;\n          }\n          newState = reducer(newState, action);\n          if (__DEV__) {\n            isInHookUserCodeInDev = false;\n          }\n          update = update.next;\n        } while (update !== null);\n\n        workInProgressHook.memoizedState = newState;\n\n        return [newState, dispatch];\n      }\n    }\n    return [workInProgressHook.memoizedState, dispatch];\n  } else {\n    if (__DEV__) {\n      isInHookUserCodeInDev = true;\n    }\n    let initialState;\n    if (reducer === basicStateReducer) {\n      // Special case for `useState`.\n      initialState =\n        typeof initialArg === 'function'\n          ? ((initialArg: any): () => S)()\n          : ((initialArg: any): S);\n    } else {\n      initialState =\n        init !== undefined ? init(initialArg) : ((initialArg: any): S);\n    }\n    if (__DEV__) {\n      isInHookUserCodeInDev = false;\n    }\n    workInProgressHook.memoizedState = initialState;\n    const queue: UpdateQueue<A> = (workInProgressHook.queue = {\n      last: null,\n      dispatch: null,\n    });\n    const dispatch: Dispatch<A> = (queue.dispatch = (dispatchAction.bind(\n      null,\n      currentlyRenderingComponent,\n      queue,\n    ): any));\n    return [workInProgressHook.memoizedState, dispatch];\n  }\n}\n\nfunction useMemo<T>(nextCreate: () => T, deps: Array<mixed> | void | null): T {\n  currentlyRenderingComponent = resolveCurrentlyRenderingComponent();\n  workInProgressHook = createWorkInProgressHook();\n\n  const nextDeps = deps === undefined ? null : deps;\n\n  if (workInProgressHook !== null) {\n    const prevState = workInProgressHook.memoizedState;\n    if (prevState !== null) {\n      if (nextDeps !== null) {\n        const prevDeps = prevState[1];\n        if (areHookInputsEqual(nextDeps, prevDeps)) {\n          return prevState[0];\n        }\n      }\n    }\n  }\n\n  if (__DEV__) {\n    isInHookUserCodeInDev = true;\n  }\n  const nextValue = nextCreate();\n  if (__DEV__) {\n    isInHookUserCodeInDev = false;\n  }\n  workInProgressHook.memoizedState = [nextValue, nextDeps];\n  return nextValue;\n}\n\nfunction useRef<T>(initialValue: T): {|current: T|} {\n  currentlyRenderingComponent = resolveCurrentlyRenderingComponent();\n  workInProgressHook = createWorkInProgressHook();\n  const previousRef = workInProgressHook.memoizedState;\n  if (previousRef === null) {\n    const ref = {current: initialValue};\n    if (__DEV__) {\n      Object.seal(ref);\n    }\n    workInProgressHook.memoizedState = ref;\n    return ref;\n  } else {\n    return previousRef;\n  }\n}\n\nexport function useLayoutEffect(\n  create: () => (() => void) | void,\n  inputs: Array<mixed> | void | null,\n) {\n  if (__DEV__) {\n    currentHookNameInDev = 'useLayoutEffect';\n    console.error(\n      'useLayoutEffect does nothing on the server, because its effect cannot ' +\n        \"be encoded into the server renderer's output format. This will lead \" +\n        'to a mismatch between the initial, non-hydrated UI and the intended ' +\n        'UI. To avoid this, useLayoutEffect should only be used in ' +\n        'components that render exclusively on the client. ' +\n        'See https://reactjs.org/link/uselayouteffect-ssr for common fixes.',\n    );\n  }\n}\n\nfunction dispatchAction<A>(\n  componentIdentity: Object,\n  queue: UpdateQueue<A>,\n  action: A,\n) {\n  if (numberOfReRenders >= RE_RENDER_LIMIT) {\n    throw new Error(\n      'Too many re-renders. React limits the number of renders to prevent ' +\n        'an infinite loop.',\n    );\n  }\n\n  if (componentIdentity === currentlyRenderingComponent) {\n    // This is a render phase update. Stash it in a lazily-created map of\n    // queue -> linked list of updates. After this render pass, we'll restart\n    // and apply the stashed updates on top of the work-in-progress hook.\n    didScheduleRenderPhaseUpdate = true;\n    const update: Update<A> = {\n      action,\n      next: null,\n    };\n    if (renderPhaseUpdates === null) {\n      renderPhaseUpdates = new Map();\n    }\n    const firstRenderPhaseUpdate = renderPhaseUpdates.get(queue);\n    if (firstRenderPhaseUpdate === undefined) {\n      renderPhaseUpdates.set(queue, update);\n    } else {\n      // Append the update to the end of the list.\n      let lastRenderPhaseUpdate = firstRenderPhaseUpdate;\n      while (lastRenderPhaseUpdate.next !== null) {\n        lastRenderPhaseUpdate = lastRenderPhaseUpdate.next;\n      }\n      lastRenderPhaseUpdate.next = update;\n    }\n  } else {\n    // This means an update has happened after the function component has\n    // returned. On the server this is a no-op. In React Fiber, the update\n    // would be scheduled for a future render.\n  }\n}\n\nexport function useCallback<T>(\n  callback: T,\n  deps: Array<mixed> | void | null,\n): T {\n  return useMemo(() => callback, deps);\n}\n\n// TODO Decide on how to implement this hook for server rendering.\n// If a mutation occurs during render, consider triggering a Suspense boundary\n// and falling back to client rendering.\nfunction useMutableSource<Source, Snapshot>(\n  source: MutableSource<Source>,\n  getSnapshot: MutableSourceGetSnapshotFn<Source, Snapshot>,\n  subscribe: MutableSourceSubscribeFn<Source, Snapshot>,\n): Snapshot {\n  resolveCurrentlyRenderingComponent();\n  return getSnapshot(source._source);\n}\n\nfunction useSyncExternalStore<T>(\n  subscribe: (() => void) => () => void,\n  getSnapshot: () => T,\n  getServerSnapshot?: () => T,\n): T {\n  if (getServerSnapshot === undefined) {\n    throw new Error(\n      'Missing getServerSnapshot, which is required for ' +\n        'server-rendered content. Will revert to client rendering.',\n    );\n  }\n  return getServerSnapshot();\n}\n\nfunction useDeferredValue<T>(value: T): T {\n  resolveCurrentlyRenderingComponent();\n  return value;\n}\n\nfunction unsupportedStartTransition() {\n  throw new Error('startTransition cannot be called during server rendering.');\n}\n\nfunction useTransition(): [\n  boolean,\n  (callback: () => void, options?: StartTransitionOptions) => void,\n] {\n  resolveCurrentlyRenderingComponent();\n  return [false, unsupportedStartTransition];\n}\n\nfunction useId(): string {\n  const task: Task = (currentlyRenderingTask: any);\n  const treeId = getTreeId(task.treeContext);\n\n  const responseState = currentResponseState;\n  if (responseState === null) {\n    throw new Error(\n      'Invalid hook call. Hooks can only be called inside of the body of a function component.',\n    );\n  }\n\n  const localId = localIdCounter++;\n  return makeId(responseState, treeId, localId);\n}\n\nfunction unsupportedRefresh() {\n  throw new Error('Cache cannot be refreshed during server rendering.');\n}\n\nfunction useCacheRefresh(): <T>(?() => T, ?T) => void {\n  return unsupportedRefresh;\n}\n\nfunction noop(): void {}\n\nexport const Dispatcher: DispatcherType = {\n  readContext,\n  useContext,\n  useMemo,\n  useReducer,\n  useRef,\n  useState,\n  useInsertionEffect: noop,\n  useLayoutEffect,\n  useCallback,\n  // useImperativeHandle is not run in the server environment\n  useImperativeHandle: noop,\n  // Effects are not run in the server environment.\n  useEffect: noop,\n  // Debugging effect\n  useDebugValue: noop,\n  useDeferredValue,\n  useTransition,\n  useId,\n  // Subscriptions are not setup in a server environment.\n  useMutableSource,\n  useSyncExternalStore,\n};\n\nif (enableCache) {\n  Dispatcher.getCacheForType = getCacheForType;\n  Dispatcher.useCacheRefresh = useCacheRefresh;\n}\n\nexport let currentResponseState: null | ResponseState = (null: any);\nexport function setCurrentResponseState(\n  responseState: null | ResponseState,\n): void {\n  currentResponseState = responseState;\n}\n","/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\nimport type {\n  Destination,\n  Chunk,\n  PrecomputedChunk,\n} from './ReactServerStreamConfig';\nimport type {\n  ReactNodeList,\n  ReactContext,\n  ReactProviderType,\n} from 'shared/ReactTypes';\nimport type {LazyComponent as LazyComponentType} from 'react/src/ReactLazy';\nimport type {\n  SuspenseBoundaryID,\n  ResponseState,\n  FormatContext,\n} from './ReactServerFormatConfig';\nimport type {ContextSnapshot} from './ReactFizzNewContext';\nimport type {ComponentStackNode} from './ReactFizzComponentStack';\nimport type {TreeContext} from './ReactFizzTreeContext';\n\nimport {\n  scheduleWork,\n  beginWriting,\n  writeChunk,\n  writeChunkAndReturn,\n  completeWriting,\n  flushBuffered,\n  close,\n  closeWithError,\n} from './ReactServerStreamConfig';\nimport {\n  writeCompletedRoot,\n  writePlaceholder,\n  writeStartCompletedSuspenseBoundary,\n  writeStartPendingSuspenseBoundary,\n  writeStartClientRenderedSuspenseBoundary,\n  writeEndCompletedSuspenseBoundary,\n  writeEndPendingSuspenseBoundary,\n  writeEndClientRenderedSuspenseBoundary,\n  writeStartSegment,\n  writeEndSegment,\n  writeClientRenderBoundaryInstruction,\n  writeCompletedBoundaryInstruction,\n  writeCompletedSegmentInstruction,\n  pushTextInstance,\n  pushStartInstance,\n  pushEndInstance,\n  pushStartCompletedSuspenseBoundary,\n  pushEndCompletedSuspenseBoundary,\n  pushSegmentFinale,\n  UNINITIALIZED_SUSPENSE_BOUNDARY_ID,\n  assignSuspenseBoundaryID,\n  getChildFormatContext,\n} from './ReactServerFormatConfig';\nimport {\n  constructClassInstance,\n  mountClassInstance,\n} from './ReactFizzClassComponent';\nimport {\n  getMaskedContext,\n  processChildContext,\n  emptyContextObject,\n} from './ReactFizzContext';\nimport {\n  readContext,\n  rootContextSnapshot,\n  switchContext,\n  getActiveContext,\n  pushProvider,\n  popProvider,\n} from './ReactFizzNewContext';\nimport {\n  prepareToUseHooks,\n  finishHooks,\n  checkDidRenderIdHook,\n  resetHooksState,\n  Dispatcher,\n  currentResponseState,\n  setCurrentResponseState,\n} from './ReactFizzHooks';\nimport {getStackByComponentStackNode} from './ReactFizzComponentStack';\nimport {emptyTreeContext, pushTreeContext} from './ReactFizzTreeContext';\n\nimport {\n  getIteratorFn,\n  REACT_ELEMENT_TYPE,\n  REACT_PORTAL_TYPE,\n  REACT_LAZY_TYPE,\n  REACT_SUSPENSE_TYPE,\n  REACT_LEGACY_HIDDEN_TYPE,\n  REACT_DEBUG_TRACING_MODE_TYPE,\n  REACT_STRICT_MODE_TYPE,\n  REACT_PROFILER_TYPE,\n  REACT_SUSPENSE_LIST_TYPE,\n  REACT_FRAGMENT_TYPE,\n  REACT_FORWARD_REF_TYPE,\n  REACT_MEMO_TYPE,\n  REACT_PROVIDER_TYPE,\n  REACT_CONTEXT_TYPE,\n  REACT_SCOPE_TYPE,\n} from 'shared/ReactSymbols';\nimport ReactSharedInternals from 'shared/ReactSharedInternals';\nimport {\n  disableLegacyContext,\n  disableModulePatternComponents,\n  warnAboutDefaultPropsOnFunctionComponents,\n  enableScopeAPI,\n  enableSuspenseAvoidThisFallbackFizz,\n} from 'shared/ReactFeatureFlags';\n\nimport assign from 'shared/assign';\nimport getComponentNameFromType from 'shared/getComponentNameFromType';\nimport isArray from 'shared/isArray';\n\nconst ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;\nconst ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\n\ntype LegacyContext = {\n  [key: string]: any,\n};\n\ntype SuspenseBoundary = {\n  id: SuspenseBoundaryID,\n  rootSegmentID: number,\n  errorDigest: ?string, // the error hash if it errors\n  errorMessage?: string, // the error string if it errors\n  errorComponentStack?: string, // the error component stack if it errors\n  forceClientRender: boolean, // if it errors or infinitely suspends\n  parentFlushed: boolean,\n  pendingTasks: number, // when it reaches zero we can show this boundary's content\n  completedSegments: Array<Segment>, // completed but not yet flushed segments.\n  byteSize: number, // used to determine whether to inline children boundaries.\n  fallbackAbortableTasks: Set<Task>, // used to cancel task on the fallback if the boundary completes or gets canceled.\n};\n\nexport type Task = {\n  node: ReactNodeList,\n  ping: () => void,\n  blockedBoundary: Root | SuspenseBoundary,\n  blockedSegment: Segment, // the segment we'll write to\n  abortSet: Set<Task>, // the abortable set that this task belongs to\n  legacyContext: LegacyContext, // the current legacy context that this task is executing in\n  context: ContextSnapshot, // the current new context that this task is executing in\n  treeContext: TreeContext, // the current tree context that this task is executing in\n  componentStack: null | ComponentStackNode, // DEV-only component stack\n};\n\nconst PENDING = 0;\nconst COMPLETED = 1;\nconst FLUSHED = 2;\nconst ABORTED = 3;\nconst ERRORED = 4;\n\ntype Root = null;\n\ntype Segment = {\n  status: 0 | 1 | 2 | 3 | 4,\n  parentFlushed: boolean, // typically a segment will be flushed by its parent, except if its parent was already flushed\n  id: number, // starts as 0 and is lazily assigned if the parent flushes early\n  +index: number, // the index within the parent's chunks or 0 at the root\n  +chunks: Array<Chunk | PrecomputedChunk>,\n  +children: Array<Segment>,\n  // The context that this segment was created in.\n  formatContext: FormatContext,\n  // If this segment represents a fallback, this is the content that will replace that fallback.\n  +boundary: null | SuspenseBoundary,\n  // used to discern when text separator boundaries are needed\n  lastPushedText: boolean,\n  textEmbedded: boolean,\n};\n\nconst OPEN = 0;\nconst CLOSING = 1;\nconst CLOSED = 2;\n\nexport opaque type Request = {\n  destination: null | Destination,\n  +responseState: ResponseState,\n  +progressiveChunkSize: number,\n  status: 0 | 1 | 2,\n  fatalError: mixed,\n  nextSegmentId: number,\n  allPendingTasks: number, // when it reaches zero, we can close the connection.\n  pendingRootTasks: number, // when this reaches zero, we've finished at least the root boundary.\n  completedRootSegment: null | Segment, // Completed but not yet flushed root segments.\n  abortableTasks: Set<Task>,\n  pingedTasks: Array<Task>,\n  // Queues to flush in order of priority\n  clientRenderedBoundaries: Array<SuspenseBoundary>, // Errored or client rendered but not yet flushed.\n  completedBoundaries: Array<SuspenseBoundary>, // Completed but not yet fully flushed boundaries to show.\n  partialBoundaries: Array<SuspenseBoundary>, // Partially completed boundaries that can flush its segments early.\n  // onError is called when an error happens anywhere in the tree. It might recover.\n  // The return string is used in production  primarily to avoid leaking internals, secondarily to save bytes.\n  // Returning null/undefined will cause a defualt error message in production\n  onError: (error: mixed) => ?string,\n  // onAllReady is called when all pending task is done but it may not have flushed yet.\n  // This is a good time to start writing if you want only HTML and no intermediate steps.\n  onAllReady: () => void,\n  // onShellReady is called when there is at least a root fallback ready to show.\n  // Typically you don't need this callback because it's best practice to always have a\n  // root fallback ready so there's no need to wait.\n  onShellReady: () => void,\n  // onShellError is called when the shell didn't complete. That means you probably want to\n  // emit a different response to the stream instead.\n  onShellError: (error: mixed) => void,\n  onFatalError: (error: mixed) => void,\n};\n\n// This is a default heuristic for how to split up the HTML content into progressive\n// loading. Our goal is to be able to display additional new content about every 500ms.\n// Faster than that is unnecessary and should be throttled on the client. It also\n// adds unnecessary overhead to do more splits. We don't know if it's a higher or lower\n// end device but higher end suffer less from the overhead than lower end does from\n// not getting small enough pieces. We error on the side of low end.\n// We base this on low end 3G speeds which is about 500kbits per second. We assume\n// that there can be a reasonable drop off from max bandwidth which leaves you with\n// as little as 80%. We can receive half of that each 500ms - at best. In practice,\n// a little bandwidth is lost to processing and contention - e.g. CSS and images that\n// are downloaded along with the main content. So we estimate about half of that to be\n// the lower end throughput. In other words, we expect that you can at least show\n// about 12.5kb of content per 500ms. Not counting starting latency for the first\n// paint.\n// 500 * 1024 / 8 * .8 * 0.5 / 2\nconst DEFAULT_PROGRESSIVE_CHUNK_SIZE = 12800;\n\nfunction defaultErrorHandler(error: mixed) {\n  console['error'](error); // Don't transform to our wrapper\n  return null;\n}\n\nfunction noop(): void {}\n\nexport function createRequest(\n  children: ReactNodeList,\n  responseState: ResponseState,\n  rootFormatContext: FormatContext,\n  progressiveChunkSize: void | number,\n  onError: void | ((error: mixed) => ?string),\n  onAllReady: void | (() => void),\n  onShellReady: void | (() => void),\n  onShellError: void | ((error: mixed) => void),\n  onFatalError: void | ((error: mixed) => void),\n): Request {\n  const pingedTasks = [];\n  const abortSet: Set<Task> = new Set();\n  const request = {\n    destination: null,\n    responseState,\n    progressiveChunkSize:\n      progressiveChunkSize === undefined\n        ? DEFAULT_PROGRESSIVE_CHUNK_SIZE\n        : progressiveChunkSize,\n    status: OPEN,\n    fatalError: null,\n    nextSegmentId: 0,\n    allPendingTasks: 0,\n    pendingRootTasks: 0,\n    completedRootSegment: null,\n    abortableTasks: abortSet,\n    pingedTasks: pingedTasks,\n    clientRenderedBoundaries: [],\n    completedBoundaries: [],\n    partialBoundaries: [],\n    onError: onError === undefined ? defaultErrorHandler : onError,\n    onAllReady: onAllReady === undefined ? noop : onAllReady,\n    onShellReady: onShellReady === undefined ? noop : onShellReady,\n    onShellError: onShellError === undefined ? noop : onShellError,\n    onFatalError: onFatalError === undefined ? noop : onFatalError,\n  };\n  // This segment represents the root fallback.\n  const rootSegment = createPendingSegment(\n    request,\n    0,\n    null,\n    rootFormatContext,\n    // Root segments are never embedded in Text on either edge\n    false,\n    false,\n  );\n  // There is no parent so conceptually, we're unblocked to flush this segment.\n  rootSegment.parentFlushed = true;\n  const rootTask = createTask(\n    request,\n    children,\n    null,\n    rootSegment,\n    abortSet,\n    emptyContextObject,\n    rootContextSnapshot,\n    emptyTreeContext,\n  );\n  pingedTasks.push(rootTask);\n  return request;\n}\n\nfunction pingTask(request: Request, task: Task): void {\n  const pingedTasks = request.pingedTasks;\n  pingedTasks.push(task);\n  if (pingedTasks.length === 1) {\n    scheduleWork(() => performWork(request));\n  }\n}\n\nfunction createSuspenseBoundary(\n  request: Request,\n  fallbackAbortableTasks: Set<Task>,\n): SuspenseBoundary {\n  return {\n    id: UNINITIALIZED_SUSPENSE_BOUNDARY_ID,\n    rootSegmentID: -1,\n    parentFlushed: false,\n    pendingTasks: 0,\n    forceClientRender: false,\n    completedSegments: [],\n    byteSize: 0,\n    fallbackAbortableTasks,\n    errorDigest: null,\n  };\n}\n\nfunction createTask(\n  request: Request,\n  node: ReactNodeList,\n  blockedBoundary: Root | SuspenseBoundary,\n  blockedSegment: Segment,\n  abortSet: Set<Task>,\n  legacyContext: LegacyContext,\n  context: ContextSnapshot,\n  treeContext: TreeContext,\n): Task {\n  request.allPendingTasks++;\n  if (blockedBoundary === null) {\n    request.pendingRootTasks++;\n  } else {\n    blockedBoundary.pendingTasks++;\n  }\n  const task: Task = ({\n    node,\n    ping: () => pingTask(request, task),\n    blockedBoundary,\n    blockedSegment,\n    abortSet,\n    legacyContext,\n    context,\n    treeContext,\n  }: any);\n  if (__DEV__) {\n    task.componentStack = null;\n  }\n  abortSet.add(task);\n  return task;\n}\n\nfunction createPendingSegment(\n  request: Request,\n  index: number,\n  boundary: null | SuspenseBoundary,\n  formatContext: FormatContext,\n  lastPushedText: boolean,\n  textEmbedded: boolean,\n): Segment {\n  return {\n    status: PENDING,\n    id: -1, // lazily assigned later\n    index,\n    parentFlushed: false,\n    chunks: [],\n    children: [],\n    formatContext,\n    boundary,\n    lastPushedText,\n    textEmbedded,\n  };\n}\n\n// DEV-only global reference to the currently executing task\nlet currentTaskInDEV: null | Task = null;\nfunction getCurrentStackInDEV(): string {\n  if (__DEV__) {\n    if (currentTaskInDEV === null || currentTaskInDEV.componentStack === null) {\n      return '';\n    }\n    return getStackByComponentStackNode(currentTaskInDEV.componentStack);\n  }\n  return '';\n}\n\nfunction pushBuiltInComponentStackInDEV(task: Task, type: string): void {\n  if (__DEV__) {\n    task.componentStack = {\n      tag: 0,\n      parent: task.componentStack,\n      type,\n    };\n  }\n}\nfunction pushFunctionComponentStackInDEV(task: Task, type: Function): void {\n  if (__DEV__) {\n    task.componentStack = {\n      tag: 1,\n      parent: task.componentStack,\n      type,\n    };\n  }\n}\nfunction pushClassComponentStackInDEV(task: Task, type: Function): void {\n  if (__DEV__) {\n    task.componentStack = {\n      tag: 2,\n      parent: task.componentStack,\n      type,\n    };\n  }\n}\nfunction popComponentStackInDEV(task: Task): void {\n  if (__DEV__) {\n    if (task.componentStack === null) {\n      console.error(\n        'Unexpectedly popped too many stack frames. This is a bug in React.',\n      );\n    } else {\n      task.componentStack = task.componentStack.parent;\n    }\n  }\n}\n\n// stash the component stack of an unwinding error until it is processed\nlet lastBoundaryErrorComponentStackDev: ?string = null;\n\nfunction captureBoundaryErrorDetailsDev(\n  boundary: SuspenseBoundary,\n  error: mixed,\n) {\n  if (__DEV__) {\n    let errorMessage;\n    if (typeof error === 'string') {\n      errorMessage = error;\n    } else if (error && typeof error.message === 'string') {\n      errorMessage = error.message;\n    } else {\n      // eslint-disable-next-line react-internal/safe-string-coercion\n      errorMessage = String(error);\n    }\n\n    const errorComponentStack =\n      lastBoundaryErrorComponentStackDev || getCurrentStackInDEV();\n    lastBoundaryErrorComponentStackDev = null;\n\n    boundary.errorMessage = errorMessage;\n    boundary.errorComponentStack = errorComponentStack;\n  }\n}\n\nfunction logRecoverableError(request: Request, error: any): ?string {\n  // If this callback errors, we intentionally let that error bubble up to become a fatal error\n  // so that someone fixes the error reporting instead of hiding it.\n  const errorDigest = request.onError(error);\n  if (errorDigest != null && typeof errorDigest !== 'string') {\n    // eslint-disable-next-line react-internal/prod-error-codes\n    throw new Error(\n      `onError returned something with a type other than \"string\". onError should return a string and may return null or undefined but must not return anything else. It received something of type \"${typeof errorDigest}\" instead`,\n    );\n  }\n  return errorDigest;\n}\n\nfunction fatalError(request: Request, error: mixed): void {\n  // This is called outside error handling code such as if the root errors outside\n  // a suspense boundary or if the root suspense boundary's fallback errors.\n  // It's also called if React itself or its host configs errors.\n  const onShellError = request.onShellError;\n  onShellError(error);\n  const onFatalError = request.onFatalError;\n  onFatalError(error);\n  if (request.destination !== null) {\n    request.status = CLOSED;\n    closeWithError(request.destination, error);\n  } else {\n    request.status = CLOSING;\n    request.fatalError = error;\n  }\n}\n\nfunction renderSuspenseBoundary(\n  request: Request,\n  task: Task,\n  props: Object,\n): void {\n  pushBuiltInComponentStackInDEV(task, 'Suspense');\n  const parentBoundary = task.blockedBoundary;\n  const parentSegment = task.blockedSegment;\n\n  // Each time we enter a suspense boundary, we split out into a new segment for\n  // the fallback so that we can later replace that segment with the content.\n  // This also lets us split out the main content even if it doesn't suspend,\n  // in case it ends up generating a large subtree of content.\n  const fallback: ReactNodeList = props.fallback;\n  const content: ReactNodeList = props.children;\n\n  const fallbackAbortSet: Set<Task> = new Set();\n  const newBoundary = createSuspenseBoundary(request, fallbackAbortSet);\n  const insertionIndex = parentSegment.chunks.length;\n  // The children of the boundary segment is actually the fallback.\n  const boundarySegment = createPendingSegment(\n    request,\n    insertionIndex,\n    newBoundary,\n    parentSegment.formatContext,\n    // boundaries never require text embedding at their edges because comment nodes bound them\n    false,\n    false,\n  );\n  parentSegment.children.push(boundarySegment);\n  // The parentSegment has a child Segment at this index so we reset the lastPushedText marker on the parent\n  parentSegment.lastPushedText = false;\n\n  // This segment is the actual child content. We can start rendering that immediately.\n  const contentRootSegment = createPendingSegment(\n    request,\n    0,\n    null,\n    parentSegment.formatContext,\n    // boundaries never require text embedding at their edges because comment nodes bound them\n    false,\n    false,\n  );\n  // We mark the root segment as having its parent flushed. It's not really flushed but there is\n  // no parent segment so there's nothing to wait on.\n  contentRootSegment.parentFlushed = true;\n\n  // Currently this is running synchronously. We could instead schedule this to pingedTasks.\n  // I suspect that there might be some efficiency benefits from not creating the suspended task\n  // and instead just using the stack if possible.\n  // TODO: Call this directly instead of messing with saving and restoring contexts.\n\n  // We can reuse the current context and task to render the content immediately without\n  // context switching. We just need to temporarily switch which boundary and which segment\n  // we're writing to. If something suspends, it'll spawn new suspended task with that context.\n  task.blockedBoundary = newBoundary;\n  task.blockedSegment = contentRootSegment;\n  try {\n    // We use the safe form because we don't handle suspending here. Only error handling.\n    renderNode(request, task, content);\n    pushSegmentFinale(\n      contentRootSegment.chunks,\n      request.responseState,\n      contentRootSegment.lastPushedText,\n      contentRootSegment.textEmbedded,\n    );\n    contentRootSegment.status = COMPLETED;\n    queueCompletedSegment(newBoundary, contentRootSegment);\n    if (newBoundary.pendingTasks === 0) {\n      // This must have been the last segment we were waiting on. This boundary is now complete.\n      // Therefore we won't need the fallback. We early return so that we don't have to create\n      // the fallback.\n      popComponentStackInDEV(task);\n      return;\n    }\n  } catch (error) {\n    contentRootSegment.status = ERRORED;\n    newBoundary.forceClientRender = true;\n    newBoundary.errorDigest = logRecoverableError(request, error);\n    if (__DEV__) {\n      captureBoundaryErrorDetailsDev(newBoundary, error);\n    }\n\n    // We don't need to decrement any task numbers because we didn't spawn any new task.\n    // We don't need to schedule any task because we know the parent has written yet.\n    // We do need to fallthrough to create the fallback though.\n  } finally {\n    task.blockedBoundary = parentBoundary;\n    task.blockedSegment = parentSegment;\n  }\n\n  // We create suspended task for the fallback because we don't want to actually work\n  // on it yet in case we finish the main content, so we queue for later.\n  const suspendedFallbackTask = createTask(\n    request,\n    fallback,\n    parentBoundary,\n    boundarySegment,\n    fallbackAbortSet,\n    task.legacyContext,\n    task.context,\n    task.treeContext,\n  );\n  if (__DEV__) {\n    suspendedFallbackTask.componentStack = task.componentStack;\n  }\n  // TODO: This should be queued at a separate lower priority queue so that we only work\n  // on preparing fallbacks if we don't have any more main content to task on.\n  request.pingedTasks.push(suspendedFallbackTask);\n\n  popComponentStackInDEV(task);\n}\n\nfunction renderBackupSuspenseBoundary(\n  request: Request,\n  task: Task,\n  props: Object,\n) {\n  pushBuiltInComponentStackInDEV(task, 'Suspense');\n\n  const content = props.children;\n  const segment = task.blockedSegment;\n\n  pushStartCompletedSuspenseBoundary(segment.chunks);\n  renderNode(request, task, content);\n  pushEndCompletedSuspenseBoundary(segment.chunks);\n\n  popComponentStackInDEV(task);\n}\n\nfunction renderHostElement(\n  request: Request,\n  task: Task,\n  type: string,\n  props: Object,\n): void {\n  pushBuiltInComponentStackInDEV(task, type);\n  const segment = task.blockedSegment;\n  const children = pushStartInstance(\n    segment.chunks,\n    type,\n    props,\n    request.responseState,\n    segment.formatContext,\n  );\n  segment.lastPushedText = false;\n  const prevContext = segment.formatContext;\n  segment.formatContext = getChildFormatContext(prevContext, type, props);\n  // We use the non-destructive form because if something suspends, we still\n  // need to pop back up and finish this subtree of HTML.\n  renderNode(request, task, children);\n\n  // We expect that errors will fatal the whole task and that we don't need\n  // the correct context. Therefore this is not in a finally.\n  segment.formatContext = prevContext;\n  pushEndInstance(segment.chunks, type, props);\n  segment.lastPushedText = false;\n  popComponentStackInDEV(task);\n}\n\nfunction shouldConstruct(Component) {\n  return Component.prototype && Component.prototype.isReactComponent;\n}\n\nfunction renderWithHooks<Props, SecondArg>(\n  request: Request,\n  task: Task,\n  Component: (p: Props, arg: SecondArg) => any,\n  props: Props,\n  secondArg: SecondArg,\n): any {\n  const componentIdentity = {};\n  prepareToUseHooks(task, componentIdentity);\n  const result = Component(props, secondArg);\n  return finishHooks(Component, props, result, secondArg);\n}\n\nfunction finishClassComponent(\n  request: Request,\n  task: Task,\n  instance: any,\n  Component: any,\n  props: any,\n): ReactNodeList {\n  const nextChildren = instance.render();\n\n  if (__DEV__) {\n    if (instance.props !== props) {\n      if (!didWarnAboutReassigningProps) {\n        console.error(\n          'It looks like %s is reassigning its own `this.props` while rendering. ' +\n            'This is not supported and can lead to confusing bugs.',\n          getComponentNameFromType(Component) || 'a component',\n        );\n      }\n      didWarnAboutReassigningProps = true;\n    }\n  }\n\n  if (!disableLegacyContext) {\n    const childContextTypes = Component.childContextTypes;\n    if (childContextTypes !== null && childContextTypes !== undefined) {\n      const previousContext = task.legacyContext;\n      const mergedContext = processChildContext(\n        instance,\n        Component,\n        previousContext,\n        childContextTypes,\n      );\n      task.legacyContext = mergedContext;\n      renderNodeDestructive(request, task, nextChildren);\n      task.legacyContext = previousContext;\n      return;\n    }\n  }\n\n  renderNodeDestructive(request, task, nextChildren);\n}\n\nfunction renderClassComponent(\n  request: Request,\n  task: Task,\n  Component: any,\n  props: any,\n): void {\n  pushClassComponentStackInDEV(task, Component);\n  const maskedContext = !disableLegacyContext\n    ? getMaskedContext(Component, task.legacyContext)\n    : undefined;\n  const instance = constructClassInstance(Component, props, maskedContext);\n  mountClassInstance(instance, Component, props, maskedContext);\n  finishClassComponent(request, task, instance, Component, props);\n  popComponentStackInDEV(task);\n}\n\nconst didWarnAboutBadClass = {};\nconst didWarnAboutModulePatternComponent = {};\nconst didWarnAboutContextTypeOnFunctionComponent = {};\nconst didWarnAboutGetDerivedStateOnFunctionComponent = {};\nlet didWarnAboutReassigningProps = false;\nconst didWarnAboutDefaultPropsOnFunctionComponent = {};\nlet didWarnAboutGenerators = false;\nlet didWarnAboutMaps = false;\nlet hasWarnedAboutUsingContextAsConsumer = false;\n\n// This would typically be a function component but we still support module pattern\n// components for some reason.\nfunction renderIndeterminateComponent(\n  request: Request,\n  task: Task,\n  Component: any,\n  props: any,\n): void {\n  let legacyContext;\n  if (!disableLegacyContext) {\n    legacyContext = getMaskedContext(Component, task.legacyContext);\n  }\n  pushFunctionComponentStackInDEV(task, Component);\n\n  if (__DEV__) {\n    if (\n      Component.prototype &&\n      typeof Component.prototype.render === 'function'\n    ) {\n      const componentName = getComponentNameFromType(Component) || 'Unknown';\n\n      if (!didWarnAboutBadClass[componentName]) {\n        console.error(\n          \"The <%s /> component appears to have a render method, but doesn't extend React.Component. \" +\n            'This is likely to cause errors. Change %s to extend React.Component instead.',\n          componentName,\n          componentName,\n        );\n        didWarnAboutBadClass[componentName] = true;\n      }\n    }\n  }\n\n  const value = renderWithHooks(request, task, Component, props, legacyContext);\n  const hasId = checkDidRenderIdHook();\n\n  if (__DEV__) {\n    // Support for module components is deprecated and is removed behind a flag.\n    // Whether or not it would crash later, we want to show a good message in DEV first.\n    if (\n      typeof value === 'object' &&\n      value !== null &&\n      typeof value.render === 'function' &&\n      value.$$typeof === undefined\n    ) {\n      const componentName = getComponentNameFromType(Component) || 'Unknown';\n      if (!didWarnAboutModulePatternComponent[componentName]) {\n        console.error(\n          'The <%s /> component appears to be a function component that returns a class instance. ' +\n            'Change %s to a class that extends React.Component instead. ' +\n            \"If you can't use a class try assigning the prototype on the function as a workaround. \" +\n            \"`%s.prototype = React.Component.prototype`. Don't use an arrow function since it \" +\n            'cannot be called with `new` by React.',\n          componentName,\n          componentName,\n          componentName,\n        );\n        didWarnAboutModulePatternComponent[componentName] = true;\n      }\n    }\n  }\n\n  if (\n    // Run these checks in production only if the flag is off.\n    // Eventually we'll delete this branch altogether.\n    !disableModulePatternComponents &&\n    typeof value === 'object' &&\n    value !== null &&\n    typeof value.render === 'function' &&\n    value.$$typeof === undefined\n  ) {\n    if (__DEV__) {\n      const componentName = getComponentNameFromType(Component) || 'Unknown';\n      if (!didWarnAboutModulePatternComponent[componentName]) {\n        console.error(\n          'The <%s /> component appears to be a function component that returns a class instance. ' +\n            'Change %s to a class that extends React.Component instead. ' +\n            \"If you can't use a class try assigning the prototype on the function as a workaround. \" +\n            \"`%s.prototype = React.Component.prototype`. Don't use an arrow function since it \" +\n            'cannot be called with `new` by React.',\n          componentName,\n          componentName,\n          componentName,\n        );\n        didWarnAboutModulePatternComponent[componentName] = true;\n      }\n    }\n\n    mountClassInstance(value, Component, props, legacyContext);\n    finishClassComponent(request, task, value, Component, props);\n  } else {\n    // Proceed under the assumption that this is a function component\n    if (__DEV__) {\n      if (disableLegacyContext && Component.contextTypes) {\n        console.error(\n          '%s uses the legacy contextTypes API which is no longer supported. ' +\n            'Use React.createContext() with React.useContext() instead.',\n          getComponentNameFromType(Component) || 'Unknown',\n        );\n      }\n    }\n    if (__DEV__) {\n      validateFunctionComponentInDev(Component);\n    }\n    // We're now successfully past this task, and we don't have to pop back to\n    // the previous task every again, so we can use the destructive recursive form.\n    if (hasId) {\n      // This component materialized an id. We treat this as its own level, with\n      // a single \"child\" slot.\n      const prevTreeContext = task.treeContext;\n      const totalChildren = 1;\n      const index = 0;\n      task.treeContext = pushTreeContext(prevTreeContext, totalChildren, index);\n      try {\n        renderNodeDestructive(request, task, value);\n      } finally {\n        task.treeContext = prevTreeContext;\n      }\n    } else {\n      renderNodeDestructive(request, task, value);\n    }\n  }\n  popComponentStackInDEV(task);\n}\n\nfunction validateFunctionComponentInDev(Component: any): void {\n  if (__DEV__) {\n    if (Component) {\n      if (Component.childContextTypes) {\n        console.error(\n          '%s(...): childContextTypes cannot be defined on a function component.',\n          Component.displayName || Component.name || 'Component',\n        );\n      }\n    }\n\n    if (\n      warnAboutDefaultPropsOnFunctionComponents &&\n      Component.defaultProps !== undefined\n    ) {\n      const componentName = getComponentNameFromType(Component) || 'Unknown';\n\n      if (!didWarnAboutDefaultPropsOnFunctionComponent[componentName]) {\n        console.error(\n          '%s: Support for defaultProps will be removed from function components ' +\n            'in a future major release. Use JavaScript default parameters instead.',\n          componentName,\n        );\n        didWarnAboutDefaultPropsOnFunctionComponent[componentName] = true;\n      }\n    }\n\n    if (typeof Component.getDerivedStateFromProps === 'function') {\n      const componentName = getComponentNameFromType(Component) || 'Unknown';\n\n      if (!didWarnAboutGetDerivedStateOnFunctionComponent[componentName]) {\n        console.error(\n          '%s: Function components do not support getDerivedStateFromProps.',\n          componentName,\n        );\n        didWarnAboutGetDerivedStateOnFunctionComponent[componentName] = true;\n      }\n    }\n\n    if (\n      typeof Component.contextType === 'object' &&\n      Component.contextType !== null\n    ) {\n      const componentName = getComponentNameFromType(Component) || 'Unknown';\n\n      if (!didWarnAboutContextTypeOnFunctionComponent[componentName]) {\n        console.error(\n          '%s: Function components do not support contextType.',\n          componentName,\n        );\n        didWarnAboutContextTypeOnFunctionComponent[componentName] = true;\n      }\n    }\n  }\n}\n\nfunction resolveDefaultProps(Component: any, baseProps: Object): Object {\n  if (Component && Component.defaultProps) {\n    // Resolve default props. Taken from ReactElement\n    const props = assign({}, baseProps);\n    const defaultProps = Component.defaultProps;\n    for (const propName in defaultProps) {\n      if (props[propName] === undefined) {\n        props[propName] = defaultProps[propName];\n      }\n    }\n    return props;\n  }\n  return baseProps;\n}\n\nfunction renderForwardRef(\n  request: Request,\n  task: Task,\n  type: any,\n  props: Object,\n  ref: any,\n): void {\n  pushFunctionComponentStackInDEV(task, type.render);\n  const children = renderWithHooks(request, task, type.render, props, ref);\n  const hasId = checkDidRenderIdHook();\n  if (hasId) {\n    // This component materialized an id. We treat this as its own level, with\n    // a single \"child\" slot.\n    const prevTreeContext = task.treeContext;\n    const totalChildren = 1;\n    const index = 0;\n    task.treeContext = pushTreeContext(prevTreeContext, totalChildren, index);\n    try {\n      renderNodeDestructive(request, task, children);\n    } finally {\n      task.treeContext = prevTreeContext;\n    }\n  } else {\n    renderNodeDestructive(request, task, children);\n  }\n  popComponentStackInDEV(task);\n}\n\nfunction renderMemo(\n  request: Request,\n  task: Task,\n  type: any,\n  props: Object,\n  ref: any,\n): void {\n  const innerType = type.type;\n  const resolvedProps = resolveDefaultProps(innerType, props);\n  renderElement(request, task, innerType, resolvedProps, ref);\n}\n\nfunction renderContextConsumer(\n  request: Request,\n  task: Task,\n  context: ReactContext<any>,\n  props: Object,\n): void {\n  // The logic below for Context differs depending on PROD or DEV mode. In\n  // DEV mode, we create a separate object for Context.Consumer that acts\n  // like a proxy to Context. This proxy object adds unnecessary code in PROD\n  // so we use the old behaviour (Context.Consumer references Context) to\n  // reduce size and overhead. The separate object references context via\n  // a property called \"_context\", which also gives us the ability to check\n  // in DEV mode if this property exists or not and warn if it does not.\n  if (__DEV__) {\n    if ((context: any)._context === undefined) {\n      // This may be because it's a Context (rather than a Consumer).\n      // Or it may be because it's older React where they're the same thing.\n      // We only want to warn if we're sure it's a new React.\n      if (context !== context.Consumer) {\n        if (!hasWarnedAboutUsingContextAsConsumer) {\n          hasWarnedAboutUsingContextAsConsumer = true;\n          console.error(\n            'Rendering <Context> directly is not supported and will be removed in ' +\n              'a future major release. Did you mean to render <Context.Consumer> instead?',\n          );\n        }\n      }\n    } else {\n      context = (context: any)._context;\n    }\n  }\n  const render = props.children;\n\n  if (__DEV__) {\n    if (typeof render !== 'function') {\n      console.error(\n        'A context consumer was rendered with multiple children, or a child ' +\n          \"that isn't a function. A context consumer expects a single child \" +\n          'that is a function. If you did pass a function, make sure there ' +\n          'is no trailing or leading whitespace around it.',\n      );\n    }\n  }\n\n  const newValue = readContext(context);\n  const newChildren = render(newValue);\n\n  renderNodeDestructive(request, task, newChildren);\n}\n\nfunction renderContextProvider(\n  request: Request,\n  task: Task,\n  type: ReactProviderType<any>,\n  props: Object,\n): void {\n  const context = type._context;\n  const value = props.value;\n  const children = props.children;\n  let prevSnapshot;\n  if (__DEV__) {\n    prevSnapshot = task.context;\n  }\n  task.context = pushProvider(context, value);\n  renderNodeDestructive(request, task, children);\n  task.context = popProvider(context);\n  if (__DEV__) {\n    if (prevSnapshot !== task.context) {\n      console.error(\n        'Popping the context provider did not return back to the original snapshot. This is a bug in React.',\n      );\n    }\n  }\n}\n\nfunction renderLazyComponent(\n  request: Request,\n  task: Task,\n  lazyComponent: LazyComponentType<any, any>,\n  props: Object,\n  ref: any,\n): void {\n  pushBuiltInComponentStackInDEV(task, 'Lazy');\n  const payload = lazyComponent._payload;\n  const init = lazyComponent._init;\n  const Component = init(payload);\n  const resolvedProps = resolveDefaultProps(Component, props);\n  renderElement(request, task, Component, resolvedProps, ref);\n  popComponentStackInDEV(task);\n}\n\nfunction renderElement(\n  request: Request,\n  task: Task,\n  type: any,\n  props: Object,\n  ref: any,\n): void {\n  if (typeof type === 'function') {\n    if (shouldConstruct(type)) {\n      renderClassComponent(request, task, type, props);\n      return;\n    } else {\n      renderIndeterminateComponent(request, task, type, props);\n      return;\n    }\n  }\n  if (typeof type === 'string') {\n    renderHostElement(request, task, type, props);\n    return;\n  }\n\n  switch (type) {\n    // TODO: LegacyHidden acts the same as a fragment. This only works\n    // because we currently assume that every instance of LegacyHidden is\n    // accompanied by a host component wrapper. In the hidden mode, the host\n    // component is given a `hidden` attribute, which ensures that the\n    // initial HTML is not visible. To support the use of LegacyHidden as a\n    // true fragment, without an extra DOM node, we would have to hide the\n    // initial HTML in some other way.\n    // TODO: Add REACT_OFFSCREEN_TYPE here too with the same capability.\n    case REACT_LEGACY_HIDDEN_TYPE:\n    case REACT_DEBUG_TRACING_MODE_TYPE:\n    case REACT_STRICT_MODE_TYPE:\n    case REACT_PROFILER_TYPE:\n    case REACT_FRAGMENT_TYPE: {\n      renderNodeDestructive(request, task, props.children);\n      return;\n    }\n    case REACT_SUSPENSE_LIST_TYPE: {\n      pushBuiltInComponentStackInDEV(task, 'SuspenseList');\n      // TODO: SuspenseList should control the boundaries.\n      renderNodeDestructive(request, task, props.children);\n      popComponentStackInDEV(task);\n      return;\n    }\n    case REACT_SCOPE_TYPE: {\n      if (enableScopeAPI) {\n        renderNodeDestructive(request, task, props.children);\n        return;\n      }\n      throw new Error('ReactDOMServer does not yet support scope components.');\n    }\n    // eslint-disable-next-line-no-fallthrough\n    case REACT_SUSPENSE_TYPE: {\n      if (\n        enableSuspenseAvoidThisFallbackFizz &&\n        props.unstable_avoidThisFallback === true\n      ) {\n        renderBackupSuspenseBoundary(request, task, props);\n      } else {\n        renderSuspenseBoundary(request, task, props);\n      }\n      return;\n    }\n  }\n\n  if (typeof type === 'object' && type !== null) {\n    switch (type.$$typeof) {\n      case REACT_FORWARD_REF_TYPE: {\n        renderForwardRef(request, task, type, props, ref);\n        return;\n      }\n      case REACT_MEMO_TYPE: {\n        renderMemo(request, task, type, props, ref);\n        return;\n      }\n      case REACT_PROVIDER_TYPE: {\n        renderContextProvider(request, task, type, props);\n        return;\n      }\n      case REACT_CONTEXT_TYPE: {\n        renderContextConsumer(request, task, type, props);\n        return;\n      }\n      case REACT_LAZY_TYPE: {\n        renderLazyComponent(request, task, type, props);\n        return;\n      }\n    }\n  }\n\n  let info = '';\n  if (__DEV__) {\n    if (\n      type === undefined ||\n      (typeof type === 'object' &&\n        type !== null &&\n        Object.keys(type).length === 0)\n    ) {\n      info +=\n        ' You likely forgot to export your component from the file ' +\n        \"it's defined in, or you might have mixed up default and \" +\n        'named imports.';\n    }\n  }\n\n  throw new Error(\n    'Element type is invalid: expected a string (for built-in ' +\n      'components) or a class/function (for composite components) ' +\n      `but got: ${type == null ? type : typeof type}.${info}`,\n  );\n}\n\nfunction validateIterable(iterable, iteratorFn: Function): void {\n  if (__DEV__) {\n    // We don't support rendering Generators because it's a mutation.\n    // See https://github.com/facebook/react/issues/12995\n    if (\n      typeof Symbol === 'function' &&\n      // $FlowFixMe Flow doesn't know about toStringTag\n      iterable[Symbol.toStringTag] === 'Generator'\n    ) {\n      if (!didWarnAboutGenerators) {\n        console.error(\n          'Using Generators as children is unsupported and will likely yield ' +\n            'unexpected results because enumerating a generator mutates it. ' +\n            'You may convert it to an array with `Array.from()` or the ' +\n            '`[...spread]` operator before rendering. Keep in mind ' +\n            'you might need to polyfill these features for older browsers.',\n        );\n      }\n      didWarnAboutGenerators = true;\n    }\n\n    // Warn about using Maps as children\n    if ((iterable: any).entries === iteratorFn) {\n      if (!didWarnAboutMaps) {\n        console.error(\n          'Using Maps as children is not supported. ' +\n            'Use an array of keyed ReactElements instead.',\n        );\n      }\n      didWarnAboutMaps = true;\n    }\n  }\n}\n\nfunction renderNodeDestructive(\n  request: Request,\n  task: Task,\n  node: ReactNodeList,\n): void {\n  if (__DEV__) {\n    // In Dev we wrap renderNodeDestructiveImpl in a try / catch so we can capture\n    // a component stack at the right place in the tree. We don't do this in renderNode\n    // becuase it is not called at every layer of the tree and we may lose frames\n    try {\n      return renderNodeDestructiveImpl(request, task, node);\n    } catch (x) {\n      if (typeof x === 'object' && x !== null && typeof x.then === 'function') {\n        // This is a Wakable, noop\n      } else {\n        // This is an error, stash the component stack if it is null.\n        lastBoundaryErrorComponentStackDev =\n          lastBoundaryErrorComponentStackDev !== null\n            ? lastBoundaryErrorComponentStackDev\n            : getCurrentStackInDEV();\n      }\n      // rethrow so normal suspense logic can handle thrown value accordingly\n      throw x;\n    }\n  } else {\n    return renderNodeDestructiveImpl(request, task, node);\n  }\n}\n\n// This function by it self renders a node and consumes the task by mutating it\n// to update the current execution state.\nfunction renderNodeDestructiveImpl(\n  request: Request,\n  task: Task,\n  node: ReactNodeList,\n): void {\n  // Stash the node we're working on. We'll pick up from this task in case\n  // something suspends.\n  task.node = node;\n\n  // Handle object types\n  if (typeof node === 'object' && node !== null) {\n    switch ((node: any).$$typeof) {\n      case REACT_ELEMENT_TYPE: {\n        const element: React$Element<any> = (node: any);\n        const type = element.type;\n        const props = element.props;\n        const ref = element.ref;\n        renderElement(request, task, type, props, ref);\n        return;\n      }\n      case REACT_PORTAL_TYPE:\n        throw new Error(\n          'Portals are not currently supported by the server renderer. ' +\n            'Render them conditionally so that they only appear on the client render.',\n        );\n      // eslint-disable-next-line-no-fallthrough\n      case REACT_LAZY_TYPE: {\n        const lazyNode: LazyComponentType<any, any> = (node: any);\n        const payload = lazyNode._payload;\n        const init = lazyNode._init;\n        let resolvedNode;\n        if (__DEV__) {\n          try {\n            resolvedNode = init(payload);\n          } catch (x) {\n            if (\n              typeof x === 'object' &&\n              x !== null &&\n              typeof x.then === 'function'\n            ) {\n              // this Lazy initializer is suspending. push a temporary frame onto the stack so it can be\n              // popped off in spawnNewSuspendedTask. This aligns stack behavior between Lazy in element position\n              // vs Component position. We do not want the frame for Errors so we exclusively do this in\n              // the wakeable branch\n              pushBuiltInComponentStackInDEV(task, 'Lazy');\n            }\n            throw x;\n          }\n        } else {\n          resolvedNode = init(payload);\n        }\n        renderNodeDestructive(request, task, resolvedNode);\n        return;\n      }\n    }\n\n    if (isArray(node)) {\n      renderChildrenArray(request, task, node);\n      return;\n    }\n\n    const iteratorFn = getIteratorFn(node);\n    if (iteratorFn) {\n      if (__DEV__) {\n        validateIterable(node, iteratorFn);\n      }\n      const iterator = iteratorFn.call(node);\n      if (iterator) {\n        // We need to know how many total children are in this set, so that we\n        // can allocate enough id slots to acommodate them. So we must exhaust\n        // the iterator before we start recursively rendering the children.\n        // TODO: This is not great but I think it's inherent to the id\n        // generation algorithm.\n        let step = iterator.next();\n        // If there are not entries, we need to push an empty so we start by checking that.\n        if (!step.done) {\n          const children = [];\n          do {\n            children.push(step.value);\n            step = iterator.next();\n          } while (!step.done);\n          renderChildrenArray(request, task, children);\n          return;\n        }\n        return;\n      }\n    }\n\n    const childString = Object.prototype.toString.call(node);\n\n    throw new Error(\n      `Objects are not valid as a React child (found: ${\n        childString === '[object Object]'\n          ? 'object with keys {' + Object.keys(node).join(', ') + '}'\n          : childString\n      }). ` +\n        'If you meant to render a collection of children, use an array ' +\n        'instead.',\n    );\n  }\n\n  if (typeof node === 'string') {\n    const segment = task.blockedSegment;\n    segment.lastPushedText = pushTextInstance(\n      task.blockedSegment.chunks,\n      node,\n      request.responseState,\n      segment.lastPushedText,\n    );\n    return;\n  }\n\n  if (typeof node === 'number') {\n    const segment = task.blockedSegment;\n    segment.lastPushedText = pushTextInstance(\n      task.blockedSegment.chunks,\n      '' + node,\n      request.responseState,\n      segment.lastPushedText,\n    );\n    return;\n  }\n\n  if (__DEV__) {\n    if (typeof node === 'function') {\n      console.error(\n        'Functions are not valid as a React child. This may happen if ' +\n          'you return a Component instead of <Component /> from render. ' +\n          'Or maybe you meant to call this function rather than return it.',\n      );\n    }\n  }\n}\n\nfunction renderChildrenArray(request, task, children) {\n  const totalChildren = children.length;\n  for (let i = 0; i < totalChildren; i++) {\n    const prevTreeContext = task.treeContext;\n    task.treeContext = pushTreeContext(prevTreeContext, totalChildren, i);\n    try {\n      // We need to use the non-destructive form so that we can safely pop back\n      // up and render the sibling if something suspends.\n      renderNode(request, task, children[i]);\n    } finally {\n      task.treeContext = prevTreeContext;\n    }\n  }\n}\n\nfunction spawnNewSuspendedTask(\n  request: Request,\n  task: Task,\n  x: Promise<any>,\n): void {\n  // Something suspended, we'll need to create a new segment and resolve it later.\n  const segment = task.blockedSegment;\n  const insertionIndex = segment.chunks.length;\n  const newSegment = createPendingSegment(\n    request,\n    insertionIndex,\n    null,\n    segment.formatContext,\n    // Adopt the parent segment's leading text embed\n    segment.lastPushedText,\n    // Assume we are text embedded at the trailing edge\n    true,\n  );\n  segment.children.push(newSegment);\n  // Reset lastPushedText for current Segment since the new Segment \"consumed\" it\n  segment.lastPushedText = false;\n  const newTask = createTask(\n    request,\n    task.node,\n    task.blockedBoundary,\n    newSegment,\n    task.abortSet,\n    task.legacyContext,\n    task.context,\n    task.treeContext,\n  );\n  if (__DEV__) {\n    if (task.componentStack !== null) {\n      // We pop one task off the stack because the node that suspended will be tried again,\n      // which will add it back onto the stack.\n      newTask.componentStack = task.componentStack.parent;\n    }\n  }\n  const ping = newTask.ping;\n  x.then(ping, ping);\n}\n\n// This is a non-destructive form of rendering a node. If it suspends it spawns\n// a new task and restores the context of this task to what it was before.\nfunction renderNode(request: Request, task: Task, node: ReactNodeList): void {\n  // TODO: Store segment.children.length here and reset it in case something\n  // suspended partially through writing something.\n\n  // Snapshot the current context in case something throws to interrupt the\n  // process.\n  const previousFormatContext = task.blockedSegment.formatContext;\n  const previousLegacyContext = task.legacyContext;\n  const previousContext = task.context;\n  let previousComponentStack = null;\n  if (__DEV__) {\n    previousComponentStack = task.componentStack;\n  }\n  try {\n    return renderNodeDestructive(request, task, node);\n  } catch (x) {\n    resetHooksState();\n    if (typeof x === 'object' && x !== null && typeof x.then === 'function') {\n      spawnNewSuspendedTask(request, task, x);\n      // Restore the context. We assume that this will be restored by the inner\n      // functions in case nothing throws so we don't use \"finally\" here.\n      task.blockedSegment.formatContext = previousFormatContext;\n      task.legacyContext = previousLegacyContext;\n      task.context = previousContext;\n      // Restore all active ReactContexts to what they were before.\n      switchContext(previousContext);\n      if (__DEV__) {\n        task.componentStack = previousComponentStack;\n      }\n      return;\n    } else {\n      // Restore the context. We assume that this will be restored by the inner\n      // functions in case nothing throws so we don't use \"finally\" here.\n      task.blockedSegment.formatContext = previousFormatContext;\n      task.legacyContext = previousLegacyContext;\n      task.context = previousContext;\n      // Restore all active ReactContexts to what they were before.\n      switchContext(previousContext);\n      if (__DEV__) {\n        task.componentStack = previousComponentStack;\n      }\n      // We assume that we don't need the correct context.\n      // Let's terminate the rest of the tree and don't render any siblings.\n      throw x;\n    }\n  }\n}\n\nfunction erroredTask(\n  request: Request,\n  boundary: Root | SuspenseBoundary,\n  segment: Segment,\n  error: mixed,\n) {\n  // Report the error to a global handler.\n  const errorDigest = logRecoverableError(request, error);\n  if (boundary === null) {\n    fatalError(request, error);\n  } else {\n    boundary.pendingTasks--;\n    if (!boundary.forceClientRender) {\n      boundary.forceClientRender = true;\n      boundary.errorDigest = errorDigest;\n      if (__DEV__) {\n        captureBoundaryErrorDetailsDev(boundary, error);\n      }\n\n      // Regardless of what happens next, this boundary won't be displayed,\n      // so we can flush it, if the parent already flushed.\n      if (boundary.parentFlushed) {\n        // We don't have a preference where in the queue this goes since it's likely\n        // to error on the client anyway. However, intentionally client-rendered\n        // boundaries should be flushed earlier so that they can start on the client.\n        // We reuse the same queue for errors.\n        request.clientRenderedBoundaries.push(boundary);\n      }\n    }\n  }\n\n  request.allPendingTasks--;\n  if (request.allPendingTasks === 0) {\n    const onAllReady = request.onAllReady;\n    onAllReady();\n  }\n}\n\nfunction abortTaskSoft(task: Task): void {\n  // This aborts task without aborting the parent boundary that it blocks.\n  // It's used for when we didn't need this task to complete the tree.\n  // If task was needed, then it should use abortTask instead.\n  const request: Request = this;\n  const boundary = task.blockedBoundary;\n  const segment = task.blockedSegment;\n  segment.status = ABORTED;\n  finishedTask(request, boundary, segment);\n}\n\nfunction abortTask(task: Task, request: Request, reason: mixed): void {\n  // This aborts the task and aborts the parent that it blocks, putting it into\n  // client rendered mode.\n  const boundary = task.blockedBoundary;\n  const segment = task.blockedSegment;\n  segment.status = ABORTED;\n\n  if (boundary === null) {\n    request.allPendingTasks--;\n    // We didn't complete the root so we have nothing to show. We can close\n    // the request;\n    if (request.status !== CLOSED) {\n      request.status = CLOSED;\n      if (request.destination !== null) {\n        close(request.destination);\n      }\n    }\n  } else {\n    boundary.pendingTasks--;\n\n    if (!boundary.forceClientRender) {\n      boundary.forceClientRender = true;\n      let error =\n        reason === undefined\n          ? new Error('The render was aborted by the server without a reason.')\n          : reason;\n      boundary.errorDigest = request.onError(error);\n      if (__DEV__) {\n        const errorPrefix =\n          'The server did not finish this Suspense boundary: ';\n        if (error && typeof error.message === 'string') {\n          error = errorPrefix + error.message;\n        } else {\n          // eslint-disable-next-line react-internal/safe-string-coercion\n          error = errorPrefix + String(error);\n        }\n        const previousTaskInDev = currentTaskInDEV;\n        currentTaskInDEV = task;\n        try {\n          captureBoundaryErrorDetailsDev(boundary, error);\n        } finally {\n          currentTaskInDEV = previousTaskInDev;\n        }\n      }\n      if (boundary.parentFlushed) {\n        request.clientRenderedBoundaries.push(boundary);\n      }\n    }\n\n    // If this boundary was still pending then we haven't already cancelled its fallbacks.\n    // We'll need to abort the fallbacks, which will also error that parent boundary.\n    boundary.fallbackAbortableTasks.forEach(fallbackTask =>\n      abortTask(fallbackTask, request, reason),\n    );\n    boundary.fallbackAbortableTasks.clear();\n\n    request.allPendingTasks--;\n    if (request.allPendingTasks === 0) {\n      const onAllReady = request.onAllReady;\n      onAllReady();\n    }\n  }\n}\n\nfunction queueCompletedSegment(\n  boundary: SuspenseBoundary,\n  segment: Segment,\n): void {\n  if (\n    segment.chunks.length === 0 &&\n    segment.children.length === 1 &&\n    segment.children[0].boundary === null\n  ) {\n    // This is an empty segment. There's nothing to write, so we can instead transfer the ID\n    // to the child. That way any existing references point to the child.\n    const childSegment = segment.children[0];\n    childSegment.id = segment.id;\n    childSegment.parentFlushed = true;\n    if (childSegment.status === COMPLETED) {\n      queueCompletedSegment(boundary, childSegment);\n    }\n  } else {\n    const completedSegments = boundary.completedSegments;\n    completedSegments.push(segment);\n  }\n}\n\nfunction finishedTask(\n  request: Request,\n  boundary: Root | SuspenseBoundary,\n  segment: Segment,\n) {\n  if (boundary === null) {\n    if (segment.parentFlushed) {\n      if (request.completedRootSegment !== null) {\n        throw new Error(\n          'There can only be one root segment. This is a bug in React.',\n        );\n      }\n\n      request.completedRootSegment = segment;\n    }\n    request.pendingRootTasks--;\n    if (request.pendingRootTasks === 0) {\n      // We have completed the shell so the shell can't error anymore.\n      request.onShellError = noop;\n      const onShellReady = request.onShellReady;\n      onShellReady();\n    }\n  } else {\n    boundary.pendingTasks--;\n    if (boundary.forceClientRender) {\n      // This already errored.\n    } else if (boundary.pendingTasks === 0) {\n      // This must have been the last segment we were waiting on. This boundary is now complete.\n      if (segment.parentFlushed) {\n        // Our parent segment already flushed, so we need to schedule this segment to be emitted.\n        // If it is a segment that was aborted, we'll write other content instead so we don't need\n        // to emit it.\n        if (segment.status === COMPLETED) {\n          queueCompletedSegment(boundary, segment);\n        }\n      }\n      if (boundary.parentFlushed) {\n        // The segment might be part of a segment that didn't flush yet, but if the boundary's\n        // parent flushed, we need to schedule the boundary to be emitted.\n        request.completedBoundaries.push(boundary);\n      }\n      // We can now cancel any pending task on the fallback since we won't need to show it anymore.\n      // This needs to happen after we read the parentFlushed flags because aborting can finish\n      // work which can trigger user code, which can start flushing, which can change those flags.\n      boundary.fallbackAbortableTasks.forEach(abortTaskSoft, request);\n      boundary.fallbackAbortableTasks.clear();\n    } else {\n      if (segment.parentFlushed) {\n        // Our parent already flushed, so we need to schedule this segment to be emitted.\n        // If it is a segment that was aborted, we'll write other content instead so we don't need\n        // to emit it.\n        if (segment.status === COMPLETED) {\n          queueCompletedSegment(boundary, segment);\n          const completedSegments = boundary.completedSegments;\n          if (completedSegments.length === 1) {\n            // This is the first time since we last flushed that we completed anything.\n            // We can schedule this boundary to emit its partially completed segments early\n            // in case the parent has already been flushed.\n            if (boundary.parentFlushed) {\n              request.partialBoundaries.push(boundary);\n            }\n          }\n        }\n      }\n    }\n  }\n\n  request.allPendingTasks--;\n  if (request.allPendingTasks === 0) {\n    // This needs to be called at the very end so that we can synchronously write the result\n    // in the callback if needed.\n    const onAllReady = request.onAllReady;\n    onAllReady();\n  }\n}\n\nfunction retryTask(request: Request, task: Task): void {\n  const segment = task.blockedSegment;\n  if (segment.status !== PENDING) {\n    // We completed this by other means before we had a chance to retry it.\n    return;\n  }\n  // We restore the context to what it was when we suspended.\n  // We don't restore it after we leave because it's likely that we'll end up\n  // needing a very similar context soon again.\n  switchContext(task.context);\n  let prevTaskInDEV = null;\n  if (__DEV__) {\n    prevTaskInDEV = currentTaskInDEV;\n    currentTaskInDEV = task;\n  }\n  try {\n    // We call the destructive form that mutates this task. That way if something\n    // suspends again, we can reuse the same task instead of spawning a new one.\n    renderNodeDestructive(request, task, task.node);\n    pushSegmentFinale(\n      segment.chunks,\n      request.responseState,\n      segment.lastPushedText,\n      segment.textEmbedded,\n    );\n\n    task.abortSet.delete(task);\n    segment.status = COMPLETED;\n    finishedTask(request, task.blockedBoundary, segment);\n  } catch (x) {\n    resetHooksState();\n    if (typeof x === 'object' && x !== null && typeof x.then === 'function') {\n      // Something suspended again, let's pick it back up later.\n      const ping = task.ping;\n      x.then(ping, ping);\n    } else {\n      task.abortSet.delete(task);\n      segment.status = ERRORED;\n      erroredTask(request, task.blockedBoundary, segment, x);\n    }\n  } finally {\n    if (__DEV__) {\n      currentTaskInDEV = prevTaskInDEV;\n    }\n  }\n}\n\nexport function performWork(request: Request): void {\n  if (request.status === CLOSED) {\n    return;\n  }\n  const prevContext = getActiveContext();\n  const prevDispatcher = ReactCurrentDispatcher.current;\n  ReactCurrentDispatcher.current = Dispatcher;\n  let prevGetCurrentStackImpl;\n  if (__DEV__) {\n    prevGetCurrentStackImpl = ReactDebugCurrentFrame.getCurrentStack;\n    ReactDebugCurrentFrame.getCurrentStack = getCurrentStackInDEV;\n  }\n  const prevResponseState = currentResponseState;\n  setCurrentResponseState(request.responseState);\n  try {\n    const pingedTasks = request.pingedTasks;\n    let i;\n    for (i = 0; i < pingedTasks.length; i++) {\n      const task = pingedTasks[i];\n      retryTask(request, task);\n    }\n    pingedTasks.splice(0, i);\n    if (request.destination !== null) {\n      flushCompletedQueues(request, request.destination);\n    }\n  } catch (error) {\n    logRecoverableError(request, error);\n    fatalError(request, error);\n  } finally {\n    setCurrentResponseState(prevResponseState);\n    ReactCurrentDispatcher.current = prevDispatcher;\n    if (__DEV__) {\n      ReactDebugCurrentFrame.getCurrentStack = prevGetCurrentStackImpl;\n    }\n    if (prevDispatcher === Dispatcher) {\n      // This means that we were in a reentrant work loop. This could happen\n      // in a renderer that supports synchronous work like renderToString,\n      // when it's called from within another renderer.\n      // Normally we don't bother switching the contexts to their root/default\n      // values when leaving because we'll likely need the same or similar\n      // context again. However, when we're inside a synchronous loop like this\n      // we'll to restore the context to what it was before returning.\n      switchContext(prevContext);\n    }\n  }\n}\n\nfunction flushSubtree(\n  request: Request,\n  destination: Destination,\n  segment: Segment,\n): boolean {\n  segment.parentFlushed = true;\n  switch (segment.status) {\n    case PENDING: {\n      // We're emitting a placeholder for this segment to be filled in later.\n      // Therefore we'll need to assign it an ID - to refer to it by.\n      const segmentID = (segment.id = request.nextSegmentId++);\n      // When this segment finally completes it won't be embedded in text since it will flush separately\n      segment.lastPushedText = false;\n      segment.textEmbedded = false;\n      return writePlaceholder(destination, request.responseState, segmentID);\n    }\n    case COMPLETED: {\n      segment.status = FLUSHED;\n      let r = true;\n      const chunks = segment.chunks;\n      let chunkIdx = 0;\n      const children = segment.children;\n      for (let childIdx = 0; childIdx < children.length; childIdx++) {\n        const nextChild = children[childIdx];\n        // Write all the chunks up until the next child.\n        for (; chunkIdx < nextChild.index; chunkIdx++) {\n          writeChunk(destination, chunks[chunkIdx]);\n        }\n        r = flushSegment(request, destination, nextChild);\n      }\n      // Finally just write all the remaining chunks\n      for (; chunkIdx < chunks.length - 1; chunkIdx++) {\n        writeChunk(destination, chunks[chunkIdx]);\n      }\n      if (chunkIdx < chunks.length) {\n        r = writeChunkAndReturn(destination, chunks[chunkIdx]);\n      }\n      return r;\n    }\n    default: {\n      throw new Error(\n        'Aborted, errored or already flushed boundaries should not be flushed again. This is a bug in React.',\n      );\n    }\n  }\n}\n\nfunction flushSegment(\n  request: Request,\n  destination,\n  segment: Segment,\n): boolean {\n  const boundary = segment.boundary;\n  if (boundary === null) {\n    // Not a suspense boundary.\n    return flushSubtree(request, destination, segment);\n  }\n  boundary.parentFlushed = true;\n  // This segment is a Suspense boundary. We need to decide whether to\n  // emit the content or the fallback now.\n  if (boundary.forceClientRender) {\n    // Emit a client rendered suspense boundary wrapper.\n    // We never queue the inner boundary so we'll never emit its content or partial segments.\n\n    writeStartClientRenderedSuspenseBoundary(\n      destination,\n      request.responseState,\n      boundary.errorDigest,\n      boundary.errorMessage,\n      boundary.errorComponentStack,\n    );\n    // Flush the fallback.\n    flushSubtree(request, destination, segment);\n\n    return writeEndClientRenderedSuspenseBoundary(\n      destination,\n      request.responseState,\n    );\n  } else if (boundary.pendingTasks > 0) {\n    // This boundary is still loading. Emit a pending suspense boundary wrapper.\n\n    // Assign an ID to refer to the future content by.\n    boundary.rootSegmentID = request.nextSegmentId++;\n    if (boundary.completedSegments.length > 0) {\n      // If this is at least partially complete, we can queue it to be partially emitted early.\n      request.partialBoundaries.push(boundary);\n    }\n\n    /// This is the first time we should have referenced this ID.\n    const id = (boundary.id = assignSuspenseBoundaryID(request.responseState));\n\n    writeStartPendingSuspenseBoundary(destination, request.responseState, id);\n\n    // Flush the fallback.\n    flushSubtree(request, destination, segment);\n\n    return writeEndPendingSuspenseBoundary(destination, request.responseState);\n  } else if (boundary.byteSize > request.progressiveChunkSize) {\n    // This boundary is large and will be emitted separately so that we can progressively show\n    // other content. We add it to the queue during the flush because we have to ensure that\n    // the parent flushes first so that there's something to inject it into.\n    // We also have to make sure that it's emitted into the queue in a deterministic slot.\n    // I.e. we can't insert it here when it completes.\n\n    // Assign an ID to refer to the future content by.\n    boundary.rootSegmentID = request.nextSegmentId++;\n\n    request.completedBoundaries.push(boundary);\n    // Emit a pending rendered suspense boundary wrapper.\n    writeStartPendingSuspenseBoundary(\n      destination,\n      request.responseState,\n      boundary.id,\n    );\n\n    // Flush the fallback.\n    flushSubtree(request, destination, segment);\n\n    return writeEndPendingSuspenseBoundary(destination, request.responseState);\n  } else {\n    // We can inline this boundary's content as a complete boundary.\n    writeStartCompletedSuspenseBoundary(destination, request.responseState);\n\n    const completedSegments = boundary.completedSegments;\n\n    if (completedSegments.length !== 1) {\n      throw new Error(\n        'A previously unvisited boundary must have exactly one root segment. This is a bug in React.',\n      );\n    }\n\n    const contentSegment = completedSegments[0];\n    flushSegment(request, destination, contentSegment);\n\n    return writeEndCompletedSuspenseBoundary(\n      destination,\n      request.responseState,\n    );\n  }\n}\n\nfunction flushClientRenderedBoundary(\n  request: Request,\n  destination: Destination,\n  boundary: SuspenseBoundary,\n): boolean {\n  return writeClientRenderBoundaryInstruction(\n    destination,\n    request.responseState,\n    boundary.id,\n    boundary.errorDigest,\n    boundary.errorMessage,\n    boundary.errorComponentStack,\n  );\n}\n\nfunction flushSegmentContainer(\n  request: Request,\n  destination: Destination,\n  segment: Segment,\n): boolean {\n  writeStartSegment(\n    destination,\n    request.responseState,\n    segment.formatContext,\n    segment.id,\n  );\n  flushSegment(request, destination, segment);\n  return writeEndSegment(destination, segment.formatContext);\n}\n\nfunction flushCompletedBoundary(\n  request: Request,\n  destination: Destination,\n  boundary: SuspenseBoundary,\n): boolean {\n  const completedSegments = boundary.completedSegments;\n  let i = 0;\n  for (; i < completedSegments.length; i++) {\n    const segment = completedSegments[i];\n    flushPartiallyCompletedSegment(request, destination, boundary, segment);\n  }\n  completedSegments.length = 0;\n\n  return writeCompletedBoundaryInstruction(\n    destination,\n    request.responseState,\n    boundary.id,\n    boundary.rootSegmentID,\n  );\n}\n\nfunction flushPartialBoundary(\n  request: Request,\n  destination: Destination,\n  boundary: SuspenseBoundary,\n): boolean {\n  const completedSegments = boundary.completedSegments;\n  let i = 0;\n  for (; i < completedSegments.length; i++) {\n    const segment = completedSegments[i];\n    if (\n      !flushPartiallyCompletedSegment(request, destination, boundary, segment)\n    ) {\n      i++;\n      completedSegments.splice(0, i);\n      // Only write as much as the buffer wants. Something higher priority\n      // might want to write later.\n      return false;\n    }\n  }\n  completedSegments.splice(0, i);\n  return true;\n}\n\nfunction flushPartiallyCompletedSegment(\n  request: Request,\n  destination: Destination,\n  boundary: SuspenseBoundary,\n  segment: Segment,\n): boolean {\n  if (segment.status === FLUSHED) {\n    // We've already flushed this inline.\n    return true;\n  }\n\n  const segmentID = segment.id;\n  if (segmentID === -1) {\n    // This segment wasn't previously referred to. This happens at the root of\n    // a boundary. We make kind of a leap here and assume this is the root.\n    const rootSegmentID = (segment.id = boundary.rootSegmentID);\n\n    if (rootSegmentID === -1) {\n      throw new Error(\n        'A root segment ID must have been assigned by now. This is a bug in React.',\n      );\n    }\n\n    return flushSegmentContainer(request, destination, segment);\n  } else {\n    flushSegmentContainer(request, destination, segment);\n    return writeCompletedSegmentInstruction(\n      destination,\n      request.responseState,\n      segmentID,\n    );\n  }\n}\n\nfunction flushCompletedQueues(\n  request: Request,\n  destination: Destination,\n): void {\n  beginWriting(destination);\n  try {\n    // The structure of this is to go through each queue one by one and write\n    // until the sink tells us to stop. When we should stop, we still finish writing\n    // that item fully and then yield. At that point we remove the already completed\n    // items up until the point we completed them.\n\n    // TODO: Emit preloading.\n\n    // TODO: It's kind of unfortunate to keep checking this array after we've already\n    // emitted the root.\n    const completedRootSegment = request.completedRootSegment;\n    if (completedRootSegment !== null && request.pendingRootTasks === 0) {\n      flushSegment(request, destination, completedRootSegment);\n      request.completedRootSegment = null;\n      writeCompletedRoot(destination, request.responseState);\n    }\n\n    // We emit client rendering instructions for already emitted boundaries first.\n    // This is so that we can signal to the client to start client rendering them as\n    // soon as possible.\n    const clientRenderedBoundaries = request.clientRenderedBoundaries;\n    let i;\n    for (i = 0; i < clientRenderedBoundaries.length; i++) {\n      const boundary = clientRenderedBoundaries[i];\n      if (!flushClientRenderedBoundary(request, destination, boundary)) {\n        request.destination = null;\n        i++;\n        clientRenderedBoundaries.splice(0, i);\n        return;\n      }\n    }\n    clientRenderedBoundaries.splice(0, i);\n\n    // Next we emit any complete boundaries. It's better to favor boundaries\n    // that are completely done since we can actually show them, than it is to emit\n    // any individual segments from a partially complete boundary.\n    const completedBoundaries = request.completedBoundaries;\n    for (i = 0; i < completedBoundaries.length; i++) {\n      const boundary = completedBoundaries[i];\n      if (!flushCompletedBoundary(request, destination, boundary)) {\n        request.destination = null;\n        i++;\n        completedBoundaries.splice(0, i);\n        return;\n      }\n    }\n    completedBoundaries.splice(0, i);\n\n    // Allow anything written so far to flush to the underlying sink before\n    // we continue with lower priorities.\n    completeWriting(destination);\n    beginWriting(destination);\n\n    // TODO: Here we'll emit data used by hydration.\n\n    // Next we emit any segments of any boundaries that are partially complete\n    // but not deeply complete.\n    const partialBoundaries = request.partialBoundaries;\n    for (i = 0; i < partialBoundaries.length; i++) {\n      const boundary = partialBoundaries[i];\n      if (!flushPartialBoundary(request, destination, boundary)) {\n        request.destination = null;\n        i++;\n        partialBoundaries.splice(0, i);\n        return;\n      }\n    }\n    partialBoundaries.splice(0, i);\n\n    // Next we check the completed boundaries again. This may have had\n    // boundaries added to it in case they were too larged to be inlined.\n    // New ones might be added in this loop.\n    const largeBoundaries = request.completedBoundaries;\n    for (i = 0; i < largeBoundaries.length; i++) {\n      const boundary = largeBoundaries[i];\n      if (!flushCompletedBoundary(request, destination, boundary)) {\n        request.destination = null;\n        i++;\n        largeBoundaries.splice(0, i);\n        return;\n      }\n    }\n    largeBoundaries.splice(0, i);\n  } finally {\n    completeWriting(destination);\n    flushBuffered(destination);\n    if (\n      request.allPendingTasks === 0 &&\n      request.pingedTasks.length === 0 &&\n      request.clientRenderedBoundaries.length === 0 &&\n      request.completedBoundaries.length === 0\n      // We don't need to check any partially completed segments because\n      // either they have pending task or they're complete.\n    ) {\n      if (__DEV__) {\n        if (request.abortableTasks.size !== 0) {\n          console.error(\n            'There was still abortable task at the root when we closed. This is a bug in React.',\n          );\n        }\n      }\n      // We're done.\n      close(destination);\n    }\n  }\n}\n\nexport function startWork(request: Request): void {\n  scheduleWork(() => performWork(request));\n}\n\nexport function startFlowing(request: Request, destination: Destination): void {\n  if (request.status === CLOSING) {\n    request.status = CLOSED;\n    closeWithError(destination, request.fatalError);\n    return;\n  }\n  if (request.status === CLOSED) {\n    return;\n  }\n  if (request.destination !== null) {\n    // We're already flowing.\n    return;\n  }\n  request.destination = destination;\n  try {\n    flushCompletedQueues(request, destination);\n  } catch (error) {\n    logRecoverableError(request, error);\n    fatalError(request, error);\n  }\n}\n\n// This is called to early terminate a request. It puts all pending boundaries in client rendered state.\nexport function abort(request: Request, reason: mixed): void {\n  try {\n    const abortableTasks = request.abortableTasks;\n    abortableTasks.forEach(task => abortTask(task, request, reason));\n    abortableTasks.clear();\n    if (request.destination !== null) {\n      flushCompletedQueues(request, request.destination);\n    }\n  } catch (error) {\n    logRecoverableError(request, error);\n    fatalError(request, error);\n  }\n}\n"],"names":["scheduleWork","$$$hostConfig","beginWriting","writeChunk","writeChunkAndReturn","completeWriting","flushBuffered","close","closeWithError","stringToChunk","stringToPrecomputedChunk","getChildFormatContext","UNINITIALIZED_SUSPENSE_BOUNDARY_ID","assignSuspenseBoundaryID","makeId","pushTextInstance","pushStartInstance","pushEndInstance","pushStartCompletedSuspenseBoundary","pushEndCompletedSuspenseBoundary","pushSegmentFinale","writeCompletedRoot","writePlaceholder","writeStartCompletedSuspenseBoundary","writeStartPendingSuspenseBoundary","writeStartClientRenderedSuspenseBoundary","writeEndCompletedSuspenseBoundary","writeEndPendingSuspenseBoundary","writeEndClientRenderedSuspenseBoundary","writeStartSegment","writeEndSegment","writeCompletedSegmentInstruction","writeCompletedBoundaryInstruction","writeClientRenderBoundaryInstruction","assign","Object","REACT_ELEMENT_TYPE","Symbol","for","REACT_PORTAL_TYPE","REACT_FRAGMENT_TYPE","REACT_STRICT_MODE_TYPE","REACT_PROFILER_TYPE","REACT_PROVIDER_TYPE","REACT_CONTEXT_TYPE","REACT_SERVER_CONTEXT_TYPE","REACT_FORWARD_REF_TYPE","REACT_SUSPENSE_TYPE","REACT_SUSPENSE_LIST_TYPE","REACT_MEMO_TYPE","REACT_LAZY_TYPE","REACT_SCOPE_TYPE","REACT_DEBUG_TRACING_MODE_TYPE","REACT_LEGACY_HIDDEN_TYPE","REACT_CACHE_TYPE","REACT_SERVER_CONTEXT_DEFAULT_VALUE_NOT_LOADED","MAYBE_ITERATOR_SYMBOL","iterator","FAUX_ITERATOR_SYMBOL","getIteratorFn","maybeIterable","maybeIterator","getWrappedName","outerType","innerType","wrapperName","displayName","functionName","name","getContextName","type","getComponentNameFromType","$$typeof","context","provider","_context","render","outerName","lazyComponent","payload","_payload","init","_init","x","context2","_globalName","ReactSharedInternals","React","ReactCurrentDispatcher","ReactDebugCurrentFrame","emptyContextObject","getMaskedContext","unmaskedContext","contextTypes","key","processChildContext","instance","parentContext","childContextTypes","getChildContext","childContext","contextKey","Error","rootContextSnapshot","currentActiveSnapshot","popNode","prev","_currentValue2","parentValue","pushNode","next","value","popToNearestCommonAncestor","parentPrev","parent","parentNext","popAllPrevious","pushAllNext","popPreviousToCommonLevel","depth","popNextToCommonLevel","switchContext","newSnapshot","pushProvider","nextValue","prevValue","prevNode","newNode","popProvider","prevSnapshot","_defaultValue","getActiveContext","readContext","isPrimaryRenderer","get","_reactInternals","set","isArrayImpl","Array","isArray","a","classComponentUpdater","isMounted","inst","enqueueSetState","callback","internals","getInstance","queue","push","enqueueReplaceState","replace","enqueueForceUpdate","applyDerivedStateFromProps","ctor","getDerivedStateFromProps","prevState","nextProps","partialState","newState","undefined","constructClassInstance","props","maskedLegacyContext","contextType","callComponentWillMount","oldState","state","componentWillMount","UNSAFE_componentWillMount","processUpdateQueue","internalInstance","length","oldQueue","oldReplace","nextState","dontMutate","i","partial","call","mountClassInstance","newProps","initialState","updater","setInstance","getSnapshotBeforeUpdate","emptyTreeContext","id","overflow","getTreeId","idWithLeadingBit","getLeadingBit","toString","pushTreeContext","baseContext","totalChildren","index","baseIdWithLeadingBit","baseOverflow","baseLength","getBitLength","baseId","slot","numberOfOverflowBits","newOverflowBits","newOverflow","restOfBaseId","restOfBaseLength","restOfLength","restOfNewBits","newBits","number","clz32","Math","clz32Fallback","log","LN2","asUint","is","y","objectIs","currentlyRenderingComponent","currentlyRenderingTask","firstWorkInProgressHook","workInProgressHook","isReRender","didScheduleRenderPhaseUpdate","localIdCounter","renderPhaseUpdates","numberOfReRenders","RE_RENDER_LIMIT","resolveCurrentlyRenderingComponent","areHookInputsEqual","nextDeps","prevDeps","createHook","memoizedState","createWorkInProgressHook","prepareToUseHooks","task","componentIdentity","finishHooks","Component","children","refOrContext","resetHooksState","checkDidRenderIdHook","didRenderIdHook","getCacheForType","resourceType","readContextImpl","useContext","basicStateReducer","action","useState","useReducer","reducer","initialArg","dispatch","firstRenderPhaseUpdate","delete","update","last","dispatchAction","bind","useMemo","nextCreate","deps","useRef","initialValue","previousRef","ref","current","useLayoutEffect","create","inputs","Map","lastRenderPhaseUpdate","useCallback","useMutableSource","source","getSnapshot","subscribe","_source","useSyncExternalStore","getServerSnapshot","useDeferredValue","unsupportedStartTransition","useTransition","useId","treeId","treeContext","responseState","currentResponseState","localId","unsupportedRefresh","useCacheRefresh","noop","Dispatcher","useInsertionEffect","useImperativeHandle","useEffect","useDebugValue","setCurrentResponseState","PENDING","COMPLETED","FLUSHED","ABORTED","ERRORED","OPEN","CLOSING","CLOSED","DEFAULT_PROGRESSIVE_CHUNK_SIZE","defaultErrorHandler","error","console","createRequest","rootFormatContext","progressiveChunkSize","onError","onAllReady","onShellReady","onShellError","onFatalError","pingedTasks","abortSet","Set","request","destination","status","fatalError","nextSegmentId","allPendingTasks","pendingRootTasks","completedRootSegment","abortableTasks","clientRenderedBoundaries","completedBoundaries","partialBoundaries","rootSegment","createPendingSegment","parentFlushed","rootTask","createTask","pingTask","performWork","createSuspenseBoundary","fallbackAbortableTasks","rootSegmentID","pendingTasks","forceClientRender","completedSegments","byteSize","errorDigest","node","blockedBoundary","blockedSegment","legacyContext","ping","add","boundary","formatContext","lastPushedText","textEmbedded","chunks","pushFunctionComponentStackInDEV","popComponentStackInDEV","logRecoverableError","renderSuspenseBoundary","pushBuiltInComponentStackInDEV","parentBoundary","parentSegment","fallback","content","fallbackAbortSet","newBoundary","insertionIndex","boundarySegment","contentRootSegment","renderNode","queueCompletedSegment","suspendedFallbackTask","renderHostElement","segment","prevContext","shouldConstruct","prototype","isReactComponent","renderWithHooks","secondArg","result","finishClassComponent","nextChildren","previousContext","mergedContext","renderNodeDestructive","renderClassComponent","pushClassComponentStackInDEV","maskedContext","renderIndeterminateComponent","hasId","prevTreeContext","resolveDefaultProps","baseProps","defaultProps","propName","renderForwardRef","renderMemo","resolvedProps","renderElement","renderContextConsumer","newValue","newChildren","renderContextProvider","renderLazyComponent","info","renderNodeDestructiveImpl","element","lazyNode","resolvedNode","renderChildrenArray","iteratorFn","step","done","childString","keys","join","spawnNewSuspendedTask","newSegment","newTask","then","previousFormatContext","previousLegacyContext","erroredTask","abortTaskSoft","finishedTask","abortTask","reason","forEach","fallbackTask","clear","childSegment","retryTask","prevDispatcher","prevResponseState","splice","flushCompletedQueues","flushSubtree","segmentID","r","chunkIdx","childIdx","nextChild","flushSegment","errorMessage","errorComponentStack","contentSegment","flushClientRenderedBoundary","flushSegmentContainer","flushCompletedBoundary","flushPartiallyCompletedSegment","flushPartialBoundary","largeBoundaries","startWork","startFlowing","abort"],"mappings":"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"}