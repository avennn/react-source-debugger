{"version":3,"file":"react-noop-renderer-server.development.js","sources":["../../../../packages/react-noop-renderer/src/ReactNoopServer.js"],"sourcesContent":["/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\n/**\n * This is a renderer of React that doesn't have a render target output.\n * It is useful to demonstrate the internals of the reconciler in isolation\n * and for testing semantics of reconciliation separate from the host\n * environment.\n */\n\nimport type {ReactNodeList} from 'shared/ReactTypes';\n\nimport ReactFizzServer from 'react-server';\n\ntype Instance = {|\n  type: string,\n  children: Array<Instance | TextInstance | SuspenseInstance>,\n  prop: any,\n  hidden: boolean,\n|};\n\ntype TextInstance = {|\n  text: string,\n  hidden: boolean,\n|};\n\ntype SuspenseInstance = {|\n  state: 'pending' | 'complete' | 'client-render',\n  children: Array<Instance | TextInstance | SuspenseInstance>,\n|};\n\ntype Placeholder = {\n  parent: Instance | SuspenseInstance,\n  index: number,\n};\n\ntype Segment = {\n  children: null | Instance | TextInstance | SuspenseInstance,\n};\n\ntype Destination = {\n  root: null | Instance | TextInstance | SuspenseInstance,\n  placeholders: Map<number, Placeholder>,\n  segments: Map<number, Segment>,\n  stack: Array<Segment | Instance | SuspenseInstance>,\n};\n\nconst POP = Buffer.from('/', 'utf8');\n\nfunction write(destination: Destination, buffer: Uint8Array): void {\n  const stack = destination.stack;\n  if (buffer === POP) {\n    stack.pop();\n    return;\n  }\n  // We assume one chunk is one instance.\n  const instance = JSON.parse(Buffer.from((buffer: any)).toString('utf8'));\n  if (stack.length === 0) {\n    destination.root = instance;\n  } else {\n    const parent = stack[stack.length - 1];\n    parent.children.push(instance);\n  }\n  stack.push(instance);\n}\n\nconst ReactNoopServer = ReactFizzServer({\n  scheduleWork(callback: () => void) {\n    callback();\n  },\n  beginWriting(destination: Destination): void {},\n  writeChunk(destination: Destination, buffer: Uint8Array): void {\n    write(destination, buffer);\n  },\n  writeChunkAndReturn(destination: Destination, buffer: Uint8Array): boolean {\n    write(destination, buffer);\n    return true;\n  },\n  completeWriting(destination: Destination): void {},\n  close(destination: Destination): void {},\n  closeWithError(destination: Destination, error: mixed): void {},\n  flushBuffered(destination: Destination): void {},\n\n  UNINITIALIZED_SUSPENSE_BOUNDARY_ID: null,\n\n  assignSuspenseBoundaryID(): SuspenseInstance {\n    // The ID is a pointer to the boundary itself.\n    return {state: 'pending', children: []};\n  },\n\n  getChildFormatContext(): null {\n    return null;\n  },\n\n  pushTextInstance(\n    target: Array<Uint8Array>,\n    text: string,\n    responseState: ResponseState,\n    textEmbedded: boolean,\n  ): boolean {\n    const textInstance: TextInstance = {\n      text,\n      hidden: false,\n    };\n    target.push(Buffer.from(JSON.stringify(textInstance), 'utf8'), POP);\n    return false;\n  },\n  pushStartInstance(\n    target: Array<Uint8Array>,\n    type: string,\n    props: Object,\n  ): ReactNodeList {\n    const instance: Instance = {\n      type: type,\n      children: [],\n      prop: props.prop,\n      hidden: false,\n    };\n    target.push(Buffer.from(JSON.stringify(instance), 'utf8'));\n    return props.children;\n  },\n\n  pushEndInstance(\n    target: Array<Uint8Array>,\n    type: string,\n    props: Object,\n  ): void {\n    target.push(POP);\n  },\n\n  // This is a noop in ReactNoop\n  pushSegmentFinale(\n    target: Array<Uint8Array>,\n    responseState: ResponseState,\n    lastPushedText: boolean,\n    textEmbedded: boolean,\n  ): void {},\n\n  writeCompletedRoot(\n    destination: Destination,\n    responseState: ResponseState,\n  ): boolean {\n    return true;\n  },\n\n  writePlaceholder(\n    destination: Destination,\n    responseState: ResponseState,\n    id: number,\n  ): boolean {\n    const parent = destination.stack[destination.stack.length - 1];\n    destination.placeholders.set(id, {\n      parent: parent,\n      index: parent.children.length,\n    });\n  },\n\n  writeStartCompletedSuspenseBoundary(\n    destination: Destination,\n    responseState: ResponseState,\n    suspenseInstance: SuspenseInstance,\n  ): boolean {\n    suspenseInstance.state = 'complete';\n    const parent = destination.stack[destination.stack.length - 1];\n    parent.children.push(suspenseInstance);\n    destination.stack.push(suspenseInstance);\n  },\n  writeStartPendingSuspenseBoundary(\n    destination: Destination,\n    responseState: ResponseState,\n    suspenseInstance: SuspenseInstance,\n  ): boolean {\n    suspenseInstance.state = 'pending';\n    const parent = destination.stack[destination.stack.length - 1];\n    parent.children.push(suspenseInstance);\n    destination.stack.push(suspenseInstance);\n  },\n  writeStartClientRenderedSuspenseBoundary(\n    destination: Destination,\n    responseState: ResponseState,\n    suspenseInstance: SuspenseInstance,\n  ): boolean {\n    suspenseInstance.state = 'client-render';\n    const parent = destination.stack[destination.stack.length - 1];\n    parent.children.push(suspenseInstance);\n    destination.stack.push(suspenseInstance);\n  },\n  writeEndCompletedSuspenseBoundary(destination: Destination): boolean {\n    destination.stack.pop();\n  },\n  writeEndPendingSuspenseBoundary(destination: Destination): boolean {\n    destination.stack.pop();\n  },\n  writeEndClientRenderedSuspenseBoundary(destination: Destination): boolean {\n    destination.stack.pop();\n  },\n\n  writeStartSegment(\n    destination: Destination,\n    responseState: ResponseState,\n    formatContext: null,\n    id: number,\n  ): boolean {\n    const segment = {\n      children: [],\n    };\n    destination.segments.set(id, segment);\n    if (destination.stack.length > 0) {\n      throw new Error('Segments are only expected at the root of the stack.');\n    }\n    destination.stack.push(segment);\n  },\n  writeEndSegment(destination: Destination, formatContext: null): boolean {\n    destination.stack.pop();\n  },\n\n  writeCompletedSegmentInstruction(\n    destination: Destination,\n    responseState: ResponseState,\n    contentSegmentID: number,\n  ): boolean {\n    const segment = destination.segments.get(contentSegmentID);\n    if (!segment) {\n      throw new Error('Missing segment.');\n    }\n    const placeholder = destination.placeholders.get(contentSegmentID);\n    if (!placeholder) {\n      throw new Error('Missing placeholder.');\n    }\n    placeholder.parent.children.splice(\n      placeholder.index,\n      0,\n      ...segment.children,\n    );\n  },\n\n  writeCompletedBoundaryInstruction(\n    destination: Destination,\n    responseState: ResponseState,\n    boundary: SuspenseInstance,\n    contentSegmentID: number,\n  ): boolean {\n    const segment = destination.segments.get(contentSegmentID);\n    if (!segment) {\n      throw new Error('Missing segment.');\n    }\n    boundary.children = segment.children;\n    boundary.state = 'complete';\n  },\n\n  writeClientRenderBoundaryInstruction(\n    destination: Destination,\n    responseState: ResponseState,\n    boundary: SuspenseInstance,\n  ): boolean {\n    boundary.status = 'client-render';\n  },\n});\n\ntype Options = {\n  progressiveChunkSize?: number,\n  onShellReady?: () => void,\n  onAllReady?: () => void,\n  onError?: (error: mixed) => ?string,\n};\n\nfunction render(children: React$Element<any>, options?: Options): Destination {\n  const destination: Destination = {\n    root: null,\n    placeholders: new Map(),\n    segments: new Map(),\n    stack: [],\n    abort() {\n      ReactNoopServer.abort(request);\n    },\n  };\n  const request = ReactNoopServer.createRequest(\n    children,\n    null,\n    null,\n    options ? options.progressiveChunkSize : undefined,\n    options ? options.onError : undefined,\n    options ? options.onAllReady : undefined,\n    options ? options.onShellReady : undefined,\n  );\n  ReactNoopServer.startWork(request);\n  ReactNoopServer.startFlowing(request, destination);\n  return destination;\n}\n\nexport {render};\n"],"names":["POP","Buffer","from","write","destination","buffer","stack","pop","instance","JSON","parse","toString","length","root","parent","children","push","ReactNoopServer","ReactFizzServer","scheduleWork","callback","beginWriting","writeChunk","writeChunkAndReturn","completeWriting","close","closeWithError","error","flushBuffered","UNINITIALIZED_SUSPENSE_BOUNDARY_ID","assignSuspenseBoundaryID","state","getChildFormatContext","pushTextInstance","target","text","responseState","textEmbedded","textInstance","hidden","stringify","pushStartInstance","type","props","prop","pushEndInstance","pushSegmentFinale","lastPushedText","writeCompletedRoot","writePlaceholder","id","placeholders","set","index","writeStartCompletedSuspenseBoundary","suspenseInstance","writeStartPendingSuspenseBoundary","writeStartClientRenderedSuspenseBoundary","writeEndCompletedSuspenseBoundary","writeEndPendingSuspenseBoundary","writeEndClientRenderedSuspenseBoundary","writeStartSegment","formatContext","segment","segments","Error","writeEndSegment","writeCompletedSegmentInstruction","contentSegmentID","get","placeholder","splice","writeCompletedBoundaryInstruction","boundary","writeClientRenderBoundaryInstruction","status","render","options","Map","abort","request","createRequest","progressiveChunkSize","undefined","onError","onAllReady","onShellReady","startWork","startFlowing"],"mappings":"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"}