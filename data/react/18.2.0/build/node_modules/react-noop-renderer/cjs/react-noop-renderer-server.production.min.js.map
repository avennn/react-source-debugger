{"version":3,"file":"react-noop-renderer-server.production.min.js","sources":["../../../../packages/react-noop-renderer/src/ReactNoopServer.js"],"sourcesContent":["/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\n/**\n * This is a renderer of React that doesn't have a render target output.\n * It is useful to demonstrate the internals of the reconciler in isolation\n * and for testing semantics of reconciliation separate from the host\n * environment.\n */\n\nimport type {ReactNodeList} from 'shared/ReactTypes';\n\nimport ReactFizzServer from 'react-server';\n\ntype Instance = {|\n  type: string,\n  children: Array<Instance | TextInstance | SuspenseInstance>,\n  prop: any,\n  hidden: boolean,\n|};\n\ntype TextInstance = {|\n  text: string,\n  hidden: boolean,\n|};\n\ntype SuspenseInstance = {|\n  state: 'pending' | 'complete' | 'client-render',\n  children: Array<Instance | TextInstance | SuspenseInstance>,\n|};\n\ntype Placeholder = {\n  parent: Instance | SuspenseInstance,\n  index: number,\n};\n\ntype Segment = {\n  children: null | Instance | TextInstance | SuspenseInstance,\n};\n\ntype Destination = {\n  root: null | Instance | TextInstance | SuspenseInstance,\n  placeholders: Map<number, Placeholder>,\n  segments: Map<number, Segment>,\n  stack: Array<Segment | Instance | SuspenseInstance>,\n};\n\nconst POP = Buffer.from('/', 'utf8');\n\nfunction write(destination: Destination, buffer: Uint8Array): void {\n  const stack = destination.stack;\n  if (buffer === POP) {\n    stack.pop();\n    return;\n  }\n  // We assume one chunk is one instance.\n  const instance = JSON.parse(Buffer.from((buffer: any)).toString('utf8'));\n  if (stack.length === 0) {\n    destination.root = instance;\n  } else {\n    const parent = stack[stack.length - 1];\n    parent.children.push(instance);\n  }\n  stack.push(instance);\n}\n\nconst ReactNoopServer = ReactFizzServer({\n  scheduleWork(callback: () => void) {\n    callback();\n  },\n  beginWriting(destination: Destination): void {},\n  writeChunk(destination: Destination, buffer: Uint8Array): void {\n    write(destination, buffer);\n  },\n  writeChunkAndReturn(destination: Destination, buffer: Uint8Array): boolean {\n    write(destination, buffer);\n    return true;\n  },\n  completeWriting(destination: Destination): void {},\n  close(destination: Destination): void {},\n  closeWithError(destination: Destination, error: mixed): void {},\n  flushBuffered(destination: Destination): void {},\n\n  UNINITIALIZED_SUSPENSE_BOUNDARY_ID: null,\n\n  assignSuspenseBoundaryID(): SuspenseInstance {\n    // The ID is a pointer to the boundary itself.\n    return {state: 'pending', children: []};\n  },\n\n  getChildFormatContext(): null {\n    return null;\n  },\n\n  pushTextInstance(\n    target: Array<Uint8Array>,\n    text: string,\n    responseState: ResponseState,\n    textEmbedded: boolean,\n  ): boolean {\n    const textInstance: TextInstance = {\n      text,\n      hidden: false,\n    };\n    target.push(Buffer.from(JSON.stringify(textInstance), 'utf8'), POP);\n    return false;\n  },\n  pushStartInstance(\n    target: Array<Uint8Array>,\n    type: string,\n    props: Object,\n  ): ReactNodeList {\n    const instance: Instance = {\n      type: type,\n      children: [],\n      prop: props.prop,\n      hidden: false,\n    };\n    target.push(Buffer.from(JSON.stringify(instance), 'utf8'));\n    return props.children;\n  },\n\n  pushEndInstance(\n    target: Array<Uint8Array>,\n    type: string,\n    props: Object,\n  ): void {\n    target.push(POP);\n  },\n\n  // This is a noop in ReactNoop\n  pushSegmentFinale(\n    target: Array<Uint8Array>,\n    responseState: ResponseState,\n    lastPushedText: boolean,\n    textEmbedded: boolean,\n  ): void {},\n\n  writeCompletedRoot(\n    destination: Destination,\n    responseState: ResponseState,\n  ): boolean {\n    return true;\n  },\n\n  writePlaceholder(\n    destination: Destination,\n    responseState: ResponseState,\n    id: number,\n  ): boolean {\n    const parent = destination.stack[destination.stack.length - 1];\n    destination.placeholders.set(id, {\n      parent: parent,\n      index: parent.children.length,\n    });\n  },\n\n  writeStartCompletedSuspenseBoundary(\n    destination: Destination,\n    responseState: ResponseState,\n    suspenseInstance: SuspenseInstance,\n  ): boolean {\n    suspenseInstance.state = 'complete';\n    const parent = destination.stack[destination.stack.length - 1];\n    parent.children.push(suspenseInstance);\n    destination.stack.push(suspenseInstance);\n  },\n  writeStartPendingSuspenseBoundary(\n    destination: Destination,\n    responseState: ResponseState,\n    suspenseInstance: SuspenseInstance,\n  ): boolean {\n    suspenseInstance.state = 'pending';\n    const parent = destination.stack[destination.stack.length - 1];\n    parent.children.push(suspenseInstance);\n    destination.stack.push(suspenseInstance);\n  },\n  writeStartClientRenderedSuspenseBoundary(\n    destination: Destination,\n    responseState: ResponseState,\n    suspenseInstance: SuspenseInstance,\n  ): boolean {\n    suspenseInstance.state = 'client-render';\n    const parent = destination.stack[destination.stack.length - 1];\n    parent.children.push(suspenseInstance);\n    destination.stack.push(suspenseInstance);\n  },\n  writeEndCompletedSuspenseBoundary(destination: Destination): boolean {\n    destination.stack.pop();\n  },\n  writeEndPendingSuspenseBoundary(destination: Destination): boolean {\n    destination.stack.pop();\n  },\n  writeEndClientRenderedSuspenseBoundary(destination: Destination): boolean {\n    destination.stack.pop();\n  },\n\n  writeStartSegment(\n    destination: Destination,\n    responseState: ResponseState,\n    formatContext: null,\n    id: number,\n  ): boolean {\n    const segment = {\n      children: [],\n    };\n    destination.segments.set(id, segment);\n    if (destination.stack.length > 0) {\n      throw new Error('Segments are only expected at the root of the stack.');\n    }\n    destination.stack.push(segment);\n  },\n  writeEndSegment(destination: Destination, formatContext: null): boolean {\n    destination.stack.pop();\n  },\n\n  writeCompletedSegmentInstruction(\n    destination: Destination,\n    responseState: ResponseState,\n    contentSegmentID: number,\n  ): boolean {\n    const segment = destination.segments.get(contentSegmentID);\n    if (!segment) {\n      throw new Error('Missing segment.');\n    }\n    const placeholder = destination.placeholders.get(contentSegmentID);\n    if (!placeholder) {\n      throw new Error('Missing placeholder.');\n    }\n    placeholder.parent.children.splice(\n      placeholder.index,\n      0,\n      ...segment.children,\n    );\n  },\n\n  writeCompletedBoundaryInstruction(\n    destination: Destination,\n    responseState: ResponseState,\n    boundary: SuspenseInstance,\n    contentSegmentID: number,\n  ): boolean {\n    const segment = destination.segments.get(contentSegmentID);\n    if (!segment) {\n      throw new Error('Missing segment.');\n    }\n    boundary.children = segment.children;\n    boundary.state = 'complete';\n  },\n\n  writeClientRenderBoundaryInstruction(\n    destination: Destination,\n    responseState: ResponseState,\n    boundary: SuspenseInstance,\n  ): boolean {\n    boundary.status = 'client-render';\n  },\n});\n\ntype Options = {\n  progressiveChunkSize?: number,\n  onShellReady?: () => void,\n  onAllReady?: () => void,\n  onError?: (error: mixed) => ?string,\n};\n\nfunction render(children: React$Element<any>, options?: Options): Destination {\n  const destination: Destination = {\n    root: null,\n    placeholders: new Map(),\n    segments: new Map(),\n    stack: [],\n    abort() {\n      ReactNoopServer.abort(request);\n    },\n  };\n  const request = ReactNoopServer.createRequest(\n    children,\n    null,\n    null,\n    options ? options.progressiveChunkSize : undefined,\n    options ? options.onError : undefined,\n    options ? options.onAllReady : undefined,\n    options ? options.onShellReady : undefined,\n  );\n  ReactNoopServer.startWork(request);\n  ReactNoopServer.startFlowing(request, destination);\n  return destination;\n}\n\nexport {render};\n"],"names":["POP","Buffer","from","write","destination","buffer","stack","pop","instance","JSON","parse","toString","length","root","parent","children","push","ReactNoopServer","ReactFizzServer","scheduleWork","callback","beginWriting","writeChunk","writeChunkAndReturn","completeWriting","close","closeWithError","error","flushBuffered","UNINITIALIZED_SUSPENSE_BOUNDARY_ID","assignSuspenseBoundaryID","state","getChildFormatContext","pushTextInstance","target","text","responseState","textEmbedded","textInstance","hidden","stringify","pushStartInstance","type","props","prop","pushEndInstance","pushSegmentFinale","lastPushedText","writeCompletedRoot","writePlaceholder","id","placeholders","set","index","writeStartCompletedSuspenseBoundary","suspenseInstance","writeStartPendingSuspenseBoundary","writeStartClientRenderedSuspenseBoundary","writeEndCompletedSuspenseBoundary","writeEndPendingSuspenseBoundary","writeEndClientRenderedSuspenseBoundary","writeStartSegment","formatContext","segment","segments","Error","writeEndSegment","writeCompletedSegmentInstruction","contentSegmentID","get","placeholder","splice","writeCompletedBoundaryInstruction","boundary","writeClientRenderBoundaryInstruction","status","render","options","Map","abort","request","createRequest","progressiveChunkSize","undefined","onError","onAllReady","onShellReady","startWork","startFlowing"],"mappings":"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"}