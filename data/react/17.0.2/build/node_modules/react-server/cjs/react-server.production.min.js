'use strict';

// This is a host config that's used for the `react-server` package on npm.
// It is only used by third-party renderers.
//
// Its API lets you pass the host config as an argument.
// However, inside the `react-server` we treat host config as a module.
// This file is a shim between two worlds.
//
// It works because the `react-server` bundle is wrapped in something like:
//
// module.exports = function ($$$config) {
//   /* renderer code */
// }
//
// So `$$$config` looks like a global variable, but it's
// really an argument to a top-level wrapping function.
// eslint-disable-line no-undef
const scheduleWork = $$$hostConfig.scheduleWork;
const beginWriting = $$$hostConfig.beginWriting;
const writeChunk = $$$hostConfig.writeChunk;
const completeWriting = $$$hostConfig.completeWriting;
const flushBuffered = $$$hostConfig.flushBuffered;
const close = $$$hostConfig.close;
const convertStringToBuffer = $$$hostConfig.convertStringToBuffer;

// This is a host config that's used for the `react-server` package on npm.
// It is only used by third-party renderers.
//
// Its API lets you pass the host config as an argument.
// However, inside the `react-server` we treat host config as a module.
// This file is a shim between two worlds.
//
// It works because the `react-server` bundle is wrapped in something like:
//
// module.exports = function ($$$config) {
//   /* renderer code */
// }
//
// So `$$$config` looks like a global variable, but it's
// really an argument to a top-level wrapping function.
// eslint-disable-line no-undef
const formatChunkAsString = $$$hostConfig.formatChunkAsString;
const formatChunk = $$$hostConfig.formatChunk;

// ATTENTION
// When adding new symbols to this file,
// Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'
// The Symbol used to tag the ReactElement-like types. If there is no native Symbol
// nor polyfill, then a plain number is used for performance.
let REACT_ELEMENT_TYPE = 0xeac7;

if (typeof Symbol === 'function' && Symbol.for) {
  const symbolFor = Symbol.for;
  REACT_ELEMENT_TYPE = symbolFor('react.element');
}

function createRequest(children, destination) {
  return {
    destination,
    children,
    completedChunks: [],
    flowing: false
  };
}

function performWork(request) {
  const element = request.children;
  request.children = null;

  if (element && element.$$typeof !== REACT_ELEMENT_TYPE) {
    return;
  }

  const type = element.type;
  const props = element.props;

  if (typeof type !== 'string') {
    return;
  }

  request.completedChunks.push(formatChunk(type, props));

  if (request.flowing) {
    flushCompletedChunks(request);
  }

  flushBuffered(request.destination);
}

function flushCompletedChunks(request) {
  const destination = request.destination;
  const chunks = request.completedChunks;
  request.completedChunks = [];
  beginWriting(destination);

  try {
    for (let i = 0; i < chunks.length; i++) {
      const chunk = chunks[i];
      writeChunk(destination, chunk);
    }
  } finally {
    completeWriting(destination);
  }

  close(destination);
}

function startWork(request) {
  request.flowing = true;
  scheduleWork(() => performWork(request));
}
function startFlowing(request) {
  request.flowing = false;
  flushCompletedChunks(request);
}

exports.createRequest = createRequest;
exports.startFlowing = startFlowing;
exports.startWork = startWork;
//# sourceMappingURL=react-server.production.min.js.map
