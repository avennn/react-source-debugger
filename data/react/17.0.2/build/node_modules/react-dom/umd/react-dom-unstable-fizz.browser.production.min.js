(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
  typeof define === 'function' && define.amd ? define(['exports'], factory) :
  (global = global || self, factory(global.ReactDOMFizzServer = {}));
}(this, (function (exports) { 'use strict';

  function scheduleWork(callback) {
    callback();
  }
  function flushBuffered(destination) {// WHATWG Streams do not yet have a way to flush the underlying
    // transform streams. https://github.com/whatwg/streams/issues/960
  }
  function writeChunk(destination, buffer) {
    destination.enqueue(buffer);
    return destination.desiredSize > 0;
  }
  function close(destination) {
    destination.close();
  }
  const textEncoder = new TextEncoder();
  function convertStringToBuffer(content) {
    return textEncoder.encode(content);
  }

  function formatChunkAsString(type, props) {
    let str = '<' + type + '>';

    if (typeof props.children === 'string') {
      str += props.children;
    }

    str += '</' + type + '>';
    return str;
  }
  function formatChunk(type, props) {
    return convertStringToBuffer(formatChunkAsString(type, props));
  }

  // ATTENTION
  // When adding new symbols to this file,
  // Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'
  // The Symbol used to tag the ReactElement-like types. If there is no native Symbol
  // nor polyfill, then a plain number is used for performance.
  let REACT_ELEMENT_TYPE = 0xeac7;

  if (typeof Symbol === 'function' && Symbol.for) {
    const symbolFor = Symbol.for;
    REACT_ELEMENT_TYPE = symbolFor('react.element');
  }

  function createRequest(children, destination) {
    return {
      destination,
      children,
      completedChunks: [],
      flowing: false
    };
  }

  function performWork(request) {
    const element = request.children;
    request.children = null;

    if (element && element.$$typeof !== REACT_ELEMENT_TYPE) {
      return;
    }

    const type = element.type;
    const props = element.props;

    if (typeof type !== 'string') {
      return;
    }

    request.completedChunks.push(formatChunk(type, props));

    if (request.flowing) {
      flushCompletedChunks(request);
    }

    flushBuffered(request.destination);
  }

  function flushCompletedChunks(request) {
    const destination = request.destination;
    const chunks = request.completedChunks;
    request.completedChunks = [];

    try {
      for (let i = 0; i < chunks.length; i++) {
        const chunk = chunks[i];
        writeChunk(destination, chunk);
      }
    } finally {
    }

    close(destination);
  }

  function startWork(request) {
    request.flowing = true;
    scheduleWork(() => performWork(request));
  }
  function startFlowing(request) {
    request.flowing = false;
    flushCompletedChunks(request);
  }

  function renderToReadableStream(children) {
    let request;
    return new ReadableStream({
      start(controller) {
        request = createRequest(children, controller);
        startWork(request);
      },

      pull(controller) {
        startFlowing(request);
      },

      cancel(reason) {}

    });
  }

  exports.renderToReadableStream = renderToReadableStream;

})));
//# sourceMappingURL=react-dom-unstable-fizz.browser.production.min.js.map
