'use strict';

function scheduleWork(callback) {
  setImmediate(callback);
}
function flushBuffered(destination) {
  // If we don't have any more data to send right now.
  // Flush whatever is in the buffer to the wire.
  if (typeof destination.flush === 'function') {
    // http.createServer response have flush(), but it has a different meaning and
    // is deprecated in favor of flushHeaders(). Detect to avoid a warning.
    if (typeof destination.flushHeaders !== 'function') {
      // By convention the Zlib streams provide a flush function for this purpose.
      destination.flush();
    }
  }
}
function beginWriting(destination) {
  // Older Node streams like http.createServer don't have this.
  if (typeof destination.cork === 'function') {
    destination.cork();
  }
}
function writeChunk(destination, buffer) {
  const nodeBuffer = buffer; // close enough

  return destination.write(nodeBuffer);
}
function completeWriting(destination) {
  // Older Node streams like http.createServer don't have this.
  if (typeof destination.uncork === 'function') {
    destination.uncork();
  }
}
function close(destination) {
  destination.end();
}
function convertStringToBuffer(content) {
  return Buffer.from(content, 'utf8');
}

function formatChunkAsString(type, props) {
  let str = '<' + type + '>';

  if (typeof props.children === 'string') {
    str += props.children;
  }

  str += '</' + type + '>';
  return str;
}
function formatChunk(type, props) {
  return convertStringToBuffer(formatChunkAsString(type, props));
}

// ATTENTION
// When adding new symbols to this file,
// Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'
// The Symbol used to tag the ReactElement-like types. If there is no native Symbol
// nor polyfill, then a plain number is used for performance.
let REACT_ELEMENT_TYPE = 0xeac7;

if (typeof Symbol === 'function' && Symbol.for) {
  const symbolFor = Symbol.for;
  REACT_ELEMENT_TYPE = symbolFor('react.element');
}

function createRequest(children, destination) {
  return {
    destination,
    children,
    completedChunks: [],
    flowing: false
  };
}

function performWork(request) {
  const element = request.children;
  request.children = null;

  if (element && element.$$typeof !== REACT_ELEMENT_TYPE) {
    return;
  }

  const type = element.type;
  const props = element.props;

  if (typeof type !== 'string') {
    return;
  }

  request.completedChunks.push(formatChunk(type, props));

  if (request.flowing) {
    flushCompletedChunks(request);
  }

  flushBuffered(request.destination);
}

function flushCompletedChunks(request) {
  const destination = request.destination;
  const chunks = request.completedChunks;
  request.completedChunks = [];
  beginWriting(destination);

  try {
    for (let i = 0; i < chunks.length; i++) {
      const chunk = chunks[i];
      writeChunk(destination, chunk);
    }
  } finally {
    completeWriting(destination);
  }

  close(destination);
}

function startWork(request) {
  request.flowing = true;
  scheduleWork(() => performWork(request));
}
function startFlowing(request) {
  request.flowing = false;
  flushCompletedChunks(request);
}

function createDrainHandler(destination, request) {
  return () => startFlowing(request);
}

function pipeToNodeWritable(children, destination) {
  const request = createRequest(children, destination);
  destination.on('drain', createDrainHandler(destination, request));
  startWork(request);
}

exports.pipeToNodeWritable = pipeToNodeWritable;
//# sourceMappingURL=react-dom-unstable-fizz.node.production.min.js.map
