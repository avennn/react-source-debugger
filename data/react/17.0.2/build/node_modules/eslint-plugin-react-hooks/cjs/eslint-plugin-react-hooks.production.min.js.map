{"version":3,"file":"eslint-plugin-react-hooks.production.min.js","sources":["../../../../packages/eslint-plugin-react-hooks/src/RulesOfHooks.js","../../../../packages/eslint-plugin-react-hooks/src/ExhaustiveDeps.js","../../../../packages/eslint-plugin-react-hooks/src/index.js"],"sourcesContent":["/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n/* eslint-disable no-for-of-loops/no-for-of-loops */\n\n'use strict';\n\n/**\n * Catch all identifiers that begin with \"use\" followed by an uppercase Latin\n * character to exclude identifiers like \"user\".\n */\n\nfunction isHookName(s) {\n  return /^use[A-Z0-9].*$/.test(s);\n}\n\n/**\n * We consider hooks to be a hook name identifier or a member expression\n * containing a hook name.\n */\n\nfunction isHook(node) {\n  if (node.type === 'Identifier') {\n    return isHookName(node.name);\n  } else if (\n    node.type === 'MemberExpression' &&\n    !node.computed &&\n    isHook(node.property)\n  ) {\n    const obj = node.object;\n    const isPascalCaseNameSpace = /^[A-Z].*/;\n    return obj.type === 'Identifier' && isPascalCaseNameSpace.test(obj.name);\n  } else {\n    return false;\n  }\n}\n\n/**\n * Checks if the node is a React component name. React component names must\n * always start with a non-lowercase letter. So `MyComponent` or `_MyComponent`\n * are valid component names for instance.\n */\n\nfunction isComponentName(node) {\n  if (node.type === 'Identifier') {\n    return !/^[a-z]/.test(node.name);\n  } else {\n    return false;\n  }\n}\n\nfunction isReactFunction(node, functionName) {\n  return (\n    node.name === functionName ||\n    (node.type === 'MemberExpression' &&\n      node.object.name === 'React' &&\n      node.property.name === functionName)\n  );\n}\n\n/**\n * Checks if the node is a callback argument of forwardRef. This render function\n * should follow the rules of hooks.\n */\n\nfunction isForwardRefCallback(node) {\n  return !!(\n    node.parent &&\n    node.parent.callee &&\n    isReactFunction(node.parent.callee, 'forwardRef')\n  );\n}\n\n/**\n * Checks if the node is a callback argument of React.memo. This anonymous\n * functional component should follow the rules of hooks.\n */\n\nfunction isMemoCallback(node) {\n  return !!(\n    node.parent &&\n    node.parent.callee &&\n    isReactFunction(node.parent.callee, 'memo')\n  );\n}\n\nfunction isInsideComponentOrHook(node) {\n  while (node) {\n    const functionName = getFunctionName(node);\n    if (functionName) {\n      if (isComponentName(functionName) || isHook(functionName)) {\n        return true;\n      }\n    }\n    if (isForwardRefCallback(node) || isMemoCallback(node)) {\n      return true;\n    }\n    node = node.parent;\n  }\n  return false;\n}\n\nexport default {\n  meta: {\n    type: 'problem',\n    docs: {\n      description: 'enforces the Rules of Hooks',\n      category: 'Possible Errors',\n      recommended: true,\n      url: 'https://reactjs.org/docs/hooks-rules.html',\n    },\n  },\n  create(context) {\n    const codePathReactHooksMapStack = [];\n    const codePathSegmentStack = [];\n    return {\n      // Maintain code segment path stack as we traverse.\n      onCodePathSegmentStart: segment => codePathSegmentStack.push(segment),\n      onCodePathSegmentEnd: () => codePathSegmentStack.pop(),\n\n      // Maintain code path stack as we traverse.\n      onCodePathStart: () => codePathReactHooksMapStack.push(new Map()),\n\n      // Process our code path.\n      //\n      // Everything is ok if all React Hooks are both reachable from the initial\n      // segment and reachable from every final segment.\n      onCodePathEnd(codePath, codePathNode) {\n        const reactHooksMap = codePathReactHooksMapStack.pop();\n        if (reactHooksMap.size === 0) {\n          return;\n        }\n\n        // All of the segments which are cyclic are recorded in this set.\n        const cyclic = new Set();\n\n        /**\n         * Count the number of code paths from the start of the function to this\n         * segment. For example:\n         *\n         * ```js\n         * function MyComponent() {\n         *   if (condition) {\n         *     // Segment 1\n         *   } else {\n         *     // Segment 2\n         *   }\n         *   // Segment 3\n         * }\n         * ```\n         *\n         * Segments 1 and 2 have one path to the beginning of `MyComponent` and\n         * segment 3 has two paths to the beginning of `MyComponent` since we\n         * could have either taken the path of segment 1 or segment 2.\n         *\n         * Populates `cyclic` with cyclic segments.\n         */\n\n        function countPathsFromStart(segment, pathHistory) {\n          const {cache} = countPathsFromStart;\n          let paths = cache.get(segment.id);\n          const pathList = new Set(pathHistory);\n\n          // If `pathList` includes the current segment then we've found a cycle!\n          // We need to fill `cyclic` with all segments inside cycle\n          if (pathList.has(segment.id)) {\n            const pathArray = [...pathList];\n            const cyclicSegments = pathArray.slice(\n              pathArray.indexOf(segment.id) + 1,\n            );\n            for (const cyclicSegment of cyclicSegments) {\n              cyclic.add(cyclicSegment);\n            }\n\n            return 0;\n          }\n\n          // add the current segment to pathList\n          pathList.add(segment.id);\n\n          // We have a cached `paths`. Return it.\n          if (paths !== undefined) {\n            return paths;\n          }\n\n          if (codePath.thrownSegments.includes(segment)) {\n            paths = 0;\n          } else if (segment.prevSegments.length === 0) {\n            paths = 1;\n          } else {\n            paths = 0;\n            for (const prevSegment of segment.prevSegments) {\n              paths += countPathsFromStart(prevSegment, pathList);\n            }\n          }\n\n          // If our segment is reachable then there should be at least one path\n          // to it from the start of our code path.\n          if (segment.reachable && paths === 0) {\n            cache.delete(segment.id);\n          } else {\n            cache.set(segment.id, paths);\n          }\n\n          return paths;\n        }\n\n        /**\n         * Count the number of code paths from this segment to the end of the\n         * function. For example:\n         *\n         * ```js\n         * function MyComponent() {\n         *   // Segment 1\n         *   if (condition) {\n         *     // Segment 2\n         *   } else {\n         *     // Segment 3\n         *   }\n         * }\n         * ```\n         *\n         * Segments 2 and 3 have one path to the end of `MyComponent` and\n         * segment 1 has two paths to the end of `MyComponent` since we could\n         * either take the path of segment 1 or segment 2.\n         *\n         * Populates `cyclic` with cyclic segments.\n         */\n\n        function countPathsToEnd(segment, pathHistory) {\n          const {cache} = countPathsToEnd;\n          let paths = cache.get(segment.id);\n          const pathList = new Set(pathHistory);\n\n          // If `pathList` includes the current segment then we've found a cycle!\n          // We need to fill `cyclic` with all segments inside cycle\n          if (pathList.has(segment.id)) {\n            const pathArray = Array.from(pathList);\n            const cyclicSegments = pathArray.slice(\n              pathArray.indexOf(segment.id) + 1,\n            );\n            for (const cyclicSegment of cyclicSegments) {\n              cyclic.add(cyclicSegment);\n            }\n\n            return 0;\n          }\n\n          // add the current segment to pathList\n          pathList.add(segment.id);\n\n          // We have a cached `paths`. Return it.\n          if (paths !== undefined) {\n            return paths;\n          }\n\n          if (codePath.thrownSegments.includes(segment)) {\n            paths = 0;\n          } else if (segment.nextSegments.length === 0) {\n            paths = 1;\n          } else {\n            paths = 0;\n            for (const nextSegment of segment.nextSegments) {\n              paths += countPathsToEnd(nextSegment, pathList);\n            }\n          }\n\n          cache.set(segment.id, paths);\n          return paths;\n        }\n\n        /**\n         * Gets the shortest path length to the start of a code path.\n         * For example:\n         *\n         * ```js\n         * function MyComponent() {\n         *   if (condition) {\n         *     // Segment 1\n         *   }\n         *   // Segment 2\n         * }\n         * ```\n         *\n         * There is only one path from segment 1 to the code path start. Its\n         * length is one so that is the shortest path.\n         *\n         * There are two paths from segment 2 to the code path start. One\n         * through segment 1 with a length of two and another directly to the\n         * start with a length of one. The shortest path has a length of one\n         * so we would return that.\n         */\n\n        function shortestPathLengthToStart(segment) {\n          const {cache} = shortestPathLengthToStart;\n          let length = cache.get(segment.id);\n\n          // If `length` is null then we found a cycle! Return infinity since\n          // the shortest path is definitely not the one where we looped.\n          if (length === null) {\n            return Infinity;\n          }\n\n          // We have a cached `length`. Return it.\n          if (length !== undefined) {\n            return length;\n          }\n\n          // Compute `length` and cache it. Guarding against cycles.\n          cache.set(segment.id, null);\n          if (segment.prevSegments.length === 0) {\n            length = 1;\n          } else {\n            length = Infinity;\n            for (const prevSegment of segment.prevSegments) {\n              const prevLength = shortestPathLengthToStart(prevSegment);\n              if (prevLength < length) {\n                length = prevLength;\n              }\n            }\n            length += 1;\n          }\n          cache.set(segment.id, length);\n          return length;\n        }\n\n        countPathsFromStart.cache = new Map();\n        countPathsToEnd.cache = new Map();\n        shortestPathLengthToStart.cache = new Map();\n\n        // Count all code paths to the end of our component/hook. Also primes\n        // the `countPathsToEnd` cache.\n        const allPathsFromStartToEnd = countPathsToEnd(codePath.initialSegment);\n\n        // Gets the function name for our code path. If the function name is\n        // `undefined` then we know either that we have an anonymous function\n        // expression or our code path is not in a function. In both cases we\n        // will want to error since neither are React function components or\n        // hook functions - unless it is an anonymous function argument to\n        // forwardRef or memo.\n        const codePathFunctionName = getFunctionName(codePathNode);\n\n        // This is a valid code path for React hooks if we are directly in a React\n        // function component or we are in a hook function.\n        const isSomewhereInsideComponentOrHook = isInsideComponentOrHook(\n          codePathNode,\n        );\n        const isDirectlyInsideComponentOrHook = codePathFunctionName\n          ? isComponentName(codePathFunctionName) ||\n            isHook(codePathFunctionName)\n          : isForwardRefCallback(codePathNode) || isMemoCallback(codePathNode);\n\n        // Compute the earliest finalizer level using information from the\n        // cache. We expect all reachable final segments to have a cache entry\n        // after calling `visitSegment()`.\n        let shortestFinalPathLength = Infinity;\n        for (const finalSegment of codePath.finalSegments) {\n          if (!finalSegment.reachable) {\n            continue;\n          }\n          const length = shortestPathLengthToStart(finalSegment);\n          if (length < shortestFinalPathLength) {\n            shortestFinalPathLength = length;\n          }\n        }\n\n        // Make sure all React Hooks pass our lint invariants. Log warnings\n        // if not.\n        for (const [segment, reactHooks] of reactHooksMap) {\n          // NOTE: We could report here that the hook is not reachable, but\n          // that would be redundant with more general \"no unreachable\"\n          // lint rules.\n          if (!segment.reachable) {\n            continue;\n          }\n\n          // If there are any final segments with a shorter path to start then\n          // we possibly have an early return.\n          //\n          // If our segment is a final segment itself then siblings could\n          // possibly be early returns.\n          const possiblyHasEarlyReturn =\n            segment.nextSegments.length === 0\n              ? shortestFinalPathLength <= shortestPathLengthToStart(segment)\n              : shortestFinalPathLength < shortestPathLengthToStart(segment);\n\n          // Count all the paths from the start of our code path to the end of\n          // our code path that go _through_ this segment. The critical piece\n          // of this is _through_. If we just call `countPathsToEnd(segment)`\n          // then we neglect that we may have gone through multiple paths to get\n          // to this point! Consider:\n          //\n          // ```js\n          // function MyComponent() {\n          //   if (a) {\n          //     // Segment 1\n          //   } else {\n          //     // Segment 2\n          //   }\n          //   // Segment 3\n          //   if (b) {\n          //     // Segment 4\n          //   } else {\n          //     // Segment 5\n          //   }\n          // }\n          // ```\n          //\n          // In this component we have four code paths:\n          //\n          // 1. `a = true; b = true`\n          // 2. `a = true; b = false`\n          // 3. `a = false; b = true`\n          // 4. `a = false; b = false`\n          //\n          // From segment 3 there are two code paths to the end through segment\n          // 4 and segment 5. However, we took two paths to get here through\n          // segment 1 and segment 2.\n          //\n          // If we multiply the paths from start (two) by the paths to end (two)\n          // for segment 3 we get four. Which is our desired count.\n          const pathsFromStartToEnd =\n            countPathsFromStart(segment) * countPathsToEnd(segment);\n\n          // Is this hook a part of a cyclic segment?\n          const cycled = cyclic.has(segment.id);\n\n          for (const hook of reactHooks) {\n            // Report an error if a hook may be called more then once.\n            if (cycled) {\n              context.report({\n                node: hook,\n                message:\n                  `React Hook \"${context.getSource(hook)}\" may be executed ` +\n                  'more than once. Possibly because it is called in a loop. ' +\n                  'React Hooks must be called in the exact same order in ' +\n                  'every component render.',\n              });\n            }\n\n            // If this is not a valid code path for React hooks then we need to\n            // log a warning for every hook in this code path.\n            //\n            // Pick a special message depending on the scope this hook was\n            // called in.\n            if (isDirectlyInsideComponentOrHook) {\n              // Report an error if a hook does not reach all finalizing code\n              // path segments.\n              //\n              // Special case when we think there might be an early return.\n              if (!cycled && pathsFromStartToEnd !== allPathsFromStartToEnd) {\n                const message =\n                  `React Hook \"${context.getSource(hook)}\" is called ` +\n                  'conditionally. React Hooks must be called in the exact ' +\n                  'same order in every component render.' +\n                  (possiblyHasEarlyReturn\n                    ? ' Did you accidentally call a React Hook after an' +\n                      ' early return?'\n                    : '');\n                context.report({node: hook, message});\n              }\n            } else if (\n              codePathNode.parent &&\n              (codePathNode.parent.type === 'MethodDefinition' ||\n                codePathNode.parent.type === 'ClassProperty') &&\n              codePathNode.parent.value === codePathNode\n            ) {\n              // Custom message for hooks inside a class\n              const message =\n                `React Hook \"${context.getSource(hook)}\" cannot be called ` +\n                'in a class component. React Hooks must be called in a ' +\n                'React function component or a custom React Hook function.';\n              context.report({node: hook, message});\n            } else if (codePathFunctionName) {\n              // Custom message if we found an invalid function name.\n              const message =\n                `React Hook \"${context.getSource(hook)}\" is called in ` +\n                `function \"${context.getSource(codePathFunctionName)}\" ` +\n                'that is neither a React function component nor a custom ' +\n                'React Hook function.' +\n                ' React component names must start with an uppercase letter.';\n              context.report({node: hook, message});\n            } else if (codePathNode.type === 'Program') {\n              // These are dangerous if you have inline requires enabled.\n              const message =\n                `React Hook \"${context.getSource(hook)}\" cannot be called ` +\n                'at the top level. React Hooks must be called in a ' +\n                'React function component or a custom React Hook function.';\n              context.report({node: hook, message});\n            } else {\n              // Assume in all other cases the user called a hook in some\n              // random function callback. This should usually be true for\n              // anonymous function expressions. Hopefully this is clarifying\n              // enough in the common case that the incorrect message in\n              // uncommon cases doesn't matter.\n              if (isSomewhereInsideComponentOrHook) {\n                const message =\n                  `React Hook \"${context.getSource(hook)}\" cannot be called ` +\n                  'inside a callback. React Hooks must be called in a ' +\n                  'React function component or a custom React Hook function.';\n                context.report({node: hook, message});\n              }\n            }\n          }\n        }\n      },\n\n      // Missed opportunity...We could visit all `Identifier`s instead of all\n      // `CallExpression`s and check that _every use_ of a hook name is valid.\n      // But that gets complicated and enters type-system territory, so we're\n      // only being strict about hook calls for now.\n      CallExpression(node) {\n        if (isHook(node.callee)) {\n          // Add the hook node to a map keyed by the code path segment. We will\n          // do full code path analysis at the end of our code path.\n          const reactHooksMap = last(codePathReactHooksMapStack);\n          const codePathSegment = last(codePathSegmentStack);\n          let reactHooks = reactHooksMap.get(codePathSegment);\n          if (!reactHooks) {\n            reactHooks = [];\n            reactHooksMap.set(codePathSegment, reactHooks);\n          }\n          reactHooks.push(node.callee);\n        }\n      },\n    };\n  },\n};\n\n/**\n * Gets the static name of a function AST node. For function declarations it is\n * easy. For anonymous function expressions it is much harder. If you search for\n * `IsAnonymousFunctionDefinition()` in the ECMAScript spec you'll find places\n * where JS gives anonymous function expressions names. We roughly detect the\n * same AST nodes with some exceptions to better fit our use case.\n */\n\nfunction getFunctionName(node) {\n  if (\n    node.type === 'FunctionDeclaration' ||\n    (node.type === 'FunctionExpression' && node.id)\n  ) {\n    // function useHook() {}\n    // const whatever = function useHook() {};\n    //\n    // Function declaration or function expression names win over any\n    // assignment statements or other renames.\n    return node.id;\n  } else if (\n    node.type === 'FunctionExpression' ||\n    node.type === 'ArrowFunctionExpression'\n  ) {\n    if (\n      node.parent.type === 'VariableDeclarator' &&\n      node.parent.init === node\n    ) {\n      // const useHook = () => {};\n      return node.parent.id;\n    } else if (\n      node.parent.type === 'AssignmentExpression' &&\n      node.parent.right === node &&\n      node.parent.operator === '='\n    ) {\n      // useHook = () => {};\n      return node.parent.left;\n    } else if (\n      node.parent.type === 'Property' &&\n      node.parent.value === node &&\n      !node.parent.computed\n    ) {\n      // {useHook: () => {}}\n      // {useHook() {}}\n      return node.parent.key;\n\n      // NOTE: We could also support `ClassProperty` and `MethodDefinition`\n      // here to be pedantic. However, hooks in a class are an anti-pattern. So\n      // we don't allow it to error early.\n      //\n      // class {useHook = () => {}}\n      // class {useHook() {}}\n    } else if (\n      node.parent.type === 'AssignmentPattern' &&\n      node.parent.right === node &&\n      !node.parent.computed\n    ) {\n      // const {useHook = () => {}} = {};\n      // ({useHook = () => {}} = {});\n      //\n      // Kinda clowny, but we'd said we'd follow spec convention for\n      // `IsAnonymousFunctionDefinition()` usage.\n      return node.parent.left;\n    } else {\n      return undefined;\n    }\n  } else {\n    return undefined;\n  }\n}\n\n/**\n * Convenience function for peeking the last item in a stack.\n */\n\nfunction last(array) {\n  return array[array.length - 1];\n}\n","/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n/* eslint-disable no-for-of-loops/no-for-of-loops */\n\n'use strict';\n\nexport default {\n  meta: {\n    type: 'suggestion',\n    docs: {\n      description:\n        'verifies the list of dependencies for Hooks like useEffect and similar',\n      category: 'Best Practices',\n      recommended: true,\n      url: 'https://github.com/facebook/react/issues/14920',\n    },\n    fixable: 'code',\n    schema: [\n      {\n        type: 'object',\n        additionalProperties: false,\n        enableDangerousAutofixThisMayCauseInfiniteLoops: false,\n        properties: {\n          additionalHooks: {\n            type: 'string',\n          },\n          enableDangerousAutofixThisMayCauseInfiniteLoops: {\n            type: 'boolean',\n          },\n        },\n      },\n    ],\n  },\n  create(context) {\n    // Parse the `additionalHooks` regex.\n    const additionalHooks =\n      context.options &&\n      context.options[0] &&\n      context.options[0].additionalHooks\n        ? new RegExp(context.options[0].additionalHooks)\n        : undefined;\n\n    const enableDangerousAutofixThisMayCauseInfiniteLoops =\n      (context.options &&\n        context.options[0] &&\n        context.options[0].enableDangerousAutofixThisMayCauseInfiniteLoops) ||\n      false;\n\n    const options = {\n      additionalHooks,\n      enableDangerousAutofixThisMayCauseInfiniteLoops,\n    };\n\n    function reportProblem(problem) {\n      if (enableDangerousAutofixThisMayCauseInfiniteLoops) {\n        // Used to enable legacy behavior. Dangerous.\n        // Keep this as an option until major IDEs upgrade (including VSCode FB ESLint extension).\n        if (Array.isArray(problem.suggest) && problem.suggest.length > 0) {\n          problem.fix = problem.suggest[0].fix;\n        }\n      }\n      context.report(problem);\n    }\n\n    const scopeManager = context.getSourceCode().scopeManager;\n\n    // Should be shared between visitors.\n    const setStateCallSites = new WeakMap();\n    const stateVariables = new WeakSet();\n    const stableKnownValueCache = new WeakMap();\n    const functionWithoutCapturedValueCache = new WeakMap();\n    function memoizeWithWeakMap(fn, map) {\n      return function(arg) {\n        if (map.has(arg)) {\n          // to verify cache hits:\n          // console.log(arg.name)\n          return map.get(arg);\n        }\n        const result = fn(arg);\n        map.set(arg, result);\n        return result;\n      };\n    }\n    /**\n     * Visitor for both function expressions and arrow function expressions.\n     */\n    function visitFunctionWithDependencies(\n      node,\n      declaredDependenciesNode,\n      reactiveHook,\n      reactiveHookName,\n      isEffect,\n    ) {\n      if (isEffect && node.async) {\n        reportProblem({\n          node: node,\n          message:\n            `Effect callbacks are synchronous to prevent race conditions. ` +\n            `Put the async function inside:\\n\\n` +\n            'useEffect(() => {\\n' +\n            '  async function fetchData() {\\n' +\n            '    // You can await here\\n' +\n            '    const response = await MyAPI.getData(someId);\\n' +\n            '    // ...\\n' +\n            '  }\\n' +\n            '  fetchData();\\n' +\n            `}, [someId]); // Or [] if effect doesn't need props or state\\n\\n` +\n            'Learn more about data fetching with Hooks: https://reactjs.org/link/hooks-data-fetching',\n        });\n      }\n\n      // Get the current scope.\n      const scope = scopeManager.acquire(node);\n\n      // Find all our \"pure scopes\". On every re-render of a component these\n      // pure scopes may have changes to the variables declared within. So all\n      // variables used in our reactive hook callback but declared in a pure\n      // scope need to be listed as dependencies of our reactive hook callback.\n      //\n      // According to the rules of React you can't read a mutable value in pure\n      // scope. We can't enforce this in a lint so we trust that all variables\n      // declared outside of pure scope are indeed frozen.\n      const pureScopes = new Set();\n      let componentScope = null;\n      {\n        let currentScope = scope.upper;\n        while (currentScope) {\n          pureScopes.add(currentScope);\n          if (currentScope.type === 'function') {\n            break;\n          }\n          currentScope = currentScope.upper;\n        }\n        // If there is no parent function scope then there are no pure scopes.\n        // The ones we've collected so far are incorrect. So don't continue with\n        // the lint.\n        if (!currentScope) {\n          return;\n        }\n        componentScope = currentScope;\n      }\n\n      // Next we'll define a few helpers that helps us\n      // tell if some values don't have to be declared as deps.\n\n      // Some are known to be stable based on Hook calls.\n      // const [state, setState] = useState() / React.useState()\n      //               ^^^ true for this reference\n      // const [state, dispatch] = useReducer() / React.useReducer()\n      //               ^^^ true for this reference\n      // const ref = useRef()\n      //       ^^^ true for this reference\n      // False for everything else.\n      function isStableKnownHookValue(resolved) {\n        if (!Array.isArray(resolved.defs)) {\n          return false;\n        }\n        const def = resolved.defs[0];\n        if (def == null) {\n          return false;\n        }\n        // Look for `let stuff = ...`\n        if (def.node.type !== 'VariableDeclarator') {\n          return false;\n        }\n        let init = def.node.init;\n        if (init == null) {\n          return false;\n        }\n        while (init.type === 'TSAsExpression') {\n          init = init.expression;\n        }\n        // Detect primitive constants\n        // const foo = 42\n        let declaration = def.node.parent;\n        if (declaration == null) {\n          // This might happen if variable is declared after the callback.\n          // In that case ESLint won't set up .parent refs.\n          // So we'll set them up manually.\n          fastFindReferenceWithParent(componentScope.block, def.node.id);\n          declaration = def.node.parent;\n          if (declaration == null) {\n            return false;\n          }\n        }\n        if (\n          declaration.kind === 'const' &&\n          init.type === 'Literal' &&\n          (typeof init.value === 'string' ||\n            typeof init.value === 'number' ||\n            init.value === null)\n        ) {\n          // Definitely stable\n          return true;\n        }\n        // Detect known Hook calls\n        // const [_, setState] = useState()\n        if (init.type !== 'CallExpression') {\n          return false;\n        }\n        let callee = init.callee;\n        // Step into `= React.something` initializer.\n        if (\n          callee.type === 'MemberExpression' &&\n          callee.object.name === 'React' &&\n          callee.property != null &&\n          !callee.computed\n        ) {\n          callee = callee.property;\n        }\n        if (callee.type !== 'Identifier') {\n          return false;\n        }\n        const id = def.node.id;\n        const {name} = callee;\n        if (name === 'useRef' && id.type === 'Identifier') {\n          // useRef() return value is stable.\n          return true;\n        } else if (name === 'useState' || name === 'useReducer') {\n          // Only consider second value in initializing tuple stable.\n          if (\n            id.type === 'ArrayPattern' &&\n            id.elements.length === 2 &&\n            Array.isArray(resolved.identifiers)\n          ) {\n            // Is second tuple value the same reference we're checking?\n            if (id.elements[1] === resolved.identifiers[0]) {\n              if (name === 'useState') {\n                const references = resolved.references;\n                for (let i = 0; i < references.length; i++) {\n                  setStateCallSites.set(\n                    references[i].identifier,\n                    id.elements[0],\n                  );\n                }\n              }\n              // Setter is stable.\n              return true;\n            } else if (id.elements[0] === resolved.identifiers[0]) {\n              if (name === 'useState') {\n                const references = resolved.references;\n                for (let i = 0; i < references.length; i++) {\n                  stateVariables.add(references[i].identifier);\n                }\n              }\n              // State variable itself is dynamic.\n              return false;\n            }\n          }\n        } else if (name === 'useTransition') {\n          if (\n            id.type === 'ArrayPattern' &&\n            Array.isArray(resolved.identifiers)\n          ) {\n            // Is first tuple value the same reference we're checking?\n            if (id.elements[0] === resolved.identifiers[0]) {\n              // Setter is stable.\n              return true;\n            }\n          }\n        }\n        // By default assume it's dynamic.\n        return false;\n      }\n\n      // Some are just functions that don't reference anything dynamic.\n      function isFunctionWithoutCapturedValues(resolved) {\n        if (!Array.isArray(resolved.defs)) {\n          return false;\n        }\n        const def = resolved.defs[0];\n        if (def == null) {\n          return false;\n        }\n        if (def.node == null || def.node.id == null) {\n          return false;\n        }\n        // Search the direct component subscopes for\n        // top-level function definitions matching this reference.\n        const fnNode = def.node;\n        const childScopes = componentScope.childScopes;\n        let fnScope = null;\n        let i;\n        for (i = 0; i < childScopes.length; i++) {\n          const childScope = childScopes[i];\n          const childScopeBlock = childScope.block;\n          if (\n            // function handleChange() {}\n            (fnNode.type === 'FunctionDeclaration' &&\n              childScopeBlock === fnNode) ||\n            // const handleChange = () => {}\n            // const handleChange = function() {}\n            (fnNode.type === 'VariableDeclarator' &&\n              childScopeBlock.parent === fnNode)\n          ) {\n            // Found it!\n            fnScope = childScope;\n            break;\n          }\n        }\n        if (fnScope == null) {\n          return false;\n        }\n        // Does this function capture any values\n        // that are in pure scopes (aka render)?\n        for (i = 0; i < fnScope.through.length; i++) {\n          const ref = fnScope.through[i];\n          if (ref.resolved == null) {\n            continue;\n          }\n          if (\n            pureScopes.has(ref.resolved.scope) &&\n            // Stable values are fine though,\n            // although we won't check functions deeper.\n            !memoizedIsStablecKnownHookValue(ref.resolved)\n          ) {\n            return false;\n          }\n        }\n        // If we got here, this function doesn't capture anything\n        // from render--or everything it captures is known stable.\n        return true;\n      }\n\n      // Remember such values. Avoid re-running extra checks on them.\n      const memoizedIsStablecKnownHookValue = memoizeWithWeakMap(\n        isStableKnownHookValue,\n        stableKnownValueCache,\n      );\n      const memoizedIsFunctionWithoutCapturedValues = memoizeWithWeakMap(\n        isFunctionWithoutCapturedValues,\n        functionWithoutCapturedValueCache,\n      );\n\n      // These are usually mistaken. Collect them.\n      const currentRefsInEffectCleanup = new Map();\n\n      // Is this reference inside a cleanup function for this effect node?\n      // We can check by traversing scopes upwards  from the reference, and checking\n      // if the last \"return () => \" we encounter is located directly inside the effect.\n      function isInsideEffectCleanup(reference) {\n        let curScope = reference.from;\n        let isInReturnedFunction = false;\n        while (curScope.block !== node) {\n          if (curScope.type === 'function') {\n            isInReturnedFunction =\n              curScope.block.parent != null &&\n              curScope.block.parent.type === 'ReturnStatement';\n          }\n          curScope = curScope.upper;\n        }\n        return isInReturnedFunction;\n      }\n\n      // Get dependencies from all our resolved references in pure scopes.\n      // Key is dependency string, value is whether it's stable.\n      const dependencies = new Map();\n      const optionalChains = new Map();\n      gatherDependenciesRecursively(scope);\n\n      function gatherDependenciesRecursively(currentScope) {\n        for (const reference of currentScope.references) {\n          // If this reference is not resolved or it is not declared in a pure\n          // scope then we don't care about this reference.\n          if (!reference.resolved) {\n            continue;\n          }\n          if (!pureScopes.has(reference.resolved.scope)) {\n            continue;\n          }\n\n          // Narrow the scope of a dependency if it is, say, a member expression.\n          // Then normalize the narrowed dependency.\n          const referenceNode = fastFindReferenceWithParent(\n            node,\n            reference.identifier,\n          );\n          const dependencyNode = getDependency(referenceNode);\n          const dependency = analyzePropertyChain(\n            dependencyNode,\n            optionalChains,\n          );\n\n          // Accessing ref.current inside effect cleanup is bad.\n          if (\n            // We're in an effect...\n            isEffect &&\n            // ... and this look like accessing .current...\n            dependencyNode.type === 'Identifier' &&\n            (dependencyNode.parent.type === 'MemberExpression' ||\n              dependencyNode.parent.type === 'OptionalMemberExpression') &&\n            !dependencyNode.parent.computed &&\n            dependencyNode.parent.property.type === 'Identifier' &&\n            dependencyNode.parent.property.name === 'current' &&\n            // ...in a cleanup function or below...\n            isInsideEffectCleanup(reference)\n          ) {\n            currentRefsInEffectCleanup.set(dependency, {\n              reference,\n              dependencyNode,\n            });\n          }\n\n          if (\n            dependencyNode.parent.type === 'TSTypeQuery' ||\n            dependencyNode.parent.type === 'TSTypeReference'\n          ) {\n            continue;\n          }\n\n          const def = reference.resolved.defs[0];\n          if (def == null) {\n            continue;\n          }\n          // Ignore references to the function itself as it's not defined yet.\n          if (def.node != null && def.node.init === node.parent) {\n            continue;\n          }\n          // Ignore Flow type parameters\n          if (def.type === 'TypeParameter') {\n            continue;\n          }\n\n          // Add the dependency to a map so we can make sure it is referenced\n          // again in our dependencies array. Remember whether it's stable.\n          if (!dependencies.has(dependency)) {\n            const resolved = reference.resolved;\n            const isStable =\n              memoizedIsStablecKnownHookValue(resolved) ||\n              memoizedIsFunctionWithoutCapturedValues(resolved);\n            dependencies.set(dependency, {\n              isStable,\n              references: [reference],\n            });\n          } else {\n            dependencies.get(dependency).references.push(reference);\n          }\n        }\n\n        for (const childScope of currentScope.childScopes) {\n          gatherDependenciesRecursively(childScope);\n        }\n      }\n\n      // Warn about accessing .current in cleanup effects.\n      currentRefsInEffectCleanup.forEach(\n        ({reference, dependencyNode}, dependency) => {\n          const references = reference.resolved.references;\n          // Is React managing this ref or us?\n          // Let's see if we can find a .current assignment.\n          let foundCurrentAssignment = false;\n          for (let i = 0; i < references.length; i++) {\n            const {identifier} = references[i];\n            const {parent} = identifier;\n            if (\n              parent != null &&\n              // ref.current\n              // Note: no need to handle OptionalMemberExpression because it can't be LHS.\n              parent.type === 'MemberExpression' &&\n              !parent.computed &&\n              parent.property.type === 'Identifier' &&\n              parent.property.name === 'current' &&\n              // ref.current = <something>\n              parent.parent.type === 'AssignmentExpression' &&\n              parent.parent.left === parent\n            ) {\n              foundCurrentAssignment = true;\n              break;\n            }\n          }\n          // We only want to warn about React-managed refs.\n          if (foundCurrentAssignment) {\n            return;\n          }\n          reportProblem({\n            node: dependencyNode.parent.property,\n            message:\n              `The ref value '${dependency}.current' will likely have ` +\n              `changed by the time this effect cleanup function runs. If ` +\n              `this ref points to a node rendered by React, copy ` +\n              `'${dependency}.current' to a variable inside the effect, and ` +\n              `use that variable in the cleanup function.`,\n          });\n        },\n      );\n\n      // Warn about assigning to variables in the outer scope.\n      // Those are usually bugs.\n      const staleAssignments = new Set();\n      function reportStaleAssignment(writeExpr, key) {\n        if (staleAssignments.has(key)) {\n          return;\n        }\n        staleAssignments.add(key);\n        reportProblem({\n          node: writeExpr,\n          message:\n            `Assignments to the '${key}' variable from inside React Hook ` +\n            `${context.getSource(reactiveHook)} will be lost after each ` +\n            `render. To preserve the value over time, store it in a useRef ` +\n            `Hook and keep the mutable value in the '.current' property. ` +\n            `Otherwise, you can move this variable directly inside ` +\n            `${context.getSource(reactiveHook)}.`,\n        });\n      }\n\n      // Remember which deps are stable and report bad usage first.\n      const stableDependencies = new Set();\n      dependencies.forEach(({isStable, references}, key) => {\n        if (isStable) {\n          stableDependencies.add(key);\n        }\n        references.forEach(reference => {\n          if (reference.writeExpr) {\n            reportStaleAssignment(reference.writeExpr, key);\n          }\n        });\n      });\n\n      if (staleAssignments.size > 0) {\n        // The intent isn't clear so we'll wait until you fix those first.\n        return;\n      }\n\n      if (!declaredDependenciesNode) {\n        // Check if there are any top-level setState() calls.\n        // Those tend to lead to infinite loops.\n        let setStateInsideEffectWithoutDeps = null;\n        dependencies.forEach(({isStable, references}, key) => {\n          if (setStateInsideEffectWithoutDeps) {\n            return;\n          }\n          references.forEach(reference => {\n            if (setStateInsideEffectWithoutDeps) {\n              return;\n            }\n\n            const id = reference.identifier;\n            const isSetState = setStateCallSites.has(id);\n            if (!isSetState) {\n              return;\n            }\n\n            let fnScope = reference.from;\n            while (fnScope.type !== 'function') {\n              fnScope = fnScope.upper;\n            }\n            const isDirectlyInsideEffect = fnScope.block === node;\n            if (isDirectlyInsideEffect) {\n              // TODO: we could potentially ignore early returns.\n              setStateInsideEffectWithoutDeps = key;\n            }\n          });\n        });\n        if (setStateInsideEffectWithoutDeps) {\n          const {suggestedDependencies} = collectRecommendations({\n            dependencies,\n            declaredDependencies: [],\n            stableDependencies,\n            externalDependencies: new Set(),\n            isEffect: true,\n          });\n          reportProblem({\n            node: reactiveHook,\n            message:\n              `React Hook ${reactiveHookName} contains a call to '${setStateInsideEffectWithoutDeps}'. ` +\n              `Without a list of dependencies, this can lead to an infinite chain of updates. ` +\n              `To fix this, pass [` +\n              suggestedDependencies.join(', ') +\n              `] as a second argument to the ${reactiveHookName} Hook.`,\n            suggest: [\n              {\n                desc: `Add dependencies array: [${suggestedDependencies.join(\n                  ', ',\n                )}]`,\n                fix(fixer) {\n                  return fixer.insertTextAfter(\n                    node,\n                    `, [${suggestedDependencies.join(', ')}]`,\n                  );\n                },\n              },\n            ],\n          });\n        }\n        return;\n      }\n\n      const declaredDependencies = [];\n      const externalDependencies = new Set();\n      if (declaredDependenciesNode.type !== 'ArrayExpression') {\n        // If the declared dependencies are not an array expression then we\n        // can't verify that the user provided the correct dependencies. Tell\n        // the user this in an error.\n        reportProblem({\n          node: declaredDependenciesNode,\n          message:\n            `React Hook ${context.getSource(reactiveHook)} was passed a ` +\n            'dependency list that is not an array literal. This means we ' +\n            \"can't statically verify whether you've passed the correct \" +\n            'dependencies.',\n        });\n      } else {\n        declaredDependenciesNode.elements.forEach(declaredDependencyNode => {\n          // Skip elided elements.\n          if (declaredDependencyNode === null) {\n            return;\n          }\n          // If we see a spread element then add a special warning.\n          if (declaredDependencyNode.type === 'SpreadElement') {\n            reportProblem({\n              node: declaredDependencyNode,\n              message:\n                `React Hook ${context.getSource(reactiveHook)} has a spread ` +\n                \"element in its dependency array. This means we can't \" +\n                \"statically verify whether you've passed the \" +\n                'correct dependencies.',\n            });\n            return;\n          }\n          // Try to normalize the declared dependency. If we can't then an error\n          // will be thrown. We will catch that error and report an error.\n          let declaredDependency;\n          try {\n            declaredDependency = analyzePropertyChain(\n              declaredDependencyNode,\n              null,\n            );\n          } catch (error) {\n            if (/Unsupported node type/.test(error.message)) {\n              if (declaredDependencyNode.type === 'Literal') {\n                if (dependencies.has(declaredDependencyNode.value)) {\n                  reportProblem({\n                    node: declaredDependencyNode,\n                    message:\n                      `The ${declaredDependencyNode.raw} literal is not a valid dependency ` +\n                      `because it never changes. ` +\n                      `Did you mean to include ${declaredDependencyNode.value} in the array instead?`,\n                  });\n                } else {\n                  reportProblem({\n                    node: declaredDependencyNode,\n                    message:\n                      `The ${declaredDependencyNode.raw} literal is not a valid dependency ` +\n                      'because it never changes. You can safely remove it.',\n                  });\n                }\n              } else {\n                reportProblem({\n                  node: declaredDependencyNode,\n                  message:\n                    `React Hook ${context.getSource(reactiveHook)} has a ` +\n                    `complex expression in the dependency array. ` +\n                    'Extract it to a separate variable so it can be statically checked.',\n                });\n              }\n\n              return;\n            } else {\n              throw error;\n            }\n          }\n\n          let maybeID = declaredDependencyNode;\n          while (\n            maybeID.type === 'MemberExpression' ||\n            maybeID.type === 'OptionalMemberExpression' ||\n            maybeID.type === 'ChainExpression'\n          ) {\n            maybeID = maybeID.object || maybeID.expression.object;\n          }\n          const isDeclaredInComponent = !componentScope.through.some(\n            ref => ref.identifier === maybeID,\n          );\n\n          // Add the dependency to our declared dependency map.\n          declaredDependencies.push({\n            key: declaredDependency,\n            node: declaredDependencyNode,\n          });\n\n          if (!isDeclaredInComponent) {\n            externalDependencies.add(declaredDependency);\n          }\n        });\n      }\n\n      const {\n        suggestedDependencies,\n        unnecessaryDependencies,\n        missingDependencies,\n        duplicateDependencies,\n      } = collectRecommendations({\n        dependencies,\n        declaredDependencies,\n        stableDependencies,\n        externalDependencies,\n        isEffect,\n      });\n\n      let suggestedDeps = suggestedDependencies;\n\n      const problemCount =\n        duplicateDependencies.size +\n        missingDependencies.size +\n        unnecessaryDependencies.size;\n\n      if (problemCount === 0) {\n        // If nothing else to report, check if some dependencies would\n        // invalidate on every render.\n        const constructions = scanForConstructions({\n          declaredDependencies,\n          declaredDependenciesNode,\n          componentScope,\n          scope,\n        });\n        constructions.forEach(\n          ({construction, isUsedOutsideOfHook, depType}) => {\n            const wrapperHook =\n              depType === 'function' ? 'useCallback' : 'useMemo';\n\n            const constructionType =\n              depType === 'function' ? 'definition' : 'initialization';\n\n            const defaultAdvice = `wrap the ${constructionType} of '${construction.name.name}' in its own ${wrapperHook}() Hook.`;\n\n            const advice = isUsedOutsideOfHook\n              ? `To fix this, ${defaultAdvice}`\n              : `Move it inside the ${reactiveHookName} callback. Alternatively, ${defaultAdvice}`;\n\n            const causation =\n              depType === 'conditional' || depType === 'logical expression'\n                ? 'could make'\n                : 'makes';\n\n            const message =\n              `The '${construction.name.name}' ${depType} ${causation} the dependencies of ` +\n              `${reactiveHookName} Hook (at line ${declaredDependenciesNode.loc.start.line}) ` +\n              `change on every render. ${advice}`;\n\n            let suggest;\n            // Only handle the simple case of variable assignments.\n            // Wrapping function declarations can mess up hoisting.\n            if (\n              isUsedOutsideOfHook &&\n              construction.type === 'Variable' &&\n              // Objects may be mutated ater construction, which would make this\n              // fix unsafe. Functions _probably_ won't be mutated, so we'll\n              // allow this fix for them.\n              depType === 'function'\n            ) {\n              suggest = [\n                {\n                  desc: `Wrap the ${constructionType} of '${construction.name.name}' in its own ${wrapperHook}() Hook.`,\n                  fix(fixer) {\n                    const [before, after] =\n                      wrapperHook === 'useMemo'\n                        ? [`useMemo(() => { return `, '; })']\n                        : ['useCallback(', ')'];\n                    return [\n                      // TODO: also add an import?\n                      fixer.insertTextBefore(construction.node.init, before),\n                      // TODO: ideally we'd gather deps here but it would require\n                      // restructuring the rule code. This will cause a new lint\n                      // error to appear immediately for useCallback. Note we're\n                      // not adding [] because would that changes semantics.\n                      fixer.insertTextAfter(construction.node.init, after),\n                    ];\n                  },\n                },\n              ];\n            }\n            // TODO: What if the function needs to change on every render anyway?\n            // Should we suggest removing effect deps as an appropriate fix too?\n            reportProblem({\n              // TODO: Why not report this at the dependency site?\n              node: construction.node,\n              message,\n              suggest,\n            });\n          },\n        );\n        return;\n      }\n\n      // If we're going to report a missing dependency,\n      // we might as well recalculate the list ignoring\n      // the currently specified deps. This can result\n      // in some extra deduplication. We can't do this\n      // for effects though because those have legit\n      // use cases for over-specifying deps.\n      if (!isEffect && missingDependencies.size > 0) {\n        suggestedDeps = collectRecommendations({\n          dependencies,\n          declaredDependencies: [], // Pretend we don't know\n          stableDependencies,\n          externalDependencies,\n          isEffect,\n        }).suggestedDependencies;\n      }\n\n      // Alphabetize the suggestions, but only if deps were already alphabetized.\n      function areDeclaredDepsAlphabetized() {\n        if (declaredDependencies.length === 0) {\n          return true;\n        }\n        const declaredDepKeys = declaredDependencies.map(dep => dep.key);\n        const sortedDeclaredDepKeys = declaredDepKeys.slice().sort();\n        return declaredDepKeys.join(',') === sortedDeclaredDepKeys.join(',');\n      }\n      if (areDeclaredDepsAlphabetized()) {\n        suggestedDeps.sort();\n      }\n\n      // Most of our algorithm deals with dependency paths with optional chaining stripped.\n      // This function is the last step before printing a dependency, so now is a good time to\n      // check whether any members in our path are always used as optional-only. In that case,\n      // we will use ?. instead of . to concatenate those parts of the path.\n      function formatDependency(path) {\n        const members = path.split('.');\n        let finalPath = '';\n        for (let i = 0; i < members.length; i++) {\n          if (i !== 0) {\n            const pathSoFar = members.slice(0, i + 1).join('.');\n            const isOptional = optionalChains.get(pathSoFar) === true;\n            finalPath += isOptional ? '?.' : '.';\n          }\n          finalPath += members[i];\n        }\n        return finalPath;\n      }\n\n      function getWarningMessage(deps, singlePrefix, label, fixVerb) {\n        if (deps.size === 0) {\n          return null;\n        }\n        return (\n          (deps.size > 1 ? '' : singlePrefix + ' ') +\n          label +\n          ' ' +\n          (deps.size > 1 ? 'dependencies' : 'dependency') +\n          ': ' +\n          joinEnglish(\n            Array.from(deps)\n              .sort()\n              .map(name => \"'\" + formatDependency(name) + \"'\"),\n          ) +\n          `. Either ${fixVerb} ${\n            deps.size > 1 ? 'them' : 'it'\n          } or remove the dependency array.`\n        );\n      }\n\n      let extraWarning = '';\n      if (unnecessaryDependencies.size > 0) {\n        let badRef = null;\n        Array.from(unnecessaryDependencies.keys()).forEach(key => {\n          if (badRef !== null) {\n            return;\n          }\n          if (key.endsWith('.current')) {\n            badRef = key;\n          }\n        });\n        if (badRef !== null) {\n          extraWarning =\n            ` Mutable values like '${badRef}' aren't valid dependencies ` +\n            \"because mutating them doesn't re-render the component.\";\n        } else if (externalDependencies.size > 0) {\n          const dep = Array.from(externalDependencies)[0];\n          // Don't show this warning for things that likely just got moved *inside* the callback\n          // because in that case they're clearly not referring to globals.\n          if (!scope.set.has(dep)) {\n            extraWarning =\n              ` Outer scope values like '${dep}' aren't valid dependencies ` +\n              `because mutating them doesn't re-render the component.`;\n          }\n        }\n      }\n\n      // `props.foo()` marks `props` as a dependency because it has\n      // a `this` value. This warning can be confusing.\n      // So if we're going to show it, append a clarification.\n      if (!extraWarning && missingDependencies.has('props')) {\n        const propDep = dependencies.get('props');\n        if (propDep == null) {\n          return;\n        }\n        const refs = propDep.references;\n        if (!Array.isArray(refs)) {\n          return;\n        }\n        let isPropsOnlyUsedInMembers = true;\n        for (let i = 0; i < refs.length; i++) {\n          const ref = refs[i];\n          const id = fastFindReferenceWithParent(\n            componentScope.block,\n            ref.identifier,\n          );\n          if (!id) {\n            isPropsOnlyUsedInMembers = false;\n            break;\n          }\n          const parent = id.parent;\n          if (parent == null) {\n            isPropsOnlyUsedInMembers = false;\n            break;\n          }\n          if (\n            parent.type !== 'MemberExpression' &&\n            parent.type !== 'OptionalMemberExpression'\n          ) {\n            isPropsOnlyUsedInMembers = false;\n            break;\n          }\n        }\n        if (isPropsOnlyUsedInMembers) {\n          extraWarning =\n            ` However, 'props' will change when *any* prop changes, so the ` +\n            `preferred fix is to destructure the 'props' object outside of ` +\n            `the ${reactiveHookName} call and refer to those specific props ` +\n            `inside ${context.getSource(reactiveHook)}.`;\n        }\n      }\n\n      if (!extraWarning && missingDependencies.size > 0) {\n        // See if the user is trying to avoid specifying a callable prop.\n        // This usually means they're unaware of useCallback.\n        let missingCallbackDep = null;\n        missingDependencies.forEach(missingDep => {\n          if (missingCallbackDep) {\n            return;\n          }\n          // Is this a variable from top scope?\n          const topScopeRef = componentScope.set.get(missingDep);\n          const usedDep = dependencies.get(missingDep);\n          if (usedDep.references[0].resolved !== topScopeRef) {\n            return;\n          }\n          // Is this a destructured prop?\n          const def = topScopeRef.defs[0];\n          if (def == null || def.name == null || def.type !== 'Parameter') {\n            return;\n          }\n          // Was it called in at least one case? Then it's a function.\n          let isFunctionCall = false;\n          let id;\n          for (let i = 0; i < usedDep.references.length; i++) {\n            id = usedDep.references[i].identifier;\n            if (\n              id != null &&\n              id.parent != null &&\n              (id.parent.type === 'CallExpression' ||\n                id.parent.type === 'OptionalCallExpression') &&\n              id.parent.callee === id\n            ) {\n              isFunctionCall = true;\n              break;\n            }\n          }\n          if (!isFunctionCall) {\n            return;\n          }\n          // If it's missing (i.e. in component scope) *and* it's a parameter\n          // then it is definitely coming from props destructuring.\n          // (It could also be props itself but we wouldn't be calling it then.)\n          missingCallbackDep = missingDep;\n        });\n        if (missingCallbackDep !== null) {\n          extraWarning =\n            ` If '${missingCallbackDep}' changes too often, ` +\n            `find the parent component that defines it ` +\n            `and wrap that definition in useCallback.`;\n        }\n      }\n\n      if (!extraWarning && missingDependencies.size > 0) {\n        let setStateRecommendation = null;\n        missingDependencies.forEach(missingDep => {\n          if (setStateRecommendation !== null) {\n            return;\n          }\n          const usedDep = dependencies.get(missingDep);\n          const references = usedDep.references;\n          let id;\n          let maybeCall;\n          for (let i = 0; i < references.length; i++) {\n            id = references[i].identifier;\n            maybeCall = id.parent;\n            // Try to see if we have setState(someExpr(missingDep)).\n            while (maybeCall != null && maybeCall !== componentScope.block) {\n              if (maybeCall.type === 'CallExpression') {\n                const correspondingStateVariable = setStateCallSites.get(\n                  maybeCall.callee,\n                );\n                if (correspondingStateVariable != null) {\n                  if (correspondingStateVariable.name === missingDep) {\n                    // setCount(count + 1)\n                    setStateRecommendation = {\n                      missingDep,\n                      setter: maybeCall.callee.name,\n                      form: 'updater',\n                    };\n                  } else if (stateVariables.has(id)) {\n                    // setCount(count + increment)\n                    setStateRecommendation = {\n                      missingDep,\n                      setter: maybeCall.callee.name,\n                      form: 'reducer',\n                    };\n                  } else {\n                    const resolved = references[i].resolved;\n                    if (resolved != null) {\n                      // If it's a parameter *and* a missing dep,\n                      // it must be a prop or something inside a prop.\n                      // Therefore, recommend an inline reducer.\n                      const def = resolved.defs[0];\n                      if (def != null && def.type === 'Parameter') {\n                        setStateRecommendation = {\n                          missingDep,\n                          setter: maybeCall.callee.name,\n                          form: 'inlineReducer',\n                        };\n                      }\n                    }\n                  }\n                  break;\n                }\n              }\n              maybeCall = maybeCall.parent;\n            }\n            if (setStateRecommendation !== null) {\n              break;\n            }\n          }\n        });\n        if (setStateRecommendation !== null) {\n          switch (setStateRecommendation.form) {\n            case 'reducer':\n              extraWarning =\n                ` You can also replace multiple useState variables with useReducer ` +\n                `if '${setStateRecommendation.setter}' needs the ` +\n                `current value of '${setStateRecommendation.missingDep}'.`;\n              break;\n            case 'inlineReducer':\n              extraWarning =\n                ` If '${setStateRecommendation.setter}' needs the ` +\n                `current value of '${setStateRecommendation.missingDep}', ` +\n                `you can also switch to useReducer instead of useState and ` +\n                `read '${setStateRecommendation.missingDep}' in the reducer.`;\n              break;\n            case 'updater':\n              extraWarning =\n                ` You can also do a functional update '${\n                  setStateRecommendation.setter\n                }(${setStateRecommendation.missingDep.substring(\n                  0,\n                  1,\n                )} => ...)' if you only need '${\n                  setStateRecommendation.missingDep\n                }'` + ` in the '${setStateRecommendation.setter}' call.`;\n              break;\n            default:\n              throw new Error('Unknown case.');\n          }\n        }\n      }\n\n      reportProblem({\n        node: declaredDependenciesNode,\n        message:\n          `React Hook ${context.getSource(reactiveHook)} has ` +\n          // To avoid a long message, show the next actionable item.\n          (getWarningMessage(missingDependencies, 'a', 'missing', 'include') ||\n            getWarningMessage(\n              unnecessaryDependencies,\n              'an',\n              'unnecessary',\n              'exclude',\n            ) ||\n            getWarningMessage(\n              duplicateDependencies,\n              'a',\n              'duplicate',\n              'omit',\n            )) +\n          extraWarning,\n        suggest: [\n          {\n            desc: `Update the dependencies array to be: [${suggestedDeps\n              .map(formatDependency)\n              .join(', ')}]`,\n            fix(fixer) {\n              // TODO: consider preserving the comments or formatting?\n              return fixer.replaceText(\n                declaredDependenciesNode,\n                `[${suggestedDeps.map(formatDependency).join(', ')}]`,\n              );\n            },\n          },\n        ],\n      });\n    }\n\n    function visitCallExpression(node) {\n      const callbackIndex = getReactiveHookCallbackIndex(node.callee, options);\n      if (callbackIndex === -1) {\n        // Not a React Hook call that needs deps.\n        return;\n      }\n      const callback = node.arguments[callbackIndex];\n      const reactiveHook = node.callee;\n      const reactiveHookName = getNodeWithoutReactNamespace(reactiveHook).name;\n      const declaredDependenciesNode = node.arguments[callbackIndex + 1];\n      const isEffect = /Effect($|[^a-z])/g.test(reactiveHookName);\n\n      // Check the declared dependencies for this reactive hook. If there is no\n      // second argument then the reactive callback will re-run on every render.\n      // So no need to check for dependency inclusion.\n      if (!declaredDependenciesNode && !isEffect) {\n        // These are only used for optimization.\n        if (\n          reactiveHookName === 'useMemo' ||\n          reactiveHookName === 'useCallback'\n        ) {\n          // TODO: Can this have a suggestion?\n          reportProblem({\n            node: reactiveHook,\n            message:\n              `React Hook ${reactiveHookName} does nothing when called with ` +\n              `only one argument. Did you forget to pass an array of ` +\n              `dependencies?`,\n          });\n        }\n        return;\n      }\n\n      switch (callback.type) {\n        case 'FunctionExpression':\n        case 'ArrowFunctionExpression':\n          visitFunctionWithDependencies(\n            callback,\n            declaredDependenciesNode,\n            reactiveHook,\n            reactiveHookName,\n            isEffect,\n          );\n          return; // Handled\n        case 'Identifier':\n          if (!declaredDependenciesNode) {\n            // No deps, no problems.\n            return; // Handled\n          }\n          // The function passed as a callback is not written inline.\n          // But perhaps it's in the dependencies array?\n          if (\n            declaredDependenciesNode.elements &&\n            declaredDependenciesNode.elements.some(\n              el => el && el.type === 'Identifier' && el.name === callback.name,\n            )\n          ) {\n            // If it's already in the list of deps, we don't care because\n            // this is valid regardless.\n            return; // Handled\n          }\n          // We'll do our best effort to find it, complain otherwise.\n          const variable = context.getScope().set.get(callback.name);\n          if (variable == null || variable.defs == null) {\n            // If it's not in scope, we don't care.\n            return; // Handled\n          }\n          // The function passed as a callback is not written inline.\n          // But it's defined somewhere in the render scope.\n          // We'll do our best effort to find and check it, complain otherwise.\n          const def = variable.defs[0];\n          if (!def || !def.node) {\n            break; // Unhandled\n          }\n          if (def.type !== 'Variable' && def.type !== 'FunctionName') {\n            // Parameter or an unusual pattern. Bail out.\n            break; // Unhandled\n          }\n          switch (def.node.type) {\n            case 'FunctionDeclaration':\n              // useEffect(() => { ... }, []);\n              visitFunctionWithDependencies(\n                def.node,\n                declaredDependenciesNode,\n                reactiveHook,\n                reactiveHookName,\n                isEffect,\n              );\n              return; // Handled\n            case 'VariableDeclarator':\n              const init = def.node.init;\n              if (!init) {\n                break; // Unhandled\n              }\n              switch (init.type) {\n                // const effectBody = () => {...};\n                // useEffect(effectBody, []);\n                case 'ArrowFunctionExpression':\n                case 'FunctionExpression':\n                  // We can inspect this function as if it were inline.\n                  visitFunctionWithDependencies(\n                    init,\n                    declaredDependenciesNode,\n                    reactiveHook,\n                    reactiveHookName,\n                    isEffect,\n                  );\n                  return; // Handled\n              }\n              break; // Unhandled\n          }\n          break; // Unhandled\n        default:\n          // useEffect(generateEffectBody(), []);\n          reportProblem({\n            node: reactiveHook,\n            message:\n              `React Hook ${reactiveHookName} received a function whose dependencies ` +\n              `are unknown. Pass an inline function instead.`,\n          });\n          return; // Handled\n      }\n\n      // Something unusual. Fall back to suggesting to add the body itself as a dep.\n      reportProblem({\n        node: reactiveHook,\n        message:\n          `React Hook ${reactiveHookName} has a missing dependency: '${callback.name}'. ` +\n          `Either include it or remove the dependency array.`,\n        suggest: [\n          {\n            desc: `Update the dependencies array to be: [${callback.name}]`,\n            fix(fixer) {\n              return fixer.replaceText(\n                declaredDependenciesNode,\n                `[${callback.name}]`,\n              );\n            },\n          },\n        ],\n      });\n    }\n\n    return {\n      CallExpression: visitCallExpression,\n    };\n  },\n};\n\n// The meat of the logic.\nfunction collectRecommendations({\n  dependencies,\n  declaredDependencies,\n  stableDependencies,\n  externalDependencies,\n  isEffect,\n}) {\n  // Our primary data structure.\n  // It is a logical representation of property chains:\n  // `props` -> `props.foo` -> `props.foo.bar` -> `props.foo.bar.baz`\n  //         -> `props.lol`\n  //         -> `props.huh` -> `props.huh.okay`\n  //         -> `props.wow`\n  // We'll use it to mark nodes that are *used* by the programmer,\n  // and the nodes that were *declared* as deps. Then we will\n  // traverse it to learn which deps are missing or unnecessary.\n  const depTree = createDepTree();\n  function createDepTree() {\n    return {\n      isUsed: false, // True if used in code\n      isSatisfiedRecursively: false, // True if specified in deps\n      isSubtreeUsed: false, // True if something deeper is used by code\n      children: new Map(), // Nodes for properties\n    };\n  }\n\n  // Mark all required nodes first.\n  // Imagine exclamation marks next to each used deep property.\n  dependencies.forEach((_, key) => {\n    const node = getOrCreateNodeByPath(depTree, key);\n    node.isUsed = true;\n    markAllParentsByPath(depTree, key, parent => {\n      parent.isSubtreeUsed = true;\n    });\n  });\n\n  // Mark all satisfied nodes.\n  // Imagine checkmarks next to each declared dependency.\n  declaredDependencies.forEach(({key}) => {\n    const node = getOrCreateNodeByPath(depTree, key);\n    node.isSatisfiedRecursively = true;\n  });\n  stableDependencies.forEach(key => {\n    const node = getOrCreateNodeByPath(depTree, key);\n    node.isSatisfiedRecursively = true;\n  });\n\n  // Tree manipulation helpers.\n  function getOrCreateNodeByPath(rootNode, path) {\n    const keys = path.split('.');\n    let node = rootNode;\n    for (const key of keys) {\n      let child = node.children.get(key);\n      if (!child) {\n        child = createDepTree();\n        node.children.set(key, child);\n      }\n      node = child;\n    }\n    return node;\n  }\n  function markAllParentsByPath(rootNode, path, fn) {\n    const keys = path.split('.');\n    let node = rootNode;\n    for (const key of keys) {\n      const child = node.children.get(key);\n      if (!child) {\n        return;\n      }\n      fn(child);\n      node = child;\n    }\n  }\n\n  // Now we can learn which dependencies are missing or necessary.\n  const missingDependencies = new Set();\n  const satisfyingDependencies = new Set();\n  scanTreeRecursively(\n    depTree,\n    missingDependencies,\n    satisfyingDependencies,\n    key => key,\n  );\n  function scanTreeRecursively(node, missingPaths, satisfyingPaths, keyToPath) {\n    node.children.forEach((child, key) => {\n      const path = keyToPath(key);\n      if (child.isSatisfiedRecursively) {\n        if (child.isSubtreeUsed) {\n          // Remember this dep actually satisfied something.\n          satisfyingPaths.add(path);\n        }\n        // It doesn't matter if there's something deeper.\n        // It would be transitively satisfied since we assume immutability.\n        // `props.foo` is enough if you read `props.foo.id`.\n        return;\n      }\n      if (child.isUsed) {\n        // Remember that no declared deps satisfied this node.\n        missingPaths.add(path);\n        // If we got here, nothing in its subtree was satisfied.\n        // No need to search further.\n        return;\n      }\n      scanTreeRecursively(\n        child,\n        missingPaths,\n        satisfyingPaths,\n        childKey => path + '.' + childKey,\n      );\n    });\n  }\n\n  // Collect suggestions in the order they were originally specified.\n  const suggestedDependencies = [];\n  const unnecessaryDependencies = new Set();\n  const duplicateDependencies = new Set();\n  declaredDependencies.forEach(({key}) => {\n    // Does this declared dep satisfy a real need?\n    if (satisfyingDependencies.has(key)) {\n      if (suggestedDependencies.indexOf(key) === -1) {\n        // Good one.\n        suggestedDependencies.push(key);\n      } else {\n        // Duplicate.\n        duplicateDependencies.add(key);\n      }\n    } else {\n      if (\n        isEffect &&\n        !key.endsWith('.current') &&\n        !externalDependencies.has(key)\n      ) {\n        // Effects are allowed extra \"unnecessary\" deps.\n        // Such as resetting scroll when ID changes.\n        // Consider them legit.\n        // The exception is ref.current which is always wrong.\n        if (suggestedDependencies.indexOf(key) === -1) {\n          suggestedDependencies.push(key);\n        }\n      } else {\n        // It's definitely not needed.\n        unnecessaryDependencies.add(key);\n      }\n    }\n  });\n\n  // Then add the missing ones at the end.\n  missingDependencies.forEach(key => {\n    suggestedDependencies.push(key);\n  });\n\n  return {\n    suggestedDependencies,\n    unnecessaryDependencies,\n    duplicateDependencies,\n    missingDependencies,\n  };\n}\n\n// If the node will result in constructing a referentially unique value, return\n// its human readable type name, else return null.\nfunction getConstructionExpressionType(node) {\n  switch (node.type) {\n    case 'ObjectExpression':\n      return 'object';\n    case 'ArrayExpression':\n      return 'array';\n    case 'ArrowFunctionExpression':\n    case 'FunctionExpression':\n      return 'function';\n    case 'ClassExpression':\n      return 'class';\n    case 'ConditionalExpression':\n      if (\n        getConstructionExpressionType(node.consequent) != null ||\n        getConstructionExpressionType(node.alternate) != null\n      ) {\n        return 'conditional';\n      }\n      return null;\n    case 'LogicalExpression':\n      if (\n        getConstructionExpressionType(node.left) != null ||\n        getConstructionExpressionType(node.right) != null\n      ) {\n        return 'logical expression';\n      }\n      return null;\n    case 'JSXFragment':\n      return 'JSX fragment';\n    case 'JSXElement':\n      return 'JSX element';\n    case 'AssignmentExpression':\n      if (getConstructionExpressionType(node.right) != null) {\n        return 'assignment expression';\n      }\n      return null;\n    case 'NewExpression':\n      return 'object construction';\n    case 'Literal':\n      if (node.value instanceof RegExp) {\n        return 'regular expression';\n      }\n      return null;\n    case 'TypeCastExpression':\n      return getConstructionExpressionType(node.expression);\n    case 'TSAsExpression':\n      return getConstructionExpressionType(node.expression);\n  }\n  return null;\n}\n\n// Finds variables declared as dependencies\n// that would invalidate on every render.\nfunction scanForConstructions({\n  declaredDependencies,\n  declaredDependenciesNode,\n  componentScope,\n  scope,\n}) {\n  const constructions = declaredDependencies\n    .map(({key}) => {\n      const ref = componentScope.variables.find(v => v.name === key);\n      if (ref == null) {\n        return null;\n      }\n\n      const node = ref.defs[0];\n      if (node == null) {\n        return null;\n      }\n      // const handleChange = function () {}\n      // const handleChange = () => {}\n      // const foo = {}\n      // const foo = []\n      // etc.\n      if (\n        node.type === 'Variable' &&\n        node.node.type === 'VariableDeclarator' &&\n        node.node.id.type === 'Identifier' && // Ensure this is not destructed assignment\n        node.node.init != null\n      ) {\n        const constantExpressionType = getConstructionExpressionType(\n          node.node.init,\n        );\n        if (constantExpressionType != null) {\n          return [ref, constantExpressionType];\n        }\n      }\n      // function handleChange() {}\n      if (\n        node.type === 'FunctionName' &&\n        node.node.type === 'FunctionDeclaration'\n      ) {\n        return [ref, 'function'];\n      }\n\n      // class Foo {}\n      if (node.type === 'ClassName' && node.node.type === 'ClassDeclaration') {\n        return [ref, 'class'];\n      }\n      return null;\n    })\n    .filter(Boolean);\n\n  function isUsedOutsideOfHook(ref) {\n    let foundWriteExpr = false;\n    for (let i = 0; i < ref.references.length; i++) {\n      const reference = ref.references[i];\n      if (reference.writeExpr) {\n        if (foundWriteExpr) {\n          // Two writes to the same function.\n          return true;\n        } else {\n          // Ignore first write as it's not usage.\n          foundWriteExpr = true;\n          continue;\n        }\n      }\n      let currentScope = reference.from;\n      while (currentScope !== scope && currentScope != null) {\n        currentScope = currentScope.upper;\n      }\n      if (currentScope !== scope) {\n        // This reference is outside the Hook callback.\n        // It can only be legit if it's the deps array.\n        if (!isAncestorNodeOf(declaredDependenciesNode, reference.identifier)) {\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n\n  return constructions.map(([ref, depType]) => ({\n    construction: ref.defs[0],\n    depType,\n    isUsedOutsideOfHook: isUsedOutsideOfHook(ref),\n  }));\n}\n\n/**\n * Assuming () means the passed/returned node:\n * (props) => (props)\n * props.(foo) => (props.foo)\n * props.foo.(bar) => (props).foo.bar\n * props.foo.bar.(baz) => (props).foo.bar.baz\n */\nfunction getDependency(node) {\n  if (\n    (node.parent.type === 'MemberExpression' ||\n      node.parent.type === 'OptionalMemberExpression') &&\n    node.parent.object === node &&\n    node.parent.property.name !== 'current' &&\n    !node.parent.computed &&\n    !(\n      node.parent.parent != null &&\n      (node.parent.parent.type === 'CallExpression' ||\n        node.parent.parent.type === 'OptionalCallExpression') &&\n      node.parent.parent.callee === node.parent\n    )\n  ) {\n    return getDependency(node.parent);\n  } else if (\n    // Note: we don't check OptionalMemberExpression because it can't be LHS.\n    node.type === 'MemberExpression' &&\n    node.parent &&\n    node.parent.type === 'AssignmentExpression' &&\n    node.parent.left === node\n  ) {\n    return node.object;\n  } else {\n    return node;\n  }\n}\n\n/**\n * Mark a node as either optional or required.\n * Note: If the node argument is an OptionalMemberExpression, it doesn't necessarily mean it is optional.\n * It just means there is an optional member somewhere inside.\n * This particular node might still represent a required member, so check .optional field.\n */\nfunction markNode(node, optionalChains, result) {\n  if (optionalChains) {\n    if (node.optional) {\n      // We only want to consider it optional if *all* usages were optional.\n      if (!optionalChains.has(result)) {\n        // Mark as (maybe) optional. If there's a required usage, this will be overridden.\n        optionalChains.set(result, true);\n      }\n    } else {\n      // Mark as required.\n      optionalChains.set(result, false);\n    }\n  }\n}\n\n/**\n * Assuming () means the passed node.\n * (foo) -> 'foo'\n * foo(.)bar -> 'foo.bar'\n * foo.bar(.)baz -> 'foo.bar.baz'\n * Otherwise throw.\n */\nfunction analyzePropertyChain(node, optionalChains) {\n  if (node.type === 'Identifier' || node.type === 'JSXIdentifier') {\n    const result = node.name;\n    if (optionalChains) {\n      // Mark as required.\n      optionalChains.set(result, false);\n    }\n    return result;\n  } else if (node.type === 'MemberExpression' && !node.computed) {\n    const object = analyzePropertyChain(node.object, optionalChains);\n    const property = analyzePropertyChain(node.property, null);\n    const result = `${object}.${property}`;\n    markNode(node, optionalChains, result);\n    return result;\n  } else if (node.type === 'OptionalMemberExpression' && !node.computed) {\n    const object = analyzePropertyChain(node.object, optionalChains);\n    const property = analyzePropertyChain(node.property, null);\n    const result = `${object}.${property}`;\n    markNode(node, optionalChains, result);\n    return result;\n  } else if (node.type === 'ChainExpression' && !node.computed) {\n    const expression = node.expression;\n    const object = analyzePropertyChain(expression.object, optionalChains);\n    const property = analyzePropertyChain(expression.property, null);\n    const result = `${object}.${property}`;\n    markNode(expression, optionalChains, result);\n    return result;\n  } else {\n    throw new Error(`Unsupported node type: ${node.type}`);\n  }\n}\n\nfunction getNodeWithoutReactNamespace(node, options) {\n  if (\n    node.type === 'MemberExpression' &&\n    node.object.type === 'Identifier' &&\n    node.object.name === 'React' &&\n    node.property.type === 'Identifier' &&\n    !node.computed\n  ) {\n    return node.property;\n  }\n  return node;\n}\n\n// What's the index of callback that needs to be analyzed for a given Hook?\n// -1 if it's not a Hook we care about (e.g. useState).\n// 0 for useEffect/useMemo/useCallback(fn).\n// 1 for useImperativeHandle(ref, fn).\n// For additionally configured Hooks, assume that they're like useEffect (0).\nfunction getReactiveHookCallbackIndex(calleeNode, options) {\n  const node = getNodeWithoutReactNamespace(calleeNode);\n  if (node.type !== 'Identifier') {\n    return -1;\n  }\n  switch (node.name) {\n    case 'useEffect':\n    case 'useLayoutEffect':\n    case 'useCallback':\n    case 'useMemo':\n      // useEffect(fn)\n      return 0;\n    case 'useImperativeHandle':\n      // useImperativeHandle(ref, fn)\n      return 1;\n    default:\n      if (node === calleeNode && options && options.additionalHooks) {\n        // Allow the user to provide a regular expression which enables the lint to\n        // target custom reactive hooks.\n        let name;\n        try {\n          name = analyzePropertyChain(node, null);\n        } catch (error) {\n          if (/Unsupported node type/.test(error.message)) {\n            return 0;\n          } else {\n            throw error;\n          }\n        }\n        return options.additionalHooks.test(name) ? 0 : -1;\n      } else {\n        return -1;\n      }\n  }\n}\n\n/**\n * ESLint won't assign node.parent to references from context.getScope()\n *\n * So instead we search for the node from an ancestor assigning node.parent\n * as we go. This mutates the AST.\n *\n * This traversal is:\n * - optimized by only searching nodes with a range surrounding our target node\n * - agnostic to AST node types, it looks for `{ type: string, ... }`\n */\nfunction fastFindReferenceWithParent(start, target) {\n  const queue = [start];\n  let item = null;\n\n  while (queue.length) {\n    item = queue.shift();\n\n    if (isSameIdentifier(item, target)) {\n      return item;\n    }\n\n    if (!isAncestorNodeOf(item, target)) {\n      continue;\n    }\n\n    for (const [key, value] of Object.entries(item)) {\n      if (key === 'parent') {\n        continue;\n      }\n      if (isNodeLike(value)) {\n        value.parent = item;\n        queue.push(value);\n      } else if (Array.isArray(value)) {\n        value.forEach(val => {\n          if (isNodeLike(val)) {\n            val.parent = item;\n            queue.push(val);\n          }\n        });\n      }\n    }\n  }\n\n  return null;\n}\n\nfunction joinEnglish(arr) {\n  let s = '';\n  for (let i = 0; i < arr.length; i++) {\n    s += arr[i];\n    if (i === 0 && arr.length === 2) {\n      s += ' and ';\n    } else if (i === arr.length - 2 && arr.length > 2) {\n      s += ', and ';\n    } else if (i < arr.length - 1) {\n      s += ', ';\n    }\n  }\n  return s;\n}\n\nfunction isNodeLike(val) {\n  return (\n    typeof val === 'object' &&\n    val !== null &&\n    !Array.isArray(val) &&\n    typeof val.type === 'string'\n  );\n}\n\nfunction isSameIdentifier(a, b) {\n  return (\n    (a.type === 'Identifier' || a.type === 'JSXIdentifier') &&\n    a.type === b.type &&\n    a.name === b.name &&\n    a.range[0] === b.range[0] &&\n    a.range[1] === b.range[1]\n  );\n}\n\nfunction isAncestorNodeOf(a, b) {\n  return a.range[0] <= b.range[0] && a.range[1] >= b.range[1];\n}\n","/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n'use strict';\n\nimport RulesOfHooks from './RulesOfHooks';\nimport ExhaustiveDeps from './ExhaustiveDeps';\n\nexport const configs = {\n  recommended: {\n    plugins: ['react-hooks'],\n    rules: {\n      'react-hooks/rules-of-hooks': 'error',\n      'react-hooks/exhaustive-deps': 'warn',\n    },\n  },\n};\n\nexport const rules = {\n  'rules-of-hooks': RulesOfHooks,\n  'exhaustive-deps': ExhaustiveDeps,\n};\n"],"names":["isHookName","s","test","isHook","node","type","name","computed","property","obj","object","isPascalCaseNameSpace","isComponentName","isReactFunction","functionName","isForwardRefCallback","parent","callee","isMemoCallback","isInsideComponentOrHook","getFunctionName","meta","docs","description","category","recommended","url","create","context","codePathReactHooksMapStack","codePathSegmentStack","onCodePathSegmentStart","segment","push","onCodePathSegmentEnd","pop","onCodePathStart","Map","onCodePathEnd","codePath","codePathNode","reactHooksMap","size","cyclic","Set","countPathsFromStart","pathHistory","cache","paths","get","id","pathList","has","pathArray","cyclicSegments","slice","indexOf","cyclicSegment","add","undefined","thrownSegments","includes","prevSegments","length","prevSegment","reachable","delete","set","countPathsToEnd","Array","from","nextSegments","nextSegment","shortestPathLengthToStart","Infinity","prevLength","allPathsFromStartToEnd","initialSegment","codePathFunctionName","isSomewhereInsideComponentOrHook","isDirectlyInsideComponentOrHook","shortestFinalPathLength","finalSegments","finalSegment","reactHooks","possiblyHasEarlyReturn","pathsFromStartToEnd","cycled","hook","report","message","getSource","value","CallExpression","last","codePathSegment","init","right","operator","left","key","array","fixable","schema","additionalProperties","enableDangerousAutofixThisMayCauseInfiniteLoops","properties","additionalHooks","options","RegExp","reportProblem","problem","isArray","suggest","fix","scopeManager","getSourceCode","setStateCallSites","WeakMap","stateVariables","WeakSet","stableKnownValueCache","functionWithoutCapturedValueCache","memoizeWithWeakMap","fn","map","arg","result","visitFunctionWithDependencies","declaredDependenciesNode","reactiveHook","reactiveHookName","isEffect","async","scope","acquire","pureScopes","componentScope","currentScope","upper","isStableKnownHookValue","resolved","defs","def","expression","declaration","fastFindReferenceWithParent","block","kind","elements","identifiers","references","i","identifier","isFunctionWithoutCapturedValues","fnNode","childScopes","fnScope","childScope","childScopeBlock","through","ref","memoizedIsStablecKnownHookValue","memoizedIsFunctionWithoutCapturedValues","currentRefsInEffectCleanup","isInsideEffectCleanup","reference","curScope","isInReturnedFunction","dependencies","optionalChains","gatherDependenciesRecursively","referenceNode","dependencyNode","getDependency","dependency","analyzePropertyChain","isStable","forEach","foundCurrentAssignment","staleAssignments","reportStaleAssignment","writeExpr","stableDependencies","setStateInsideEffectWithoutDeps","isSetState","isDirectlyInsideEffect","collectRecommendations","declaredDependencies","externalDependencies","suggestedDependencies","join","desc","fixer","insertTextAfter","declaredDependencyNode","declaredDependency","error","raw","maybeID","isDeclaredInComponent","some","unnecessaryDependencies","missingDependencies","duplicateDependencies","suggestedDeps","problemCount","constructions","scanForConstructions","construction","isUsedOutsideOfHook","depType","wrapperHook","constructionType","defaultAdvice","advice","causation","loc","start","line","before","after","insertTextBefore","areDeclaredDepsAlphabetized","declaredDepKeys","dep","sortedDeclaredDepKeys","sort","formatDependency","path","members","split","finalPath","pathSoFar","isOptional","getWarningMessage","deps","singlePrefix","label","fixVerb","joinEnglish","extraWarning","badRef","keys","endsWith","propDep","refs","isPropsOnlyUsedInMembers","missingCallbackDep","missingDep","topScopeRef","usedDep","isFunctionCall","setStateRecommendation","maybeCall","correspondingStateVariable","setter","form","substring","Error","replaceText","visitCallExpression","callbackIndex","getReactiveHookCallbackIndex","callback","arguments","getNodeWithoutReactNamespace","el","variable","getScope","depTree","createDepTree","isUsed","isSatisfiedRecursively","isSubtreeUsed","children","_","getOrCreateNodeByPath","markAllParentsByPath","rootNode","child","satisfyingDependencies","scanTreeRecursively","missingPaths","satisfyingPaths","keyToPath","childKey","getConstructionExpressionType","consequent","alternate","variables","find","v","constantExpressionType","filter","Boolean","foundWriteExpr","isAncestorNodeOf","markNode","optional","calleeNode","target","queue","item","shift","isSameIdentifier","Object","entries","isNodeLike","val","arr","a","b","range","configs","plugins","rules","RulesOfHooks","ExhaustiveDeps"],"mappings":"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"}