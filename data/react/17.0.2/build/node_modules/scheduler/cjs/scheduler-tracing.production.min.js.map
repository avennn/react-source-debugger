{"version":3,"file":"scheduler-tracing.production.min.js","sources":["../../../../packages/scheduler/src/Tracing.js","../../../../packages/scheduler/src/TracingSubscriptions.js"],"sourcesContent":["/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\nimport {enableSchedulerTracing} from 'shared/ReactFeatureFlags';\n\nexport type Interaction = {|\n  __count: number,\n  id: number,\n  name: string,\n  timestamp: number,\n|};\n\nexport type Subscriber = {\n  // A new interaction has been created via the trace() method.\n  onInteractionTraced: (interaction: Interaction) => void,\n\n  // All scheduled async work for an interaction has finished.\n  onInteractionScheduledWorkCompleted: (interaction: Interaction) => void,\n\n  // New async work has been scheduled for a set of interactions.\n  // When this work is later run, onWorkStarted/onWorkStopped will be called.\n  // A batch of async/yieldy work may be scheduled multiple times before completing.\n  // In that case, onWorkScheduled may be called more than once before onWorkStopped.\n  // Work is scheduled by a \"thread\" which is identified by a unique ID.\n  onWorkScheduled: (interactions: Set<Interaction>, threadID: number) => void,\n\n  // A batch of scheduled work has been canceled.\n  // Work is done by a \"thread\" which is identified by a unique ID.\n  onWorkCanceled: (interactions: Set<Interaction>, threadID: number) => void,\n\n  // A batch of work has started for a set of interactions.\n  // When this work is complete, onWorkStopped will be called.\n  // Work is not always completed synchronously; yielding may occur in between.\n  // A batch of async/yieldy work may also be re-started before completing.\n  // In that case, onWorkStarted may be called more than once before onWorkStopped.\n  // Work is done by a \"thread\" which is identified by a unique ID.\n  onWorkStarted: (interactions: Set<Interaction>, threadID: number) => void,\n\n  // A batch of work has completed for a set of interactions.\n  // Work is done by a \"thread\" which is identified by a unique ID.\n  onWorkStopped: (interactions: Set<Interaction>, threadID: number) => void,\n  ...\n};\n\nexport type InteractionsRef = {|current: Set<Interaction>|};\n\nexport type SubscriberRef = {|current: Subscriber | null|};\n\nconst DEFAULT_THREAD_ID = 0;\n\n// Counters used to generate unique IDs.\nlet interactionIDCounter: number = 0;\nlet threadIDCounter: number = 0;\n\n// Set of currently traced interactions.\n// Interactions \"stack\"–\n// Meaning that newly traced interactions are appended to the previously active set.\n// When an interaction goes out of scope, the previous set (if any) is restored.\nlet interactionsRef: InteractionsRef = (null: any);\n\n// Listener(s) to notify when interactions begin and end.\nlet subscriberRef: SubscriberRef = (null: any);\n\nif (enableSchedulerTracing) {\n  interactionsRef = {\n    current: new Set(),\n  };\n  subscriberRef = {\n    current: null,\n  };\n}\n\nexport {interactionsRef as __interactionsRef, subscriberRef as __subscriberRef};\n\nexport function unstable_clear(callback: Function): any {\n  if (!enableSchedulerTracing) {\n    return callback();\n  }\n\n  const prevInteractions = interactionsRef.current;\n  interactionsRef.current = new Set();\n\n  try {\n    return callback();\n  } finally {\n    interactionsRef.current = prevInteractions;\n  }\n}\n\nexport function unstable_getCurrent(): Set<Interaction> | null {\n  if (!enableSchedulerTracing) {\n    return null;\n  } else {\n    return interactionsRef.current;\n  }\n}\n\nexport function unstable_getThreadID(): number {\n  return ++threadIDCounter;\n}\n\nexport function unstable_trace(\n  name: string,\n  timestamp: number,\n  callback: Function,\n  threadID: number = DEFAULT_THREAD_ID,\n): any {\n  if (!enableSchedulerTracing) {\n    return callback();\n  }\n\n  const interaction: Interaction = {\n    __count: 1,\n    id: interactionIDCounter++,\n    name,\n    timestamp,\n  };\n\n  const prevInteractions = interactionsRef.current;\n\n  // Traced interactions should stack/accumulate.\n  // To do that, clone the current interactions.\n  // The previous set will be restored upon completion.\n  const interactions = new Set(prevInteractions);\n  interactions.add(interaction);\n  interactionsRef.current = interactions;\n\n  const subscriber = subscriberRef.current;\n  let returnValue;\n\n  try {\n    if (subscriber !== null) {\n      subscriber.onInteractionTraced(interaction);\n    }\n  } finally {\n    try {\n      if (subscriber !== null) {\n        subscriber.onWorkStarted(interactions, threadID);\n      }\n    } finally {\n      try {\n        returnValue = callback();\n      } finally {\n        interactionsRef.current = prevInteractions;\n\n        try {\n          if (subscriber !== null) {\n            subscriber.onWorkStopped(interactions, threadID);\n          }\n        } finally {\n          interaction.__count--;\n\n          // If no async work was scheduled for this interaction,\n          // Notify subscribers that it's completed.\n          if (subscriber !== null && interaction.__count === 0) {\n            subscriber.onInteractionScheduledWorkCompleted(interaction);\n          }\n        }\n      }\n    }\n  }\n\n  return returnValue;\n}\n\nexport function unstable_wrap(\n  callback: Function,\n  threadID: number = DEFAULT_THREAD_ID,\n): Function {\n  if (!enableSchedulerTracing) {\n    return callback;\n  }\n\n  const wrappedInteractions = interactionsRef.current;\n\n  let subscriber = subscriberRef.current;\n  if (subscriber !== null) {\n    subscriber.onWorkScheduled(wrappedInteractions, threadID);\n  }\n\n  // Update the pending async work count for the current interactions.\n  // Update after calling subscribers in case of error.\n  wrappedInteractions.forEach(interaction => {\n    interaction.__count++;\n  });\n\n  let hasRun = false;\n\n  function wrapped() {\n    const prevInteractions = interactionsRef.current;\n    interactionsRef.current = wrappedInteractions;\n\n    subscriber = subscriberRef.current;\n\n    try {\n      let returnValue;\n\n      try {\n        if (subscriber !== null) {\n          subscriber.onWorkStarted(wrappedInteractions, threadID);\n        }\n      } finally {\n        try {\n          returnValue = callback.apply(undefined, arguments);\n        } finally {\n          interactionsRef.current = prevInteractions;\n\n          if (subscriber !== null) {\n            subscriber.onWorkStopped(wrappedInteractions, threadID);\n          }\n        }\n      }\n\n      return returnValue;\n    } finally {\n      if (!hasRun) {\n        // We only expect a wrapped function to be executed once,\n        // But in the event that it's executed more than once–\n        // Only decrement the outstanding interaction counts once.\n        hasRun = true;\n\n        // Update pending async counts for all wrapped interactions.\n        // If this was the last scheduled async work for any of them,\n        // Mark them as completed.\n        wrappedInteractions.forEach(interaction => {\n          interaction.__count--;\n\n          if (subscriber !== null && interaction.__count === 0) {\n            subscriber.onInteractionScheduledWorkCompleted(interaction);\n          }\n        });\n      }\n    }\n  }\n\n  wrapped.cancel = function cancel() {\n    subscriber = subscriberRef.current;\n\n    try {\n      if (subscriber !== null) {\n        subscriber.onWorkCanceled(wrappedInteractions, threadID);\n      }\n    } finally {\n      // Update pending async counts for all wrapped interactions.\n      // If this was the last scheduled async work for any of them,\n      // Mark them as completed.\n      wrappedInteractions.forEach(interaction => {\n        interaction.__count--;\n\n        if (subscriber && interaction.__count === 0) {\n          subscriber.onInteractionScheduledWorkCompleted(interaction);\n        }\n      });\n    }\n  };\n\n  return wrapped;\n}\n","/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\nimport type {Interaction, Subscriber} from './Tracing';\n\nimport {enableSchedulerTracing} from 'shared/ReactFeatureFlags';\nimport {__subscriberRef} from './Tracing';\n\nlet subscribers: Set<Subscriber> = (null: any);\nif (enableSchedulerTracing) {\n  subscribers = new Set();\n}\n\nexport function unstable_subscribe(subscriber: Subscriber): void {\n  if (enableSchedulerTracing) {\n    subscribers.add(subscriber);\n\n    if (subscribers.size === 1) {\n      __subscriberRef.current = {\n        onInteractionScheduledWorkCompleted,\n        onInteractionTraced,\n        onWorkCanceled,\n        onWorkScheduled,\n        onWorkStarted,\n        onWorkStopped,\n      };\n    }\n  }\n}\n\nexport function unstable_unsubscribe(subscriber: Subscriber): void {\n  if (enableSchedulerTracing) {\n    subscribers.delete(subscriber);\n\n    if (subscribers.size === 0) {\n      __subscriberRef.current = null;\n    }\n  }\n}\n\nfunction onInteractionTraced(interaction: Interaction): void {\n  let didCatchError = false;\n  let caughtError = null;\n\n  subscribers.forEach(subscriber => {\n    try {\n      subscriber.onInteractionTraced(interaction);\n    } catch (error) {\n      if (!didCatchError) {\n        didCatchError = true;\n        caughtError = error;\n      }\n    }\n  });\n\n  if (didCatchError) {\n    throw caughtError;\n  }\n}\n\nfunction onInteractionScheduledWorkCompleted(interaction: Interaction): void {\n  let didCatchError = false;\n  let caughtError = null;\n\n  subscribers.forEach(subscriber => {\n    try {\n      subscriber.onInteractionScheduledWorkCompleted(interaction);\n    } catch (error) {\n      if (!didCatchError) {\n        didCatchError = true;\n        caughtError = error;\n      }\n    }\n  });\n\n  if (didCatchError) {\n    throw caughtError;\n  }\n}\n\nfunction onWorkScheduled(\n  interactions: Set<Interaction>,\n  threadID: number,\n): void {\n  let didCatchError = false;\n  let caughtError = null;\n\n  subscribers.forEach(subscriber => {\n    try {\n      subscriber.onWorkScheduled(interactions, threadID);\n    } catch (error) {\n      if (!didCatchError) {\n        didCatchError = true;\n        caughtError = error;\n      }\n    }\n  });\n\n  if (didCatchError) {\n    throw caughtError;\n  }\n}\n\nfunction onWorkStarted(interactions: Set<Interaction>, threadID: number): void {\n  let didCatchError = false;\n  let caughtError = null;\n\n  subscribers.forEach(subscriber => {\n    try {\n      subscriber.onWorkStarted(interactions, threadID);\n    } catch (error) {\n      if (!didCatchError) {\n        didCatchError = true;\n        caughtError = error;\n      }\n    }\n  });\n\n  if (didCatchError) {\n    throw caughtError;\n  }\n}\n\nfunction onWorkStopped(interactions: Set<Interaction>, threadID: number): void {\n  let didCatchError = false;\n  let caughtError = null;\n\n  subscribers.forEach(subscriber => {\n    try {\n      subscriber.onWorkStopped(interactions, threadID);\n    } catch (error) {\n      if (!didCatchError) {\n        didCatchError = true;\n        caughtError = error;\n      }\n    }\n  });\n\n  if (didCatchError) {\n    throw caughtError;\n  }\n}\n\nfunction onWorkCanceled(\n  interactions: Set<Interaction>,\n  threadID: number,\n): void {\n  let didCatchError = false;\n  let caughtError = null;\n\n  subscribers.forEach(subscriber => {\n    try {\n      subscriber.onWorkCanceled(interactions, threadID);\n    } catch (error) {\n      if (!didCatchError) {\n        didCatchError = true;\n        caughtError = error;\n      }\n    }\n  });\n\n  if (didCatchError) {\n    throw caughtError;\n  }\n}\n"],"names":["threadIDCounter","interactionsRef","subscriberRef","unstable_clear","callback","unstable_getCurrent","unstable_getThreadID","unstable_trace","name","timestamp","unstable_wrap","unstable_subscribe","subscriber","unstable_unsubscribe"],"mappings":";;AA0DA,IAAIA,eAAuB,GAAG,CAA9B;AAGA;AACA;AACA;;IACIC,eAAgC,GAAI;;IAGpCC,aAA4B,GAAI;AAa7B,SAASC,cAAT,CAAwBC,QAAxB,EAAiD;AACtD,EAA6B;AAC3B,WAAOA,QAAQ,EAAf;AACD;AAUF;AAEM,SAASC,mBAAT,GAAwD;AAC7D,EAA6B;AAC3B,WAAO,IAAP;AACD;AAGF;AAEM,SAASC,oBAAT,GAAwC;AAC7C,SAAO,EAAEN,eAAT;AACD;AAEM,SAASO,cAAT,CACLC,IADK,EAELC,SAFK,EAGLL,QAHK,EAKA;;AACL,EAA6B;AAC3B,WAAOA,QAAQ,EAAf;AACD;AAsDF;AAEM,SAASM,aAAT,CACLN,QADK,EAGK;;AACV,EAA6B;AAC3B,WAAOA,QAAP;AACD;AAsFF;;ACpPM,SAASO,kBAAT,CAA4BC,UAA5B,EAA0D;AAC/D,AAcD;AAED,AAAO,SAASC,oBAAT,CAA8BD,UAA9B,EAA4D;AACjE,AAOD;;;;;;;;;;;;"}