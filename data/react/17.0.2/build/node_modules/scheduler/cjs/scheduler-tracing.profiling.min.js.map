{"version":3,"file":"scheduler-tracing.profiling.min.js","sources":["../../../../packages/scheduler/src/Tracing.js","../../../../packages/scheduler/src/TracingSubscriptions.js"],"sourcesContent":["/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\nimport {enableSchedulerTracing} from 'shared/ReactFeatureFlags';\n\nexport type Interaction = {|\n  __count: number,\n  id: number,\n  name: string,\n  timestamp: number,\n|};\n\nexport type Subscriber = {\n  // A new interaction has been created via the trace() method.\n  onInteractionTraced: (interaction: Interaction) => void,\n\n  // All scheduled async work for an interaction has finished.\n  onInteractionScheduledWorkCompleted: (interaction: Interaction) => void,\n\n  // New async work has been scheduled for a set of interactions.\n  // When this work is later run, onWorkStarted/onWorkStopped will be called.\n  // A batch of async/yieldy work may be scheduled multiple times before completing.\n  // In that case, onWorkScheduled may be called more than once before onWorkStopped.\n  // Work is scheduled by a \"thread\" which is identified by a unique ID.\n  onWorkScheduled: (interactions: Set<Interaction>, threadID: number) => void,\n\n  // A batch of scheduled work has been canceled.\n  // Work is done by a \"thread\" which is identified by a unique ID.\n  onWorkCanceled: (interactions: Set<Interaction>, threadID: number) => void,\n\n  // A batch of work has started for a set of interactions.\n  // When this work is complete, onWorkStopped will be called.\n  // Work is not always completed synchronously; yielding may occur in between.\n  // A batch of async/yieldy work may also be re-started before completing.\n  // In that case, onWorkStarted may be called more than once before onWorkStopped.\n  // Work is done by a \"thread\" which is identified by a unique ID.\n  onWorkStarted: (interactions: Set<Interaction>, threadID: number) => void,\n\n  // A batch of work has completed for a set of interactions.\n  // Work is done by a \"thread\" which is identified by a unique ID.\n  onWorkStopped: (interactions: Set<Interaction>, threadID: number) => void,\n  ...\n};\n\nexport type InteractionsRef = {|current: Set<Interaction>|};\n\nexport type SubscriberRef = {|current: Subscriber | null|};\n\nconst DEFAULT_THREAD_ID = 0;\n\n// Counters used to generate unique IDs.\nlet interactionIDCounter: number = 0;\nlet threadIDCounter: number = 0;\n\n// Set of currently traced interactions.\n// Interactions \"stack\"–\n// Meaning that newly traced interactions are appended to the previously active set.\n// When an interaction goes out of scope, the previous set (if any) is restored.\nlet interactionsRef: InteractionsRef = (null: any);\n\n// Listener(s) to notify when interactions begin and end.\nlet subscriberRef: SubscriberRef = (null: any);\n\nif (enableSchedulerTracing) {\n  interactionsRef = {\n    current: new Set(),\n  };\n  subscriberRef = {\n    current: null,\n  };\n}\n\nexport {interactionsRef as __interactionsRef, subscriberRef as __subscriberRef};\n\nexport function unstable_clear(callback: Function): any {\n  if (!enableSchedulerTracing) {\n    return callback();\n  }\n\n  const prevInteractions = interactionsRef.current;\n  interactionsRef.current = new Set();\n\n  try {\n    return callback();\n  } finally {\n    interactionsRef.current = prevInteractions;\n  }\n}\n\nexport function unstable_getCurrent(): Set<Interaction> | null {\n  if (!enableSchedulerTracing) {\n    return null;\n  } else {\n    return interactionsRef.current;\n  }\n}\n\nexport function unstable_getThreadID(): number {\n  return ++threadIDCounter;\n}\n\nexport function unstable_trace(\n  name: string,\n  timestamp: number,\n  callback: Function,\n  threadID: number = DEFAULT_THREAD_ID,\n): any {\n  if (!enableSchedulerTracing) {\n    return callback();\n  }\n\n  const interaction: Interaction = {\n    __count: 1,\n    id: interactionIDCounter++,\n    name,\n    timestamp,\n  };\n\n  const prevInteractions = interactionsRef.current;\n\n  // Traced interactions should stack/accumulate.\n  // To do that, clone the current interactions.\n  // The previous set will be restored upon completion.\n  const interactions = new Set(prevInteractions);\n  interactions.add(interaction);\n  interactionsRef.current = interactions;\n\n  const subscriber = subscriberRef.current;\n  let returnValue;\n\n  try {\n    if (subscriber !== null) {\n      subscriber.onInteractionTraced(interaction);\n    }\n  } finally {\n    try {\n      if (subscriber !== null) {\n        subscriber.onWorkStarted(interactions, threadID);\n      }\n    } finally {\n      try {\n        returnValue = callback();\n      } finally {\n        interactionsRef.current = prevInteractions;\n\n        try {\n          if (subscriber !== null) {\n            subscriber.onWorkStopped(interactions, threadID);\n          }\n        } finally {\n          interaction.__count--;\n\n          // If no async work was scheduled for this interaction,\n          // Notify subscribers that it's completed.\n          if (subscriber !== null && interaction.__count === 0) {\n            subscriber.onInteractionScheduledWorkCompleted(interaction);\n          }\n        }\n      }\n    }\n  }\n\n  return returnValue;\n}\n\nexport function unstable_wrap(\n  callback: Function,\n  threadID: number = DEFAULT_THREAD_ID,\n): Function {\n  if (!enableSchedulerTracing) {\n    return callback;\n  }\n\n  const wrappedInteractions = interactionsRef.current;\n\n  let subscriber = subscriberRef.current;\n  if (subscriber !== null) {\n    subscriber.onWorkScheduled(wrappedInteractions, threadID);\n  }\n\n  // Update the pending async work count for the current interactions.\n  // Update after calling subscribers in case of error.\n  wrappedInteractions.forEach(interaction => {\n    interaction.__count++;\n  });\n\n  let hasRun = false;\n\n  function wrapped() {\n    const prevInteractions = interactionsRef.current;\n    interactionsRef.current = wrappedInteractions;\n\n    subscriber = subscriberRef.current;\n\n    try {\n      let returnValue;\n\n      try {\n        if (subscriber !== null) {\n          subscriber.onWorkStarted(wrappedInteractions, threadID);\n        }\n      } finally {\n        try {\n          returnValue = callback.apply(undefined, arguments);\n        } finally {\n          interactionsRef.current = prevInteractions;\n\n          if (subscriber !== null) {\n            subscriber.onWorkStopped(wrappedInteractions, threadID);\n          }\n        }\n      }\n\n      return returnValue;\n    } finally {\n      if (!hasRun) {\n        // We only expect a wrapped function to be executed once,\n        // But in the event that it's executed more than once–\n        // Only decrement the outstanding interaction counts once.\n        hasRun = true;\n\n        // Update pending async counts for all wrapped interactions.\n        // If this was the last scheduled async work for any of them,\n        // Mark them as completed.\n        wrappedInteractions.forEach(interaction => {\n          interaction.__count--;\n\n          if (subscriber !== null && interaction.__count === 0) {\n            subscriber.onInteractionScheduledWorkCompleted(interaction);\n          }\n        });\n      }\n    }\n  }\n\n  wrapped.cancel = function cancel() {\n    subscriber = subscriberRef.current;\n\n    try {\n      if (subscriber !== null) {\n        subscriber.onWorkCanceled(wrappedInteractions, threadID);\n      }\n    } finally {\n      // Update pending async counts for all wrapped interactions.\n      // If this was the last scheduled async work for any of them,\n      // Mark them as completed.\n      wrappedInteractions.forEach(interaction => {\n        interaction.__count--;\n\n        if (subscriber && interaction.__count === 0) {\n          subscriber.onInteractionScheduledWorkCompleted(interaction);\n        }\n      });\n    }\n  };\n\n  return wrapped;\n}\n","/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\nimport type {Interaction, Subscriber} from './Tracing';\n\nimport {enableSchedulerTracing} from 'shared/ReactFeatureFlags';\nimport {__subscriberRef} from './Tracing';\n\nlet subscribers: Set<Subscriber> = (null: any);\nif (enableSchedulerTracing) {\n  subscribers = new Set();\n}\n\nexport function unstable_subscribe(subscriber: Subscriber): void {\n  if (enableSchedulerTracing) {\n    subscribers.add(subscriber);\n\n    if (subscribers.size === 1) {\n      __subscriberRef.current = {\n        onInteractionScheduledWorkCompleted,\n        onInteractionTraced,\n        onWorkCanceled,\n        onWorkScheduled,\n        onWorkStarted,\n        onWorkStopped,\n      };\n    }\n  }\n}\n\nexport function unstable_unsubscribe(subscriber: Subscriber): void {\n  if (enableSchedulerTracing) {\n    subscribers.delete(subscriber);\n\n    if (subscribers.size === 0) {\n      __subscriberRef.current = null;\n    }\n  }\n}\n\nfunction onInteractionTraced(interaction: Interaction): void {\n  let didCatchError = false;\n  let caughtError = null;\n\n  subscribers.forEach(subscriber => {\n    try {\n      subscriber.onInteractionTraced(interaction);\n    } catch (error) {\n      if (!didCatchError) {\n        didCatchError = true;\n        caughtError = error;\n      }\n    }\n  });\n\n  if (didCatchError) {\n    throw caughtError;\n  }\n}\n\nfunction onInteractionScheduledWorkCompleted(interaction: Interaction): void {\n  let didCatchError = false;\n  let caughtError = null;\n\n  subscribers.forEach(subscriber => {\n    try {\n      subscriber.onInteractionScheduledWorkCompleted(interaction);\n    } catch (error) {\n      if (!didCatchError) {\n        didCatchError = true;\n        caughtError = error;\n      }\n    }\n  });\n\n  if (didCatchError) {\n    throw caughtError;\n  }\n}\n\nfunction onWorkScheduled(\n  interactions: Set<Interaction>,\n  threadID: number,\n): void {\n  let didCatchError = false;\n  let caughtError = null;\n\n  subscribers.forEach(subscriber => {\n    try {\n      subscriber.onWorkScheduled(interactions, threadID);\n    } catch (error) {\n      if (!didCatchError) {\n        didCatchError = true;\n        caughtError = error;\n      }\n    }\n  });\n\n  if (didCatchError) {\n    throw caughtError;\n  }\n}\n\nfunction onWorkStarted(interactions: Set<Interaction>, threadID: number): void {\n  let didCatchError = false;\n  let caughtError = null;\n\n  subscribers.forEach(subscriber => {\n    try {\n      subscriber.onWorkStarted(interactions, threadID);\n    } catch (error) {\n      if (!didCatchError) {\n        didCatchError = true;\n        caughtError = error;\n      }\n    }\n  });\n\n  if (didCatchError) {\n    throw caughtError;\n  }\n}\n\nfunction onWorkStopped(interactions: Set<Interaction>, threadID: number): void {\n  let didCatchError = false;\n  let caughtError = null;\n\n  subscribers.forEach(subscriber => {\n    try {\n      subscriber.onWorkStopped(interactions, threadID);\n    } catch (error) {\n      if (!didCatchError) {\n        didCatchError = true;\n        caughtError = error;\n      }\n    }\n  });\n\n  if (didCatchError) {\n    throw caughtError;\n  }\n}\n\nfunction onWorkCanceled(\n  interactions: Set<Interaction>,\n  threadID: number,\n): void {\n  let didCatchError = false;\n  let caughtError = null;\n\n  subscribers.forEach(subscriber => {\n    try {\n      subscriber.onWorkCanceled(interactions, threadID);\n    } catch (error) {\n      if (!didCatchError) {\n        didCatchError = true;\n        caughtError = error;\n      }\n    }\n  });\n\n  if (didCatchError) {\n    throw caughtError;\n  }\n}\n"],"names":["DEFAULT_THREAD_ID","interactionIDCounter","threadIDCounter","interactionsRef","subscriberRef","current","Set","unstable_clear","callback","prevInteractions","unstable_getCurrent","unstable_getThreadID","unstable_trace","name","timestamp","threadID","interaction","__count","id","interactions","add","subscriber","returnValue","onInteractionTraced","onWorkStarted","onWorkStopped","onInteractionScheduledWorkCompleted","unstable_wrap","wrappedInteractions","onWorkScheduled","forEach","hasRun","wrapped","apply","undefined","arguments","cancel","onWorkCanceled","subscribers","unstable_subscribe","size","__subscriberRef","unstable_unsubscribe","delete","didCatchError","caughtError","error"],"mappings":"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"}