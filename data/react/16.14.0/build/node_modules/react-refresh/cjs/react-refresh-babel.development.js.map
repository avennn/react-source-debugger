{"version":3,"file":"react-refresh-babel.development.js","sources":["../../../../packages/react-refresh/src/ReactFreshBabelPlugin.js"],"sourcesContent":["/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n'use strict';\n\nexport default function(babel, opts = {}) {\n  if (typeof babel.env === 'function') {\n    // Only available in Babel 7.\n    const env = babel.env();\n    if (env !== 'development' && !opts.skipEnvCheck) {\n      throw new Error(\n        'React Refresh Babel transform should only be enabled in development environment. ' +\n          'Instead, the environment is: \"' +\n          env +\n          '\". If you want to override this check, pass {skipEnvCheck: true} as plugin options.',\n      );\n    }\n  }\n\n  const {types: t} = babel;\n  const refreshReg = t.identifier(opts.refreshReg || '$RefreshReg$');\n  const refreshSig = t.identifier(opts.refreshSig || '$RefreshSig$');\n\n  const registrationsByProgramPath = new Map();\n  function createRegistration(programPath, persistentID) {\n    const handle = programPath.scope.generateUidIdentifier('c');\n    if (!registrationsByProgramPath.has(programPath)) {\n      registrationsByProgramPath.set(programPath, []);\n    }\n    const registrations = registrationsByProgramPath.get(programPath);\n    registrations.push({\n      handle,\n      persistentID,\n    });\n    return handle;\n  }\n\n  function isComponentishName(name) {\n    return typeof name === 'string' && name[0] >= 'A' && name[0] <= 'Z';\n  }\n\n  function findInnerComponents(inferredName, path, callback) {\n    const node = path.node;\n    switch (node.type) {\n      case 'Identifier': {\n        if (!isComponentishName(node.name)) {\n          return false;\n        }\n        // export default hoc(Foo)\n        // const X = hoc(Foo)\n        callback(inferredName, node, null);\n        return true;\n      }\n      case 'FunctionDeclaration': {\n        // function Foo() {}\n        // export function Foo() {}\n        // export default function Foo() {}\n        callback(inferredName, node.id, null);\n        return true;\n      }\n      case 'ArrowFunctionExpression': {\n        if (node.body.type === 'ArrowFunctionExpression') {\n          return false;\n        }\n        // let Foo = () => {}\n        // export default hoc1(hoc2(() => {}))\n        callback(inferredName, node, path);\n        return true;\n      }\n      case 'FunctionExpression': {\n        // let Foo = function() {}\n        // const Foo = hoc1(forwardRef(function renderFoo() {}))\n        // export default memo(function() {})\n        callback(inferredName, node, path);\n        return true;\n      }\n      case 'CallExpression': {\n        const argsPath = path.get('arguments');\n        if (argsPath === undefined || argsPath.length === 0) {\n          return false;\n        }\n        const calleePath = path.get('callee');\n        switch (calleePath.node.type) {\n          case 'MemberExpression':\n          case 'Identifier': {\n            const calleeSource = calleePath.getSource();\n            const firstArgPath = argsPath[0];\n            const innerName = inferredName + '$' + calleeSource;\n            const foundInside = findInnerComponents(\n              innerName,\n              firstArgPath,\n              callback,\n            );\n            if (!foundInside) {\n              return false;\n            }\n            // const Foo = hoc1(hoc2(() => {}))\n            // export default memo(React.forwardRef(function() {}))\n            callback(inferredName, node, path);\n            return true;\n          }\n          default: {\n            return false;\n          }\n        }\n      }\n      case 'VariableDeclarator': {\n        const init = node.init;\n        if (init === null) {\n          return false;\n        }\n        const name = node.id.name;\n        if (!isComponentishName(name)) {\n          return false;\n        }\n        switch (init.type) {\n          case 'ArrowFunctionExpression':\n          case 'FunctionExpression':\n            // Likely component definitions.\n            break;\n          case 'CallExpression': {\n            // Maybe a HOC.\n            // Try to determine if this is some form of import.\n            const callee = init.callee;\n            const calleeType = callee.type;\n            if (calleeType === 'Import') {\n              return false;\n            } else if (calleeType === 'Identifier') {\n              if (callee.name.indexOf('require') === 0) {\n                return false;\n              } else if (callee.name.indexOf('import') === 0) {\n                return false;\n              }\n              // Neither require nor import. Might be a HOC.\n              // Pass through.\n            } else if (calleeType === 'MemberExpression') {\n              // Could be something like React.forwardRef(...)\n              // Pass through.\n            }\n            break;\n          }\n          case 'TaggedTemplateExpression':\n            // Maybe something like styled.div`...`\n            break;\n          default:\n            return false;\n        }\n        const initPath = path.get('init');\n        const foundInside = findInnerComponents(\n          inferredName,\n          initPath,\n          callback,\n        );\n        if (foundInside) {\n          return true;\n        }\n        // See if this identifier is used in JSX. Then it's a component.\n        const binding = path.scope.getBinding(name);\n        if (binding === undefined) {\n          return;\n        }\n        let isLikelyUsedAsType = false;\n        const referencePaths = binding.referencePaths;\n        for (let i = 0; i < referencePaths.length; i++) {\n          const ref = referencePaths[i];\n          if (\n            ref.node &&\n            ref.node.type !== 'JSXIdentifier' &&\n            ref.node.type !== 'Identifier'\n          ) {\n            continue;\n          }\n          const refParent = ref.parent;\n          if (refParent.type === 'JSXOpeningElement') {\n            isLikelyUsedAsType = true;\n          } else if (refParent.type === 'CallExpression') {\n            const callee = refParent.callee;\n            let fnName;\n            switch (callee.type) {\n              case 'Identifier':\n                fnName = callee.name;\n                break;\n              case 'MemberExpression':\n                fnName = callee.property.name;\n                break;\n            }\n            switch (fnName) {\n              case 'createElement':\n              case 'jsx':\n              case 'jsxDEV':\n              case 'jsxs':\n                isLikelyUsedAsType = true;\n                break;\n            }\n          }\n          if (isLikelyUsedAsType) {\n            // const X = ... + later <X />\n            callback(inferredName, init, initPath);\n            return true;\n          }\n        }\n      }\n    }\n    return false;\n  }\n\n  function isBuiltinHook(hookName) {\n    switch (hookName) {\n      case 'useState':\n      case 'React.useState':\n      case 'useReducer':\n      case 'React.useReducer':\n      case 'useEffect':\n      case 'React.useEffect':\n      case 'useLayoutEffect':\n      case 'React.useLayoutEffect':\n      case 'useMemo':\n      case 'React.useMemo':\n      case 'useCallback':\n      case 'React.useCallback':\n      case 'useRef':\n      case 'React.useRef':\n      case 'useContext':\n      case 'React.useContext':\n      case 'useImperativeMethods':\n      case 'React.useImperativeMethods':\n      case 'useDebugValue':\n      case 'React.useDebugValue':\n        return true;\n      default:\n        return false;\n    }\n  }\n\n  function getHookCallsSignature(functionNode) {\n    const fnHookCalls = hookCalls.get(functionNode);\n    if (fnHookCalls === undefined) {\n      return null;\n    }\n    return {\n      key: fnHookCalls.map(call => call.name + '{' + call.key + '}').join('\\n'),\n      customHooks: fnHookCalls\n        .filter(call => !isBuiltinHook(call.name))\n        .map(call => t.cloneDeep(call.callee)),\n    };\n  }\n\n  const hasForceResetCommentByFile = new WeakMap();\n\n  // We let user do /* @refresh reset */ to reset state in the whole file.\n  function hasForceResetComment(path) {\n    const file = path.hub.file;\n    let hasForceReset = hasForceResetCommentByFile.get(file);\n    if (hasForceReset !== undefined) {\n      return hasForceReset;\n    }\n\n    hasForceReset = false;\n    const comments = file.ast.comments;\n    for (let i = 0; i < comments.length; i++) {\n      const cmt = comments[i];\n      if (cmt.value.indexOf('@refresh reset') !== -1) {\n        hasForceReset = true;\n        break;\n      }\n    }\n\n    hasForceResetCommentByFile.set(file, hasForceReset);\n    return hasForceReset;\n  }\n\n  function createArgumentsForSignature(node, signature, scope) {\n    const {key, customHooks} = signature;\n\n    let forceReset = hasForceResetComment(scope.path);\n    const customHooksInScope = [];\n    customHooks.forEach(callee => {\n      // Check if a corresponding binding exists where we emit the signature.\n      let bindingName;\n      switch (callee.type) {\n        case 'MemberExpression':\n          if (callee.object.type === 'Identifier') {\n            bindingName = callee.object.name;\n          }\n          break;\n        case 'Identifier':\n          bindingName = callee.name;\n          break;\n      }\n      if (scope.hasBinding(bindingName)) {\n        customHooksInScope.push(callee);\n      } else {\n        // We don't have anything to put in the array because Hook is out of scope.\n        // Since it could potentially have been edited, remount the component.\n        forceReset = true;\n      }\n    });\n\n    let finalKey = key;\n    if (typeof require === 'function' && !opts.emitFullSignatures) {\n      // Prefer to hash when we can (e.g. outside of ASTExplorer).\n      // This makes it deterministically compact, even if there's\n      // e.g. a useState initializer with some code inside.\n      // We also need it for www that has transforms like cx()\n      // that don't understand if something is part of a string.\n      finalKey = require('crypto')\n        .createHash('sha1')\n        .update(key)\n        .digest('base64');\n    }\n\n    const args = [node, t.stringLiteral(finalKey)];\n    if (forceReset || customHooksInScope.length > 0) {\n      args.push(t.booleanLiteral(forceReset));\n    }\n    if (customHooksInScope.length > 0) {\n      args.push(\n        // TODO: We could use an arrow here to be more compact.\n        // However, don't do it until AMA can run them natively.\n        t.functionExpression(\n          null,\n          [],\n          t.blockStatement([\n            t.returnStatement(t.arrayExpression(customHooksInScope)),\n          ]),\n        ),\n      );\n    }\n    return args;\n  }\n\n  const seenForRegistration = new WeakSet();\n  const seenForSignature = new WeakSet();\n  const seenForOutro = new WeakSet();\n\n  const hookCalls = new WeakMap();\n  const HookCallsVisitor = {\n    CallExpression(path) {\n      const node = path.node;\n      const callee = node.callee;\n\n      // Note: this visitor MUST NOT mutate the tree in any way.\n      // It runs early in a separate traversal and should be very fast.\n\n      let name = null;\n      switch (callee.type) {\n        case 'Identifier':\n          name = callee.name;\n          break;\n        case 'MemberExpression':\n          name = callee.property.name;\n          break;\n      }\n      if (name === null || !/^use[A-Z]/.test(name)) {\n        return;\n      }\n      const fnScope = path.scope.getFunctionParent();\n      if (fnScope === null) {\n        return;\n      }\n\n      // This is a Hook call. Record it.\n      const fnNode = fnScope.block;\n      if (!hookCalls.has(fnNode)) {\n        hookCalls.set(fnNode, []);\n      }\n      const hookCallsForFn = hookCalls.get(fnNode);\n      let key = '';\n      if (path.parent.type === 'VariableDeclarator') {\n        // TODO: if there is no LHS, consider some other heuristic.\n        key = path.parentPath.get('id').getSource();\n      }\n\n      // Some built-in Hooks reset on edits to arguments.\n      const args = path.get('arguments');\n      if (name === 'useState' && args.length > 0) {\n        // useState second argument is initial state.\n        key += '(' + args[0].getSource() + ')';\n      } else if (name === 'useReducer' && args.length > 1) {\n        // useReducer second argument is initial state.\n        key += '(' + args[1].getSource() + ')';\n      }\n\n      hookCallsForFn.push({\n        callee: path.node.callee,\n        name,\n        key,\n      });\n    },\n  };\n\n  return {\n    visitor: {\n      ExportDefaultDeclaration(path) {\n        const node = path.node;\n        const decl = node.declaration;\n        const declPath = path.get('declaration');\n        if (decl.type !== 'CallExpression') {\n          // For now, we only support possible HOC calls here.\n          // Named function declarations are handled in FunctionDeclaration.\n          // Anonymous direct exports like export default function() {}\n          // are currently ignored.\n          return;\n        }\n\n        // Make sure we're not mutating the same tree twice.\n        // This can happen if another Babel plugin replaces parents.\n        if (seenForRegistration.has(node)) {\n          return;\n        }\n        seenForRegistration.add(node);\n        // Don't mutate the tree above this point.\n\n        // This code path handles nested cases like:\n        // export default memo(() => {})\n        // In those cases it is more plausible people will omit names\n        // so they're worth handling despite possible false positives.\n        // More importantly, it handles the named case:\n        // export default memo(function Named() {})\n        const inferredName = '%default%';\n        const programPath = path.parentPath;\n        findInnerComponents(\n          inferredName,\n          declPath,\n          (persistentID, targetExpr, targetPath) => {\n            if (targetPath === null) {\n              // For case like:\n              // export default hoc(Foo)\n              // we don't want to wrap Foo inside the call.\n              // Instead we assume it's registered at definition.\n              return;\n            }\n            const handle = createRegistration(programPath, persistentID);\n            targetPath.replaceWith(\n              t.assignmentExpression('=', handle, targetExpr),\n            );\n          },\n        );\n      },\n      FunctionDeclaration: {\n        enter(path) {\n          const node = path.node;\n          let programPath;\n          let insertAfterPath;\n          switch (path.parent.type) {\n            case 'Program':\n              insertAfterPath = path;\n              programPath = path.parentPath;\n              break;\n            case 'ExportNamedDeclaration':\n              insertAfterPath = path.parentPath;\n              programPath = insertAfterPath.parentPath;\n              break;\n            case 'ExportDefaultDeclaration':\n              insertAfterPath = path.parentPath;\n              programPath = insertAfterPath.parentPath;\n              break;\n            default:\n              return;\n          }\n          const id = node.id;\n          if (id === null) {\n            // We don't currently handle anonymous default exports.\n            return;\n          }\n          const inferredName = id.name;\n          if (!isComponentishName(inferredName)) {\n            return;\n          }\n\n          // Make sure we're not mutating the same tree twice.\n          // This can happen if another Babel plugin replaces parents.\n          if (seenForRegistration.has(node)) {\n            return;\n          }\n          seenForRegistration.add(node);\n          // Don't mutate the tree above this point.\n\n          // export function Named() {}\n          // function Named() {}\n          findInnerComponents(\n            inferredName,\n            path,\n            (persistentID, targetExpr) => {\n              const handle = createRegistration(programPath, persistentID);\n              insertAfterPath.insertAfter(\n                t.expressionStatement(\n                  t.assignmentExpression('=', handle, targetExpr),\n                ),\n              );\n            },\n          );\n        },\n        exit(path) {\n          const node = path.node;\n          const id = node.id;\n          if (id === null) {\n            return;\n          }\n          const signature = getHookCallsSignature(node);\n          if (signature === null) {\n            return;\n          }\n\n          // Make sure we're not mutating the same tree twice.\n          // This can happen if another Babel plugin replaces parents.\n          if (seenForSignature.has(node)) {\n            return;\n          }\n          seenForSignature.add(node);\n          // Don't mutate the tree above this point.\n\n          const sigCallID = path.scope.generateUidIdentifier('_s');\n          path.scope.parent.push({\n            id: sigCallID,\n            init: t.callExpression(refreshSig, []),\n          });\n\n          // The signature call is split in two parts. One part is called inside the function.\n          // This is used to signal when first render happens.\n          path\n            .get('body')\n            .unshiftContainer(\n              'body',\n              t.expressionStatement(t.callExpression(sigCallID, [])),\n            );\n\n          // The second call is around the function itself.\n          // This is used to associate a type with a signature.\n\n          // Unlike with $RefreshReg$, this needs to work for nested\n          // declarations too. So we need to search for a path where\n          // we can insert a statement rather than hard coding it.\n          let insertAfterPath = null;\n          path.find(p => {\n            if (p.parentPath.isBlock()) {\n              insertAfterPath = p;\n              return true;\n            }\n          });\n          if (insertAfterPath === null) {\n            return;\n          }\n\n          insertAfterPath.insertAfter(\n            t.expressionStatement(\n              t.callExpression(\n                sigCallID,\n                createArgumentsForSignature(\n                  id,\n                  signature,\n                  insertAfterPath.scope,\n                ),\n              ),\n            ),\n          );\n        },\n      },\n      'ArrowFunctionExpression|FunctionExpression': {\n        exit(path) {\n          const node = path.node;\n          const signature = getHookCallsSignature(node);\n          if (signature === null) {\n            return;\n          }\n\n          // Make sure we're not mutating the same tree twice.\n          // This can happen if another Babel plugin replaces parents.\n          if (seenForSignature.has(node)) {\n            return;\n          }\n          seenForSignature.add(node);\n          // Don't mutate the tree above this point.\n\n          const sigCallID = path.scope.generateUidIdentifier('_s');\n          path.scope.parent.push({\n            id: sigCallID,\n            init: t.callExpression(refreshSig, []),\n          });\n\n          // The signature call is split in two parts. One part is called inside the function.\n          // This is used to signal when first render happens.\n          if (path.node.body.type !== 'BlockStatement') {\n            path.node.body = t.blockStatement([\n              t.returnStatement(path.node.body),\n            ]);\n          }\n          path\n            .get('body')\n            .unshiftContainer(\n              'body',\n              t.expressionStatement(t.callExpression(sigCallID, [])),\n            );\n\n          // The second call is around the function itself.\n          // This is used to associate a type with a signature.\n\n          if (path.parent.type === 'VariableDeclarator') {\n            let insertAfterPath = null;\n            path.find(p => {\n              if (p.parentPath.isBlock()) {\n                insertAfterPath = p;\n                return true;\n              }\n            });\n            if (insertAfterPath === null) {\n              return;\n            }\n            // Special case when a function would get an inferred name:\n            // let Foo = () => {}\n            // let Foo = function() {}\n            // We'll add signature it on next line so that\n            // we don't mess up the inferred 'Foo' function name.\n            insertAfterPath.insertAfter(\n              t.expressionStatement(\n                t.callExpression(\n                  sigCallID,\n                  createArgumentsForSignature(\n                    path.parent.id,\n                    signature,\n                    insertAfterPath.scope,\n                  ),\n                ),\n              ),\n            );\n            // Result: let Foo = () => {}; __signature(Foo, ...);\n          } else {\n            // let Foo = hoc(() => {})\n            path.replaceWith(\n              t.callExpression(\n                sigCallID,\n                createArgumentsForSignature(node, signature, path.scope),\n              ),\n            );\n            // Result: let Foo = hoc(__signature(() => {}, ...))\n          }\n        },\n      },\n      VariableDeclaration(path) {\n        const node = path.node;\n        let programPath;\n        let insertAfterPath;\n        switch (path.parent.type) {\n          case 'Program':\n            insertAfterPath = path;\n            programPath = path.parentPath;\n            break;\n          case 'ExportNamedDeclaration':\n            insertAfterPath = path.parentPath;\n            programPath = insertAfterPath.parentPath;\n            break;\n          case 'ExportDefaultDeclaration':\n            insertAfterPath = path.parentPath;\n            programPath = insertAfterPath.parentPath;\n            break;\n          default:\n            return;\n        }\n\n        // Make sure we're not mutating the same tree twice.\n        // This can happen if another Babel plugin replaces parents.\n        if (seenForRegistration.has(node)) {\n          return;\n        }\n        seenForRegistration.add(node);\n        // Don't mutate the tree above this point.\n\n        const declPaths = path.get('declarations');\n        if (declPaths.length !== 1) {\n          return;\n        }\n        const declPath = declPaths[0];\n        const inferredName = declPath.node.id.name;\n        findInnerComponents(\n          inferredName,\n          declPath,\n          (persistentID, targetExpr, targetPath) => {\n            if (targetPath === null) {\n              // For case like:\n              // export const Something = hoc(Foo)\n              // we don't want to wrap Foo inside the call.\n              // Instead we assume it's registered at definition.\n              return;\n            }\n            const handle = createRegistration(programPath, persistentID);\n            if (targetPath.parent.type === 'VariableDeclarator') {\n              // Special case when a variable would get an inferred name:\n              // let Foo = () => {}\n              // let Foo = function() {}\n              // let Foo = styled.div``;\n              // We'll register it on next line so that\n              // we don't mess up the inferred 'Foo' function name.\n              // (eg: with @babel/plugin-transform-react-display-name or\n              // babel-plugin-styled-components)\n              insertAfterPath.insertAfter(\n                t.expressionStatement(\n                  t.assignmentExpression('=', handle, declPath.node.id),\n                ),\n              );\n              // Result: let Foo = () => {}; _c1 = Foo;\n            } else {\n              // let Foo = hoc(() => {})\n              targetPath.replaceWith(\n                t.assignmentExpression('=', handle, targetExpr),\n              );\n              // Result: let Foo = hoc(_c1 = () => {})\n            }\n          },\n        );\n      },\n      Program: {\n        enter(path) {\n          // This is a separate early visitor because we need to collect Hook calls\n          // and \"const [foo, setFoo] = ...\" signatures before the destructuring\n          // transform mangles them. This extra traversal is not ideal for perf,\n          // but it's the best we can do until we stop transpiling destructuring.\n          path.traverse(HookCallsVisitor);\n        },\n        exit(path) {\n          const registrations = registrationsByProgramPath.get(path);\n          if (registrations === undefined) {\n            return;\n          }\n\n          // Make sure we're not mutating the same tree twice.\n          // This can happen if another Babel plugin replaces parents.\n          const node = path.node;\n          if (seenForOutro.has(node)) {\n            return;\n          }\n          seenForOutro.add(node);\n          // Don't mutate the tree above this point.\n\n          registrationsByProgramPath.delete(path);\n          const declarators = [];\n          path.pushContainer('body', t.variableDeclaration('var', declarators));\n          registrations.forEach(({handle, persistentID}) => {\n            path.pushContainer(\n              'body',\n              t.expressionStatement(\n                t.callExpression(refreshReg, [\n                  handle,\n                  t.stringLiteral(persistentID),\n                ]),\n              ),\n            );\n            declarators.push(t.variableDeclarator(handle));\n          });\n        },\n      },\n    },\n  };\n}\n"],"names":["babel","opts","env","skipEnvCheck","Error","t","types","refreshReg","identifier","refreshSig","registrationsByProgramPath","Map","createRegistration","programPath","persistentID","handle","scope","generateUidIdentifier","has","set","registrations","get","push","isComponentishName","name","findInnerComponents","inferredName","path","callback","node","type","id","body","argsPath","undefined","length","calleePath","calleeSource","getSource","firstArgPath","innerName","foundInside","init","callee","calleeType","indexOf","initPath","binding","getBinding","isLikelyUsedAsType","referencePaths","i","ref","refParent","parent","fnName","property","isBuiltinHook","hookName","getHookCallsSignature","functionNode","fnHookCalls","hookCalls","key","map","call","join","customHooks","filter","cloneDeep","hasForceResetCommentByFile","WeakMap","hasForceResetComment","file","hub","hasForceReset","comments","ast","cmt","value","createArgumentsForSignature","signature","forceReset","customHooksInScope","forEach","bindingName","object","hasBinding","finalKey","require","emitFullSignatures","createHash","update","digest","args","stringLiteral","booleanLiteral","functionExpression","blockStatement","returnStatement","arrayExpression","seenForRegistration","WeakSet","seenForSignature","seenForOutro","HookCallsVisitor","CallExpression","test","fnScope","getFunctionParent","fnNode","block","hookCallsForFn","parentPath","visitor","ExportDefaultDeclaration","decl","declaration","declPath","add","targetExpr","targetPath","replaceWith","assignmentExpression","FunctionDeclaration","enter","insertAfterPath","insertAfter","expressionStatement","exit","sigCallID","callExpression","unshiftContainer","find","p","isBlock","VariableDeclaration","declPaths","Program","traverse","delete","declarators","pushContainer","variableDeclaration","variableDeclarator"],"mappings":"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"}