'use strict';

var React = require('react');

// Do not require this module directly! Use normal `invariant` calls with
// template literal strings. The messages will be replaced with error codes
// during build.
function formatProdErrorMessage(code) {
  let url = 'https://reactjs.org/docs/error-decoder.html?invariant=' + code;

  for (let i = 1; i < arguments.length; i++) {
    url += '&args[]=' + encodeURIComponent(arguments[i]);
  }

  return "Minified React error #" + code + "; visit " + url + " for the full message or " + 'use the non-minified dev environment for full errors and additional ' + 'helpful warnings.';
}

function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  subClass.__proto__ = superClass;
}

function createSubscription(config) {
  const getCurrentValue = config.getCurrentValue,
        _subscribe = config.subscribe;

  // Reference: https://gist.github.com/bvaughn/d569177d70b50b58bff69c3c4a5353f3
  let Subscription = /*#__PURE__*/function (_React$Component) {
    _inheritsLoose(Subscription, _React$Component);

    function Subscription() {
      var _this;

      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      _this = _React$Component.call.apply(_React$Component, [this].concat(args)) || this;
      _this.state = {
        source: _this.props.source,
        value: _this.props.source != null ? getCurrentValue(_this.props.source) : undefined
      };
      _this._hasUnmounted = false;
      _this._unsubscribe = null;
      return _this;
    }

    Subscription.getDerivedStateFromProps = function getDerivedStateFromProps(nextProps, prevState) {
      if (nextProps.source !== prevState.source) {
        return {
          source: nextProps.source,
          value: nextProps.source != null ? getCurrentValue(nextProps.source) : undefined
        };
      }

      return null;
    };

    var _proto = Subscription.prototype;

    _proto.componentDidMount = function componentDidMount() {
      this.subscribe();
    };

    _proto.componentDidUpdate = function componentDidUpdate(prevProps, prevState) {
      if (this.state.source !== prevState.source) {
        this.unsubscribe();
        this.subscribe();
      }
    };

    _proto.componentWillUnmount = function componentWillUnmount() {
      this.unsubscribe(); // Track mounted to avoid calling setState after unmounting
      // For source like Promises that can't be unsubscribed from.

      this._hasUnmounted = true;
    };

    _proto.render = function render() {
      return this.props.children(this.state.value);
    };

    _proto.subscribe = function subscribe() {
      const source = this.state.source;

      if (source != null) {
        const callback = value => {
          if (this._hasUnmounted) {
            return;
          }

          this.setState(state => {
            // If the value is the same, skip the unnecessary state update.
            if (value === state.value) {
              return null;
            } // If this event belongs to an old or uncommitted data source, ignore it.


            if (source !== state.source) {
              return null;
            }

            return {
              value
            };
          });
        }; // Store the unsubscribe method for later (in case the subscribable prop changes).


        const unsubscribe = _subscribe(source, callback);

        if (!(typeof unsubscribe === 'function')) {
          {
            throw Error( formatProdErrorMessage(266));
          }
        } // It's safe to store unsubscribe on the instance because
        // We only read or write that property during the "commit" phase.


        this._unsubscribe = unsubscribe; // External values could change between render and mount,
        // In some cases it may be important to handle this case.

        const value = getCurrentValue(this.props.source);

        if (value !== this.state.value) {
          this.setState({
            value
          });
        }
      }
    };

    _proto.unsubscribe = function unsubscribe() {
      if (typeof this._unsubscribe === 'function') {
        this._unsubscribe();
      }

      this._unsubscribe = null;
    };

    return Subscription;
  }(React.Component);

  return Subscription;
}

exports.createSubscription = createSubscription;
//# sourceMappingURL=create-subscription.production.min.js.map
